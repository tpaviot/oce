// This file is generated by WOK (CPPExt).
// Please do not edit this file; modify original file instead.
// The copyright and license terms as defined for the original file apply to 
// this header file considered to be the "object code" form of the original source.

#ifndef _IntPatch_PrmPrmIntersection_HeaderFile
#define _IntPatch_PrmPrmIntersection_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_DefineAlloc_HeaderFile
#include <Standard_DefineAlloc.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _Standard_Real_HeaderFile
#include <Standard_Real.hxx>
#endif
#ifndef _IntPatch_SequenceOfLine_HeaderFile
#include <IntPatch_SequenceOfLine.hxx>
#endif
#ifndef _Handle_Adaptor3d_HSurface_HeaderFile
#include <Handle_Adaptor3d_HSurface.hxx>
#endif
#ifndef _Handle_Adaptor3d_TopolTool_HeaderFile
#include <Handle_Adaptor3d_TopolTool.hxx>
#endif
#ifndef _Standard_Integer_HeaderFile
#include <Standard_Integer.hxx>
#endif
#ifndef _Handle_IntPatch_Line_HeaderFile
#include <Handle_IntPatch_Line.hxx>
#endif
#ifndef _Handle_IntSurf_LineOn2S_HeaderFile
#include <Handle_IntSurf_LineOn2S.hxx>
#endif
class Standard_OutOfRange;
class StdFail_NotDone;
class Adaptor3d_HSurface;
class IntPatch_Polyhedron;
class Adaptor3d_TopolTool;
class IntSurf_ListOfPntOn2S;
class IntPatch_Line;
class IntPatch_PrmPrmIntersection_T3Bits;
class IntSurf_LineOn2S;


//! Implementation  of   the Intersection      between two <br>
//!          bi-parametrised surfaces. <br>
//! <br>
//!          To  avoid  multiple constructions of  the approximated <br>
//!          polyhedron  of the    surfaces, the algorithm  can  be <br>
//!          called whith the  two  surfaces  and their  associated <br>
//!          polyhedron. <br>
//! <br>
class IntPatch_PrmPrmIntersection  {
public:

  DEFINE_STANDARD_ALLOC

  //! Empty Constructor <br>
  Standard_EXPORT   IntPatch_PrmPrmIntersection();
  //! Performs the intersection between <Caro1>  and <br>
//!          <Caro2>.  Associated Polyhedrons <Polyhedron1> <br>
//!          and <Polyhedron2> are given. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const IntPatch_Polyhedron& Polyhedron1,const Handle(Adaptor3d_TopolTool)& Domain1,const Handle(Adaptor3d_HSurface)& Caro2,const IntPatch_Polyhedron& Polyhedron2,const Handle(Adaptor3d_TopolTool)& Domain2,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment) ;
  
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const IntPatch_Polyhedron& Polyhedron1,const Handle(Adaptor3d_TopolTool)& Domain1,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment) ;
  //! Performs the intersection between <Caro1>  and <br>
//!          <Caro2>. The method computes the polyhedron on <br>
//!          each surface. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const Handle(Adaptor3d_TopolTool)& Domain1,const Handle(Adaptor3d_HSurface)& Caro2,const Handle(Adaptor3d_TopolTool)& Domain2,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment,const Standard_Boolean ClearFlag = Standard_True) ;
  //! Performs the intersection between <Caro1>  and <br>
//!          <Caro2>. The method computes the polyhedron on <br>
//!          each surface. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const Handle(Adaptor3d_TopolTool)& Domain1,const Handle(Adaptor3d_HSurface)& Caro2,const Handle(Adaptor3d_TopolTool)& Domain2,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment,IntSurf_ListOfPntOn2S& ListOfPnts,const Standard_Boolean RestrictLine) ;
  //! Performs the intersection between <Caro1>  and <br>
//!          <Caro2>. The method computes the polyhedron on <br>
//!          each surface. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const Handle(Adaptor3d_TopolTool)& Domain1,const Handle(Adaptor3d_HSurface)& Caro2,const Handle(Adaptor3d_TopolTool)& Domain2,const Standard_Real U1,const Standard_Real V1,const Standard_Real U2,const Standard_Real V2,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment) ;
  //! Performs the intersection between <Caro1>  and <br>
//!          <Caro2>. The method computes the polyhedron on <br>
//!          each surface. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const Handle(Adaptor3d_TopolTool)& Domain1,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment) ;
  //! Performs  the intersection between <Caro1> and <br>
//!          <Caro2>. <br>
//! <br>
//!          The polyhedron which approximates     <Caro2>, <br>
//!          <Polyhedron2> is given. The other one is <br>
//!          computed. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const Handle(Adaptor3d_TopolTool)& Domain1,const Handle(Adaptor3d_HSurface)& Caro2,const IntPatch_Polyhedron& Polyhedron2,const Handle(Adaptor3d_TopolTool)& Domain2,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment) ;
  //! Performs  the intersection between <Caro1> and <br>
//!          <Caro2>. <br>
//! <br>
//!          The polyhedron which approximates     <Caro1>, <br>
//!          <Polyhedron1> is given. The other one is <br>
//!          computed. <br>
  Standard_EXPORT     void Perform(const Handle(Adaptor3d_HSurface)& Caro1,const IntPatch_Polyhedron& Polyhedron1,const Handle(Adaptor3d_TopolTool)& Domain1,const Handle(Adaptor3d_HSurface)& Caro2,const Handle(Adaptor3d_TopolTool)& Domain2,const Standard_Real TolTangency,const Standard_Real Epsilon,const Standard_Real Deflection,const Standard_Real Increment) ;
  //! Returns true if the calculus was succesfull. <br>
        Standard_Boolean IsDone() const;
  //! Returns true if the is no intersection. <br>
        Standard_Boolean IsEmpty() const;
  //! Returns the number of intersection lines. <br>
        Standard_Integer NbLines() const;
  //! Returns the line of range Index. <br>
//!          An exception is raised if Index<=0 or Index>NbLine. <br>
       const Handle_IntPatch_Line& Line(const Standard_Integer Index) const;
  //! Computes about <NbPoints>  Intersection Points  on <br>
//!          the Line <IndexLine> between  the Points of  Index <br>
//!          <LowPoint> and <HighPoint>. <br>
//! <br>
//!          All  the points  of the line  of index <IndexLine> <br>
//!          with an index  between <LowPoint>  and <HighPoint> <br>
//!          are in the returned  line. New Points are inserted <br>
//!          between existing points  if  those  points are not <br>
//!          too closed. <br>
//! <br>
//!          An exception is raised if Index<=0 or Index>NbLine. <br>
//!          or if IsDone returns False <br>
  Standard_EXPORT     Handle_IntPatch_Line NewLine(const Handle(Adaptor3d_HSurface)& Caro1,const Handle(Adaptor3d_HSurface)& Caro2,const Standard_Integer IndexLine,const Standard_Integer LowPoint,const Standard_Integer HighPoint,const Standard_Integer NbPoints) const;
  
        Standard_Integer GrilleInteger(const Standard_Integer ix,const Standard_Integer iy,const Standard_Integer iz) const;
  
        void IntegerGrille(const Standard_Integer t,Standard_Integer& ix,Standard_Integer& iy,Standard_Integer& iz) const;
  
        Standard_Integer DansGrille(const Standard_Integer t) const;
  
        Standard_Integer NbPointsGrille() const;
  
  Standard_EXPORT     void RemplitLin(const Standard_Integer x1,const Standard_Integer y1,const Standard_Integer z1,const Standard_Integer x2,const Standard_Integer y2,const Standard_Integer z2,IntPatch_PrmPrmIntersection_T3Bits& Map) const;
  
  Standard_EXPORT     void RemplitTri(const Standard_Integer x1,const Standard_Integer y1,const Standard_Integer z1,const Standard_Integer x2,const Standard_Integer y2,const Standard_Integer z2,const Standard_Integer x3,const Standard_Integer y3,const Standard_Integer z3,IntPatch_PrmPrmIntersection_T3Bits& Map) const;
  
  Standard_EXPORT     void Remplit(const Standard_Integer a,const Standard_Integer b,const Standard_Integer c,IntPatch_PrmPrmIntersection_T3Bits& Map) const;
  
  Standard_EXPORT     Standard_Integer CodeReject(const Standard_Real x1,const Standard_Real y1,const Standard_Real z1,const Standard_Real x2,const Standard_Real y2,const Standard_Real z2,const Standard_Real x3,const Standard_Real y3,const Standard_Real z3) const;
  
  Standard_EXPORT     void PointDepart(Handle(IntSurf_LineOn2S)& LineOn2S,const Handle(Adaptor3d_HSurface)& S1,const Standard_Integer SU1,const Standard_Integer SV1,const Handle(Adaptor3d_HSurface)& S2,const Standard_Integer SU2,const Standard_Integer SV2) const;





protected:





private:



Standard_Boolean done;
Standard_Boolean empt;
Standard_Real Preci;
Standard_Real Fleche;
Standard_Real Pas;
IntPatch_SequenceOfLine SLin;


};


#include <IntPatch_PrmPrmIntersection.lxx>



// other Inline functions and methods (like "C++: function call" methods)


#endif
