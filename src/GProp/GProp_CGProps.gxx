// Copyright (c) 1995-1999 Matra Datavision
// Copyright (c) 1999-2012 OPEN CASCADE SAS
//
// The content of this file is subject to the Open CASCADE Technology Public
// License Version 6.5 (the "License"). You may not use the content of this file
// except in compliance with the License. Please obtain a copy of the License
// at http://www.opencascade.org and read it completely before using this file.
//
// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
//
// The Original Code and all software distributed under the License is
// distributed on an "AS IS" basis, without warranty of any kind, and the
// Initial Developer hereby disclaims all such warranties, including without
// limitation, any warranties of merchantability, fitness for a particular
// purpose or non-infringement. Please see the License for the specific terms
// and conditions governing the rights and limitations under the License.

#include <math.hxx>
#include <math_Vector.hxx>
#include <gp.hxx>
#include <gp_Vec.hxx>
#include <Standard_NotImplemented.hxx>

#include <TColStd_Array1OfReal.hxx>


GProp_CGProps::GProp_CGProps(){}

void GProp_CGProps::SetLocation(const gp_Pnt& CLocation)
{
  loc = CLocation;
}

void GProp_CGProps::Perform (const Curve& C)
{

  Standard_Real Ix, Iy, Iz, Ixx, Iyy, Izz, Ixy, Ixz, Iyz;
  dim = Ix = Iy = Iz = Ixx = Iyy = Izz = Ixy = Ixz = Iyz = 0.0;

  Standard_Real Lower    = Tool::FirstParameter  (C);
  Standard_Real Upper    = Tool::LastParameter   (C);
  Standard_Integer Order = Min(Tool::IntegrationOrder (C),
			       math::GaussPointsMax());
  
  gp_Pnt P;    //value on the curve
  gp_Vec V1;   //first derivative on the curve
  Standard_Real ds;  //curvilign abscissae
  Standard_Real ur, um, u;
  Standard_Real x, y, z; 
  Standard_Real xloc, yloc, zloc;

  math_Vector GaussP (1, Order);
  math_Vector GaussW (1, Order);
  
  //Recuperation des points de Gauss dans le fichier GaussPoints.
  math::GaussPoints  (Order,GaussP);
  math::GaussWeights (Order,GaussW);

  // modified by NIZHNY-MKK  Thu Jun  9 12:13:21 2005.BEGIN
  Standard_Integer nbIntervals = Tool::NbIntervals(C, GeomAbs_CN);
  Standard_Boolean bHasIntervals = (nbIntervals > 1);
  TColStd_Array1OfReal TI(1, nbIntervals + 1);

  if(bHasIntervals) {
    Tool::Intervals(C, TI, GeomAbs_CN);
  }
  else {
    nbIntervals = 1;
  }
  Standard_Integer nIndex = 0;
  Standard_Real UU1 = Min(Lower, Upper);
  Standard_Real UU2 = Max(Lower, Upper);
  
  for(nIndex = 1; nIndex <= nbIntervals; nIndex++) {
    if(bHasIntervals) {
      Lower = Max(TI(nIndex), UU1);
      Upper = Min(TI(nIndex+1), UU2);
    }
    else {
      Lower = UU1;
      Upper = UU2;
    }

    Standard_Real dimLocal, IxLocal, IyLocal, IzLocal, IxxLocal, IyyLocal, IzzLocal, IxyLocal, IxzLocal, IyzLocal;
    dimLocal = IxLocal = IyLocal = IzLocal = IxxLocal = IyyLocal = IzzLocal = IxyLocal = IxzLocal = IyzLocal = 0.0;
  // modified by NIZHNY-MKK  Thu Jun  9 12:13:32 2005.END

    loc.Coord (xloc, yloc, zloc);

    Standard_Integer i;

    // Calcul des integrales aux points de gauss :
    um = 0.5 * (Upper + Lower);
    ur = 0.5 * (Upper - Lower);

    for (i = 1; i <= Order; i++) {
      u   = um + ur * GaussP (i);
      Tool::D1 (C,u, P, V1); 
      ds  = V1.Magnitude();
      P.Coord (x, y, z);
      x   -= xloc;
      y   -= yloc;
      z   -= zloc;
      ds  *= GaussW (i);
      dimLocal += ds; 
      IxLocal  += x * ds;  
      IyLocal  += y * ds;
      IzLocal  += z * ds;
      IxyLocal += x * y * ds;
      IyzLocal += y * z * ds;
      IxzLocal += x * z * ds;
      x   *= x;      
      y   *= y;      
      z   *= z;      
      IxxLocal += (y + z) * ds;
      IyyLocal += (x + z) * ds;
      IzzLocal += (x + y) * ds;
    }
    // modified by NIZHNY-MKK  Thu Jun  9 12:13:47 2005.BEGIN
    dimLocal *= ur;
    IxLocal  *= ur;
    IyLocal  *= ur;
    IzLocal  *= ur;
    IxxLocal *= ur;
    IyyLocal *= ur;
    IzzLocal *= ur;
    IxyLocal *= ur;
    IxzLocal *= ur;
    IyzLocal *= ur;

    dim += dimLocal;
    Ix += IxLocal;
    Iy += IyLocal;
    Iz += IzLocal;
    Ixx += IxxLocal;
    Iyy += IyyLocal;
    Izz += IzzLocal;
    Ixy += IxyLocal;
    Ixz += IxzLocal;
    Iyz += IyzLocal;
  }
  // modified by NIZHNY-MKK  Thu Jun  9 12:13:55 2005.END

  inertia = gp_Mat (gp_XYZ (Ixx, -Ixy, -Ixz),
		    gp_XYZ (-Ixy, Iyy, -Iyz),
		    gp_XYZ (-Ixz, -Iyz, Izz));

  if (Abs(dim) < gp::Resolution())
    g = P;
  else
    g.SetCoord (Ix/dim, Iy/dim, Iz/dim);
}


GProp_CGProps::GProp_CGProps (const Curve& C, 
			      const gp_Pnt&   CLocation)
{
  SetLocation(CLocation);
  Perform(C);
}
