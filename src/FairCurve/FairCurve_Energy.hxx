// This file is generated by WOK (CPPExt).
// Please do not edit this file; modify original file instead.
// The copyright and license terms as defined for the original file apply to 
// this header file considered to be the "object code" form of the original source.

#ifndef _FairCurve_Energy_HeaderFile
#define _FairCurve_Energy_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_DefineAlloc_HeaderFile
#include <Standard_DefineAlloc.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

#ifndef _Handle_TColgp_HArray1OfPnt2d_HeaderFile
#include <Handle_TColgp_HArray1OfPnt2d.hxx>
#endif
#ifndef _Standard_Integer_HeaderFile
#include <Standard_Integer.hxx>
#endif
#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _TColgp_Array1OfXY_HeaderFile
#include <TColgp_Array1OfXY.hxx>
#endif
#ifndef _math_Vector_HeaderFile
#include <math_Vector.hxx>
#endif
#ifndef _math_MultipleVarFunctionWithHessian_HeaderFile
#include <math_MultipleVarFunctionWithHessian.hxx>
#endif
#ifndef _Standard_Real_HeaderFile
#include <Standard_Real.hxx>
#endif
class TColgp_HArray1OfPnt2d;
class math_Vector;
class math_Matrix;
class gp_Pnt2d;


//! necessary methodes to compute the energy of an FairCurve. <br>
class FairCurve_Energy  : public math_MultipleVarFunctionWithHessian {
public:

  DEFINE_STANDARD_ALLOC

  //! returns the number of variables of the energy. <br>
      virtual  Standard_Integer NbVariables() const;
  //! computes the values of the Energys E for the <br>
//!          variable <X>. <br>
//!          Returns True if the computation was done successfully, <br>
//!          False otherwise. <br>
  Standard_EXPORT   virtual  Standard_Boolean Value(const math_Vector& X,Standard_Real& E) ;
  //!computes the gradient <G> of the energys for the <br>
//!         variable <X>. <br>
//!         Returns True if the computation was done successfully, <br>
//!         False otherwise. <br>
  Standard_EXPORT   virtual  Standard_Boolean Gradient(const math_Vector& X,math_Vector& G) ;
  //! computes the Energy <E> and the gradient <G> of the <br>
//!          energy for the variable <X>. <br>
//!          Returns True if the computation was done successfully, <br>
//!          False otherwise. <br>
  Standard_EXPORT   virtual  Standard_Boolean Values(const math_Vector& X,Standard_Real& E,math_Vector& G) ;
  //! computes the Energy  <E>, the gradient <G> and the <br>
//!          Hessian   <H> of  the  energy  for  the   variable <X>. <br>
//!          Returns   True  if    the  computation   was  done <br>
//!          successfully, False otherwise. <br>
  Standard_EXPORT   virtual  Standard_Boolean Values(const math_Vector& X,Standard_Real& E,math_Vector& G,math_Matrix& H) ;
  //! compute the variables <X> wich correspond with the field <MyPoles> <br>
  Standard_EXPORT   virtual  Standard_Boolean Variable(math_Vector& X) const;
  //! return  the  poles <br>
       const Handle_TColgp_HArray1OfPnt2d& Poles() const;





protected:

  //! Angles corresspond to the Ox axis <br>
//!          ConstrOrder1(2) can be equal to 0, 1 or 2 <br>
  Standard_EXPORT   FairCurve_Energy(const Handle(TColgp_HArray1OfPnt2d)& Poles,const Standard_Integer ConstrOrder1,const Standard_Integer ConstrOrder2,const Standard_Boolean WithAuxValue = Standard_False,const Standard_Real Angle1 = 0,const Standard_Real Angle2 = 0,const Standard_Integer Degree = 2,const Standard_Real Curvature1 = 0,const Standard_Real Curvature2 = 0);
  //! It is use internaly to make the Gradient Vector <G> <br>
  Standard_EXPORT     void Gradient1(const math_Vector& TheVector,math_Vector& G) ;
  //! It is use internaly to make the Hessian Matrix <H> <br>
  Standard_EXPORT     void Hessian1(const math_Vector& TheVector,math_Matrix& H) ;
  //! compute  the  poles wich correspond with the variable X <br>
  Standard_EXPORT   virtual  void ComputePoles(const math_Vector& X) ;
  
        Standard_Integer Indice(const Standard_Integer i,const Standard_Integer j) const;
  //! compute  the  pole wich depend of variables and G1 constraint <br>
  Standard_EXPORT     void ComputePolesG1(const Standard_Integer Side,const Standard_Real Lambda,const gp_Pnt2d& P1,gp_Pnt2d& P2) const;
  //! compute  the  pole wich depend of variables and G2 constraint <br>
  Standard_EXPORT     void ComputePolesG2(const Standard_Integer Side,const Standard_Real Lambda,const Standard_Real Rho,const gp_Pnt2d& P1,gp_Pnt2d& P2) const;
  //! compute the energy (and derivatives) in intermediat format <br>
  Standard_EXPORT   virtual  Standard_Boolean Compute(const Standard_Integer DerivativeOrder,math_Vector& Result)  = 0;


Handle_TColgp_HArray1OfPnt2d MyPoles;
Standard_Integer MyContrOrder1;
Standard_Integer MyContrOrder2;
Standard_Boolean MyWithAuxValue;
Standard_Integer MyNbVar;


private:



Standard_Integer MyNbValues;
TColgp_Array1OfXY MyLinearForm;
TColgp_Array1OfXY MyQuadForm;
math_Vector MyGradient;
math_Vector MyHessian;


};


#include <FairCurve_Energy.lxx>



// other Inline functions and methods (like "C++: function call" methods)


#endif
