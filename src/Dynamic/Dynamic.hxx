// This file is generated by WOK (CPPExt).
// Please do not edit this file; modify original file instead.
// The copyright and license terms as defined for the original file apply to 
// this header file considered to be the "object code" form of the original source.

#ifndef _Dynamic_HeaderFile
#define _Dynamic_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_DefineAlloc_HeaderFile
#include <Standard_DefineAlloc.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

#ifndef _Dynamic_ModeEnum_HeaderFile
#include <Dynamic_ModeEnum.hxx>
#endif
#ifndef _Standard_CString_HeaderFile
#include <Standard_CString.hxx>
#endif
class Dynamic_Node;
class Dynamic_Parameter;
class Dynamic_BooleanParameter;
class Dynamic_EnumerationParameter;
class Dynamic_IntegerParameter;
class Dynamic_RealParameter;
class Dynamic_StringParameter;
class Dynamic_ObjectParameter;
class Dynamic_InstanceParameter;
class Dynamic_ParameterNode;
class Dynamic_Variable;
class Dynamic_VariableGroup;
class Dynamic_AbstractVariableInstance;
class Dynamic_VariableInstance;
class Dynamic_CompositVariableInstance;
class Dynamic_VariableNode;
class Dynamic_Method;
class Dynamic_MethodDefinition;
class Dynamic_CompiledMethod;
class Dynamic_InterpretedMethod;
class Dynamic_CompositMethod;
class Dynamic_MethodInstance;
class Dynamic_MethodDefinitionsDictionary;
class Dynamic_SeqOfMethods;
class Dynamic_SequenceOfMethods;
class Dynamic_SeqOfMethodDefinitions;
class Dynamic_SequenceOfMethodDefinitions;
class Dynamic_DynamicClass;
class Dynamic_DynamicDerivedClass;
class Dynamic_SeqOfClasses;
class Dynamic_SequenceOfClasses;
class Dynamic_DynamicInstance;
class Dynamic_FuzzyClass;
class Dynamic_FuzzyDefinition;
class Dynamic_SeqOfFuzzyDefinitions;
class Dynamic_SequenceOfFuzzyDefinitions;
class Dynamic_FuzzyDefinitionsDictionary;
class Dynamic_FuzzyInstance;
class Dynamic_SequenceNodeOfSeqOfMethods;
class Dynamic_SequenceNodeOfSeqOfMethodDefinitions;
class Dynamic_SequenceNodeOfSeqOfClasses;
class Dynamic_SequenceNodeOfSeqOfFuzzyDefinitions;


//! This package propose a  set of abstract persistent <br>
//!          classes. These classes may  be sort in  three main <br>
//!          groups, which are : <br>
//! <br>
//!          - fuzzy classes <br>
//!          - methods <br>
//!          - dynamic classes <br>
//! <br>
//!          And in    two complementary  groups   used by  the <br>
//!          previously    described family,  which   are  : <br>
//! <br>
//!          - parameter classes <br>
//!          - variable classes <br>
//! <br>
//!          All the main classes  are manipulated  through two <br>
//!          steps which are : <br>
//! <br>
//!          - the definition  which gives the signature of the <br>
//!          object <br>
//!          -  the instanciation   which  always  references a <br>
//!          definition <br>
//! <br>
//!          This    separation has  been  created  to  clearly <br>
//!          separate the definition  of an object, a method or <br>
//!          a class which  is the description and the instance <br>
//!          which is the utilisation with  a particular set of <br>
//!          values.   In  this case  for few instanciations of <br>
//!          the same object, the definition can be unique. <br>
//! <br>
//!          Each family address a particular problem. <br>
//! <br>
//!          Dynamic class <br>
//!          ------------- <br>
//! <br>
//!          This family of  classes offers  the possibility to <br>
//!          define and to  manipulate  dynamically objets with <br>
//!          the  same  specifications        as C++   objects. <br>
//!          Dynamically  means without  CDL description    and <br>
//!          without compilation  and link  if all  the methods <br>
//!          attached are interpreted methods. <br>
//! <br>
//!          The first thing to  do is to define the  signature <br>
//!          of the class, in terms of fields and methods. <br>
//! <br>
//!          You  can  also  derive a   class  from others, add <br>
//!          fields, and add or redefine methods. <br>
//! <br>
//!          Then instances of the   class can be   created and <br>
//!          values can be assigned to the fields. <br>
//! <br>
//!          It is then possible to execute methods attached to <br>
//!          the definition of the class. These methods may set <br>
//!          computed values to  other fields, or simply return <br>
//!          them. <br>
//! <br>
//!          A method can be compiled or interpreted. <br>
//! <br>
//!          Fuzzy class <br>
//!          ----------- <br>
//! <br>
//!          A fuzzy  class   is a   degeneration  of a dynamic <br>
//!          class.  Only  the   fields are  specified.   These <br>
//!          classes  are useful    to describe  objects   with <br>
//!          various definitions, and  with the number and  the <br>
//!          nature of fields depending of the definition. <br>
//! <br>
//!          The definitions of the lights for Photo  Realistic <br>
//!          Renderer is an illutration of the use of the fuzzy <br>
//!          classes. <br>
//! <br>
//!          These lights have the same definitions in terms of <br>
//!          parameters as   the lights used  in the LightWorks <br>
//!          module. <br>
//! <br>
//!          For each type  of  light   an exhaustive set    of <br>
//!          parameters is  described,  and  each  parameter is <br>
//!          defined by its  name, its type  and, if necessary, <br>
//!          its default value as follows : <br>
//! <br>
//!          ambient <br>
//!                "intensity"   Standard_Real    1.0 <br>
//!                "colour"      Materials_PColor 1.0 1.0 1.0 <br>
//! <br>
//!          distant <br>
//!                "intensity"         Standard_Real          1.0 <br>
//!                "colour"            Materials_PColor       1.0 1.0 1.0 <br>
//!                "location"          PGeom_CartesianPoint   0.0 0.0 1.0 <br>
//!                "to"                PGeom_CartesianPoint   0.0 0.0 0.0 <br>
//!                "shadows"           Standard_Boolean       Standard_False <br>
//!                "shadow resolution" Standard_Integer       256 <br>
//!                "shadow quality"    Standard_Integer       4 <br>
//!                "shadow softness"   Standard_Real          1.0 <br>
//! <br>
//!          eye <br>
//!                "intensity"         Standard_Real          1.0 <br>
//!                "colour"            Materials_PColor       1.0 1.0 1.0 <br>
//! <br>
//!          point <br>
//!                "intensity"         Standard_Real            1.0 <br>
//!                "colour"            Materials_PColor         1.0 1.0 1.0 <br>
//!                "location"          PGeom_CartesianPoint     0.0 0.0 0.0 <br>
//!                "fall off"          LightWorks_LiFallOffType LI_FALL_OFF_CONSTANT <br>
//!                "shadows"           Standard_Boolean         Standard_False <br>
//!                "shadow resolution" Standard_Integer         256 <br>
//!                "shadow quality"    Standard_Integer         4 <br>
//!                "shadow softness"   Standard_Real            1.0 <br>
//! <br>
//!          spot <br>
//!                "intensity"         Standard_Real            1.0 <br>
//!                "colour"            Materials_PColor         1.0 1.0 1.0 <br>
//!                "location"          PGeom_CartesianPoint     0.0 0.0 1.0 <br>
//!                "to"                PGeom_CartesianPoint     0.0 0.0 0.0 <br>
//!                "fall off"          LightWorks_LiFallOffType LI_FALL_OFF_CONSTANT <br>
//!                "cone angle"        Standard_Real            60.0 <br>
//!                "cone delta angle"  Standard_Real            5.0 <br>
//!                "beam distribution" Standard_Real            2.0 <br>
//!                "shadows"           Standard_Boolean         Standard_False <br>
//!                "shadow resolution" Standard_Integer         256 <br>
//!                "shadow quality"    Standard_Integer         4 <br>
//!                "shadow softness"   Standard_Real            1.0 <br>
//! <br>
//!          All  these  definitions are described  in  a  file <br>
//!          which is read  at  the first  creation  of a light <br>
//!          instance to be put in a dictionary. <br>
//! <br>
//!          At the creation  of an instance, just  a reference <br>
//!          on the definition is set. All the parameter values <br>
//!          are read in the definition. If now  a value of one <br>
//!          parameter  is changed, the  modified parameter  is <br>
//!          added   to the  instance.   So  only  the modified <br>
//!          parameters are directely attached to the instance. <br>
//!          This behaviour allows the  use of an  instance  as <br>
//!          definition,  and can be  useful to create catalogs <br>
//!          of standards which  can be directly  questioned in <br>
//!          the database. <br>
//! <br>
//!          The use  of fuzzy classes needs four prerequisites <br>
//!          which are : <br>
//! <br>
//!          - The   creation  of a  file   with the exhaustive <br>
//!          description of all  the possible types taken by an <br>
//!          object and for each    type the complete   set  of <br>
//!          parameters  in  terms  of  name,   type,   and, if <br>
//!          necessary, default value. <br>
//! <br>
//!          -    The     inheritance    from     the     class <br>
//!          FuzzyDefinitionsDictionary  and, if necessary, the <br>
//!          redefinition of the  Switch  method for the   non- <br>
//!          standard type of parameters described in the file. <br>
//! <br>
//!          - The following method : <br>
//! <br>
//!          void  DictionaryOfDefinitions(Handle(MyPackage_MyDictionary)&); <br>
//! <br>
//!          must be  writen in the file MyPackage.cxx, because <br>
//!          this method   is  automatically  called   by   the <br>
//!          constructor of FuzzyInstance. This method tests if <br>
//!          the dictionary has  been  created yet.  If  it  is <br>
//!          true  the  method returns    a reference   to  it, <br>
//!          otherwise the method creates the dictionary before <br>
//!          returning the reference. <br>
//! <br>
//!          - The instanciation   of  the FuzzyInstance  class <br>
//!          with the pre-defined dictionary. <br>
//! <br>
//!          Method class <br>
//!          ------------ <br>
//! <br>
//!          The behaviour  of  these  classes  are  similar to <br>
//!          fuzzy classes.    Only the semantic  is different. <br>
//!          These   classes   are   for memorized actions   or <br>
//!          constraints,  e.g.  they  are useful  to memorized <br>
//!          persistently   the  working  system  of    Imagine <br>
//!          Conception. <br>
class Dynamic  {
public:

  DEFINE_STANDARD_ALLOC

  
  Standard_EXPORT   static  Dynamic_ModeEnum Mode(const Standard_CString amode) ;





protected:





private:




friend class Dynamic_Node;
friend class Dynamic_Parameter;
friend class Dynamic_BooleanParameter;
friend class Dynamic_EnumerationParameter;
friend class Dynamic_IntegerParameter;
friend class Dynamic_RealParameter;
friend class Dynamic_StringParameter;
friend class Dynamic_ObjectParameter;
friend class Dynamic_InstanceParameter;
friend class Dynamic_ParameterNode;
friend class Dynamic_Variable;
friend class Dynamic_VariableGroup;
friend class Dynamic_AbstractVariableInstance;
friend class Dynamic_VariableInstance;
friend class Dynamic_CompositVariableInstance;
friend class Dynamic_VariableNode;
friend class Dynamic_Method;
friend class Dynamic_MethodDefinition;
friend class Dynamic_CompiledMethod;
friend class Dynamic_InterpretedMethod;
friend class Dynamic_CompositMethod;
friend class Dynamic_MethodInstance;
friend class Dynamic_MethodDefinitionsDictionary;
friend class Dynamic_SeqOfMethods;
friend class Dynamic_SequenceOfMethods;
friend class Dynamic_SeqOfMethodDefinitions;
friend class Dynamic_SequenceOfMethodDefinitions;
friend class Dynamic_DynamicClass;
friend class Dynamic_DynamicDerivedClass;
friend class Dynamic_SeqOfClasses;
friend class Dynamic_SequenceOfClasses;
friend class Dynamic_DynamicInstance;
friend class Dynamic_FuzzyClass;
friend class Dynamic_FuzzyDefinition;
friend class Dynamic_SeqOfFuzzyDefinitions;
friend class Dynamic_SequenceOfFuzzyDefinitions;
friend class Dynamic_FuzzyDefinitionsDictionary;
friend class Dynamic_FuzzyInstance;
friend class Dynamic_SequenceNodeOfSeqOfMethods;
friend class Dynamic_SequenceNodeOfSeqOfMethodDefinitions;
friend class Dynamic_SequenceNodeOfSeqOfClasses;
friend class Dynamic_SequenceNodeOfSeqOfFuzzyDefinitions;

};





// other Inline functions and methods (like "C++: function call" methods)


#endif
