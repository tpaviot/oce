// Created on: 1991-12-20
// Created by: Remi GILET
// Copyright (c) 1991-1999 Matra Datavision
// Copyright (c) 1999-2012 OPEN CASCADE SAS
//
// The content of this file is subject to the Open CASCADE Technology Public
// License Version 6.5 (the "License"). You may not use the content of this file
// except in compliance with the License. Please obtain a copy of the License
// at http://www.opencascade.org and read it completely before using this file.
//
// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
//
// The Original Code and all software distributed under the License is
// distributed on an "AS IS" basis, without warranty of any kind, and the
// Initial Developer hereby disclaims all such warranties, including without
// limitation, any warranties of merchantability, fitness for a particular
// purpose or non-infringement. Please see the License for the specific terms
// and conditions governing the rights and limitations under the License.


//========================================================================
//  CREATION D UNE LIGNE TANGENTE A DEUX COURBES.                        +
//========================================================================

#include <StdFail_NotDone.hxx>
#include <GccEnt_BadQualifier.hxx>
#include <gp_XY.hxx>
#include <gp_Dir2d.hxx>
#include <gp_Vec2d.hxx>
#include <gp_Circ2d.hxx>
#include <math_Vector.hxx>
#include <math_Matrix.hxx>
#include <math_FunctionSetRoot.hxx>
#include <math_FunctionRoot.hxx>

GccIter_Lin2d2Tan::
   GccIter_Lin2d2Tan (const GccEnt_QualifiedCirc& Qualified1 ,
		      const TheQualifiedCurve&    Qualified2 ,
		      const Standard_Real         Param2     ,
		      const Standard_Real         Tolang     ) {
     
   par1sol = 0.;
   pararg1 = 0.;

   //Standard_Real Tol = Abs(Tolang);

   WellDone = Standard_False;
   if (Qualified1.IsEnclosed()) { GccEnt_BadQualifier::Raise(); }
   gp_Circ2d C1 = Qualified1.Qualified();
   TheCurve Cu2 = Qualified2.Qualified();
   Standard_Real U1 = TheCurveTool::FirstParameter(Cu2);
   Standard_Real U2 = TheCurveTool::LastParameter(Cu2);
   GccIter_FuncTCirCu func(C1,Cu2);
   math_FunctionRoot sol(func,Param2,TheCurveTool::EpsX(Cu2,Abs(Tolang)),U1,U2,100);
   if (sol.IsDone()) {
     Standard_Real Usol = sol.Root();
//     gp_Pnt2d Origine,Pt;
//  Modified by Sergey KHROMOV - Thu Apr  5 17:39:47 2001 Begin
     Standard_Real Norm;
     func.Value(Usol, Norm);
     if (Abs(Norm) < Tolang) {
//  Modified by Sergey KHROMOV - Thu Apr  5 17:39:48 2001 End
     gp_Pnt2d Origine;
     gp_Vec2d Vect1;
     gp_Vec2d Vect2;
     TheCurveTool::D2(Cu2,Usol,Origine,Vect1,Vect2);
     gp_Vec2d Vdir(C1.Location().XY() - Origine.XY());
     Standard_Real sign1 = Vect1.Dot(Vdir);
     if (sign1 <= 0. ) { Vect1.Reverse(); }
     Standard_Real sign2 = Vect2.Crossed(Vect1);
     if (Qualified2.IsUnqualified() || 
	 (Qualified2.IsEnclosing() && sign2<=0.) ||
	 (Qualified2.IsOutside() && sign1 <= 0. && sign2 >= 0.) ||
	 (Qualified2.IsEnclosed() && sign1 >= 0. && sign2 >= 0.)) {
       if (Qualified1.IsUnqualified() ||
	   (Qualified1.IsOutside() && Vect1.Angle(Vdir) <= 0.) ||
	   (Qualified1.IsEnclosing() && Vect1.Angle(Vdir) >= 0.)) {
	 gp_Dir2d direc(Vect1);
	 Standard_Real R1 = C1.Radius();
	 gp_XY normal(-R1*direc.Y(),R1*direc.X());
	 sign1 = Vect1.Crossed(Vdir);
	 if (Qualified1.IsEnclosing()) {
	   pnttg1sol = gp_Pnt2d(C1.Location().XY()-normal);
	 }
	 else if (Qualified1.IsOutside()) {
	   pnttg1sol = gp_Pnt2d(C1.Location().XY()+normal);
	 }
	 else {
	   if (sign1 >= 0.) {
	     pnttg1sol = gp_Pnt2d(C1.Location().XY()-normal);
	   }
	   else {
	     pnttg1sol = gp_Pnt2d(C1.Location().XY()+normal);
	   }
	 }
// 	 if (gp_Vec2d(direc.XY()).Angle(gp_Vec2d(pnttg1sol,Origine)) <= Tol) {
	   pnttg2sol = Origine;
	   linsol = gp_Lin2d(pnttg1sol,direc);
	   WellDone = Standard_True;
	   qualifier1 = Qualified1.Qualifier();
	   qualifier2 = Qualified2.Qualifier();
	   pararg2 = Usol;
	   par1sol = 0.;
	   par2sol = pnttg2sol.Distance(pnttg1sol);
	   pararg1 = 0.;
	 }
       }
     }
   }
 }

GccIter_Lin2d2Tan::
   GccIter_Lin2d2Tan (const TheQualifiedCurve& Qualified1 ,
		      const TheQualifiedCurve& Qualified2 ,
		      const Standard_Real      Param1     ,
		      const Standard_Real      Param2     ,
		      const Standard_Real      Tolang     ) {
   par1sol = 0.;
   pararg1 = 0.;
   WellDone = Standard_False;
   if (!(Qualified1.IsEnclosed() || Qualified1.IsEnclosing() || 
	 Qualified1.IsOutside() || Qualified1.IsUnqualified()) ||
       !(Qualified2.IsEnclosed() || Qualified2.IsEnclosing() || 
	 Qualified2.IsOutside() || Qualified2.IsUnqualified())) {
     GccEnt_BadQualifier::Raise();
     return;
   }
   TheCurve Cu1 = Qualified1.Qualified();
   TheCurve Cu2 = Qualified2.Qualified();
   GccIter_FuncTCuCu Func(Cu1,Cu2);
   math_Vector Umin(1,2);
   math_Vector Umax(1,2);
   math_Vector Ufirst(1,2);
   math_Vector tol(1,2);
   Umin(1) = TheCurveTool::FirstParameter(Cu1);
   Umin(2) = TheCurveTool::FirstParameter(Cu2);
   Umax(1) = TheCurveTool::LastParameter(Cu1);
   Umax(2) = TheCurveTool::LastParameter(Cu2);
   Ufirst(1) = Param1;
   Ufirst(2) = Param2;
   tol(1) = TheCurveTool::EpsX(Cu1,Abs(Tolang));
   tol(2) = TheCurveTool::EpsX(Cu2,Abs(Tolang));
   math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
   if (Root.IsDone()) {
     Root.Root(Ufirst);
//  Modified by Sergey KHROMOV - Thu Apr  5 17:45:00 2001 Begin
     math_Vector Norm(1,2);
     Func.Value(Ufirst, Norm);
     if (Abs(Norm(1)) < Tolang && Abs(Norm(2)) < Tolang) {
//  Modified by Sergey KHROMOV - Thu Apr  5 17:45:01 2001 End
       gp_Pnt2d point1,point2;
       gp_Vec2d Vect11,Vect12,Vect21,Vect22;
       TheCurveTool::D2(Cu1,Ufirst(1),point1,Vect11,Vect12);
       TheCurveTool::D2(Cu2,Ufirst(2),point2,Vect21,Vect22);
       gp_Vec2d Vec(point1.XY(),point2.XY());
       Standard_Real Angle1 = Vec.Angle(Vect12);
       Standard_Real sign1 = Vect11.Dot(Vec);
       if (Qualified1.IsUnqualified() || 
	   (Qualified1.IsEnclosing() && Angle1 >= 0.) ||
	   (Qualified1.IsOutside() && Angle1 <= 0. && sign1 <= 0.) ||
	   (Qualified1.IsEnclosed() && Angle1 <= 0. && sign1 >= 0.)) {
	 Angle1 = Vec.Angle(Vect22);
	 sign1 = Vect21.Dot(Vec);
	 if (Qualified2.IsUnqualified() || 
	     (Qualified2.IsEnclosing() && Angle1 >= 0.) ||
	     (Qualified2.IsOutside() && Angle1 <= 0. && sign1 <= 0.) ||
	     (Qualified2.IsEnclosed() && Angle1 <= 0. && sign1 >= 0.)) {
	   qualifier1 = Qualified1.Qualifier();
	   qualifier2 = Qualified2.Qualifier();
	   pararg1 = Ufirst(1);
	   par1sol = 0.;
	   pnttg1sol = point1;
	   pararg2 = Ufirst(2);
	   pnttg2sol = point2;
	   par2sol = pnttg2sol.Distance(pnttg1sol);
	   gp_Dir2d dir(pnttg2sol.X()-pnttg1sol.X(),pnttg2sol.Y()-pnttg1sol.Y());
	   linsol = gp_Lin2d(pnttg1sol,dir);
	   WellDone = Standard_True;
	 }
       }
     }
   }
 }

GccIter_Lin2d2Tan::
   GccIter_Lin2d2Tan (const TheQualifiedCurve& Qualified1 ,
		      const gp_Pnt2d&          ThePoint   ,
		      const Standard_Real      Param1     ,
		      const Standard_Real      Tolang     ) {
     
   par1sol = 0.;
   pararg1 = 0.;
   WellDone = Standard_False;
   if (!(Qualified1.IsEnclosed() || Qualified1.IsEnclosing() || 
	 Qualified1.IsOutside() || Qualified1.IsUnqualified())) {
     GccEnt_BadQualifier::Raise();
     return;
   }
   TheCurve Cu1 = Qualified1.Qualified();
   Standard_Real U1 = TheCurveTool::FirstParameter(Cu1);
   Standard_Real U2 = TheCurveTool::LastParameter(Cu1);
   GccIter_FuncTCuPt func(Cu1,ThePoint);
   math_FunctionRoot sol(func,Param1,TheCurveTool::EpsX(Cu1,Abs(Tolang)),U1,U2,100);
   if (sol.IsDone()) {
     Standard_Real Usol = sol.Root();
//  Modified by Sergey KHROMOV - Thu Apr  5 17:45:17 2001 Begin
     Standard_Real Norm;
     func.Value(Usol, Norm);
     if (Abs(Norm) < Tolang) {
//  Modified by Sergey KHROMOV - Thu Apr  5 17:45:19 2001 End
       gp_Pnt2d Origine;
       gp_Vec2d Vect1;
       gp_Vec2d Vect2;
       TheCurveTool::D2(Cu1,Usol,Origine,Vect1,Vect2);
       gp_Vec2d Vdir(ThePoint.XY()-Origine.XY());
       Standard_Real sign1 = Vect1.Dot(Vdir);
       Standard_Real sign2 = Vect2.Crossed(Vdir);
       if (Qualified1.IsUnqualified() || 
	   (Qualified1.IsEnclosing() && 
	    ((sign1 >= 0. && sign2 <= 0.) || (sign1 <= 0. && sign2 <= 0.))) ||
	   (Qualified1.IsOutside() && sign1 <= 0. && sign2 >= 0.) ||
	   (Qualified1.IsEnclosed() && sign1 >= 0. && sign2 >= 0.)) {
	 WellDone = Standard_True;
	 linsol = gp_Lin2d(Origine,gp_Dir2d(Vdir));
	 qualifier1 = Qualified1.Qualifier();
	 qualifier2 = GccEnt_noqualifier;
	 pnttg1sol = Origine;
	 pnttg2sol = ThePoint;
	 pararg1 = Usol;
	 par1sol = 0.;
	 pararg2 = ThePoint.Distance(Origine);
	 par2sol = 0.;
       }
     }
   }
 }

Standard_Boolean GccIter_Lin2d2Tan::
   IsDone () const { return WellDone; }

gp_Lin2d GccIter_Lin2d2Tan::
   ThisSolution () const 
{
  if (!WellDone) StdFail_NotDone::Raise();
  return linsol;
}

void GccIter_Lin2d2Tan:: 
  WhichQualifier (GccEnt_Position& Qualif1  ,
		  GccEnt_Position& Qualif2  ) const
{
  if (!WellDone) { StdFail_NotDone::Raise(); }
  else {
    Qualif1 = qualifier1;
    Qualif2 = qualifier2;
  }
}

void GccIter_Lin2d2Tan::
   Tangency1 (Standard_Real& ParSol ,
              Standard_Real& ParArg ,
              gp_Pnt2d& Pnt) const {
   if (!WellDone) { StdFail_NotDone::Raise(); }
   else {
     ParSol = par1sol;
     ParArg = pararg1;
     Pnt    = pnttg1sol;
   }
 }

void GccIter_Lin2d2Tan::
   Tangency2 (Standard_Real& ParSol ,
              Standard_Real& ParArg ,
              gp_Pnt2d& Pnt) const {
   if (!WellDone) { StdFail_NotDone::Raise(); }
   else {
     ParSol = par2sol;
     ParArg = pararg2;
     Pnt    = pnttg2sol;
   }
 }

