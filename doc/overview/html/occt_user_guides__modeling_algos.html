<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Modeling Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__modeling_algos.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Modeling Algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_modalg_1">Introduction</a></li>
<li class="level1"><a href="#occt_modalg_2">Geometric Tools</a><ul><li class="level2"><a href="#occt_modalg_2_2">Intersections</a><ul><li class="level3"><a href="#occt_modalg_2_2_1">Intersection of two curves</a></li>
<li class="level3"><a href="#occt_modalg_2_2_2">Intersection of Curves and Surfaces</a></li>
<li class="level3"><a href="#occt_modalg_2_2_3">Intersection of two Surfaces</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_3">Interpolations</a><ul><li class="level3"><a href="#occt_modalg_2_3_1">Geom2dAPI_Interpolate</a></li>
<li class="level3"><a href="#occt_modalg_2_3_2">GeomAPI_Interpolate</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_4">Lines and  Circles from Constraints</a><ul><li class="level3"><a href="#occt_modalg_2_4_1">Types of constraints</a></li>
<li class="level3"><a href="#occt_modalg_2_4_2">Available types of lines and circles</a></li>
<li class="level3"><a href="#occt_modalg_2_4_3">Types of  algorithms</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_5">Curves and Surfaces from Constraints</a><ul><li class="level3"><a href="#occt_modalg_2_5_1">Faired and Minimal Variation 2D Curves</a></li>
<li class="level3"><a href="#occt_modalg_2_5_2">Ruled Surfaces</a></li>
<li class="level3"><a href="#occt_modalg_2_5_3">Pipe Surfaces</a></li>
<li class="level3"><a href="#occt_modalg_2_5_4">Filling a contour</a></li>
<li class="level3"><a href="#occt_modalg_2_5_5">Plate surfaces</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_2_6">Projections</a><ul><li class="level3"><a href="#occt_modalg_2_6_1">Projection of a 2D Point on a Curve</a></li>
<li class="level3"><a href="#occt_modalg_2_6_2">Projection of a 3D Point on a Curve</a></li>
<li class="level3"><a href="#occt_modalg_2_6_3">Projection of a Point on a Surface</a></li>
<li class="level3"><a href="#occt_modalg_2_12_8">Switching from 2d and 3d Curves</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_2_topo_tools">Topological Tools</a><ul><li class="level2"><a href="#occt_modalg_2_topo_tools_1">Creation of the faces from wireframe model</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_2">Classification of the shapes</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_3">Orientation of the shapes in the container</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_4">Making new shapes</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_5">Building PCurves</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_6">Checking the validity of the shapes</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_7">Taking a point inside the face</a></li>
<li class="level2"><a href="#occt_modalg_2_topo_tools_8">Getting normal for the face</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_3a">The Topology API</a><ul><li class="level2"><a href="#occt_modalg_3a_1">Error Handling in the Topology API</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_3">Standard  Topological Objects</a><ul><li class="level2"><a href="#occt_modalg_3_1">Vertex</a></li>
<li class="level2"><a href="#occt_modalg_3_2">Edge</a><ul><li class="level3"><a href="#occt_modalg_3_2_1">Basic edge construction method</a></li>
<li class="level3"><a href="#occt_modalg_3_2_2">Supplementary edge construction methods</a></li>
<li class="level3"><a href="#occt_modalg_3_2_3">Other information and error status</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_3_3">Edge 2D</a></li>
<li class="level2"><a href="#occt_modalg_3_4">Polygon</a></li>
<li class="level2"><a href="#occt_modalg_3_5">Face</a><ul><li class="level3"><a href="#occt_modalg_3_5_1">Basic face construction method</a></li>
<li class="level3"><a href="#occt_modalg_3_5_2">Supplementary face construction methods</a></li>
<li class="level3"><a href="#occt_modalg_3_5_3">Error status</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_3_6">Wire</a></li>
<li class="level2"><a href="#occt_modalg_3_7">Shell</a></li>
<li class="level2"><a href="#occt_modalg_3_8">Solid</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_3b">Object Modification</a><ul><li class="level2"><a href="#occt_modalg_3b_1">Transformation</a></li>
<li class="level2"><a href="#occt_modalg_3b_2">Duplication</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_4">Primitives</a><ul><li class="level2"><a href="#occt_modalg_4_1">Making  Primitives</a><ul><li class="level3"><a href="#occt_modalg_4_1_1">Box</a></li>
<li class="level3"><a href="#occt_modalg_4_1_2">Wedge</a></li>
<li class="level3"><a href="#occt_modalg_4_1_3">Rotation object</a></li>
<li class="level3"><a href="#occt_modalg_4_1_4">Cylinder</a></li>
<li class="level3"><a href="#occt_modalg_4_1_5">Cone</a></li>
<li class="level3"><a href="#occt_modalg_4_1_6">Sphere</a></li>
<li class="level3"><a href="#occt_modalg_4_1_7">Torus</a></li>
<li class="level3"><a href="#occt_modalg_4_1_8">Revolution</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_4_2">Sweeping:  Prism, Revolution and Pipe</a><ul><li class="level3"><a href="#occt_modalg_4_2_1">Sweeping</a></li>
<li class="level3"><a href="#occt_modalg_4_2_2">Prism</a></li>
<li class="level3"><a href="#occt_modalg_4_2_3">Rotational Sweep</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_5">Boolean  Operations</a><ul><li class="level2"><a href="#occt_modalg_5_1">Input and Result Arguments</a></li>
<li class="level2"><a href="#occt_modalg_5_2">Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_6">Fillets and  Chamfers</a><ul><li class="level2"><a href="#occt_modalg_6_1">Fillets</a></li>
<li class="level2"><a href="#occt_modalg_6_1_1">Fillet on shape</a></li>
<li class="level2"><a href="#occt_modalg_6_1_2">Chamfer</a></li>
<li class="level2"><a href="#occt_modalg_6_1_3">Fillet on a planar face</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_7">Offsets, Drafts, Pipes and Evolved shapes</a><ul><li class="level2"><a href="#occt_modalg_7_1">Offset computation</a></li>
<li class="level2"><a href="#occt_modalg_7_2">Shelling</a></li>
<li class="level2"><a href="#occt_modalg_7_3">Draft Angle</a></li>
<li class="level2"><a href="#occt_modalg_7_4">Pipe  Constructor</a></li>
<li class="level2"><a href="#occt_modalg_7_5">Evolved Solid</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_8">Sewing</a><ul><li class="level2"><a href="#occt_modalg_8_1">Introduction</a></li>
<li class="level2"><a href="#occt_modalg_8_2">Sewing Algorithm</a></li>
<li class="level2"><a href="#occt_modalg_8_3">Tolerance Management</a></li>
<li class="level2"><a href="#occt_modalg_8_4">Manifold and Non-manifold Sewing</a></li>
<li class="level2"><a href="#occt_modalg_8_5">Local Sewing</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_9">Features</a><ul><li class="level2"><a href="#occt_modalg_9_1">Form Features</a><ul><li class="level3"><a href="#occt_modalg_9_1_1">Prism</a></li>
<li class="level3"><a href="#occt_modalg_9_1_2">Draft Prism</a></li>
<li class="level3"><a href="#occt_modalg_9_1_3">Revolution</a></li>
<li class="level3"><a href="#occt_modalg_9_1_4">Pipe</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_9_2">Mechanical Features</a><ul><li class="level3"><a href="#occt_modalg_9_2_1">Linear Form</a></li>
<li class="level3"><a href="#occt_modalg_9_2_3">Gluer</a></li>
<li class="level3"><a href="#occt_modalg_9_2_4">Split Shape</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_10">Hidden Line  Removal</a><ul><li class="level2"><a href="#occt_modalg_10_1">Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_modalg_11">Meshing</a><ul><li class="level2"><a href="#occt_modalg_11_1">Mesh presentations</a></li>
<li class="level2"><a href="#occt_modalg_11_2">Meshing algorithm</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_modalg_1"></a>
Introduction</h1>
<p>This manual explains how to use the Modeling Algorithms. It provides basic documentation on modeling algorithms. For advanced information on Modeling Algorithms, see our <a href="http://www.opencascade.com/content/tutorial-learning">E-learning &amp; Training</a> offerings.</p>
<p>The Modeling Algorithms module brings together a wide range of topological algorithms used in modeling. Along with these tools, you will find the geometric algorithms, which they call.</p>
<h1><a class="anchor" id="occt_modalg_2"></a>
Geometric Tools</h1>
<p>Open CASCADE Technology geometric tools provide algorithms to:</p><ul>
<li>Calculate the intersection of two 2D curves, surfaces, or a 3D curve and a surface;</li>
<li>Project points onto 2D and 3D curves, points onto surfaces, and 3D curves onto surfaces;</li>
<li>Construct lines and circles from constraints;</li>
<li>Construct curves and surfaces from constraints;</li>
<li>Construct curves and surfaces by interpolation.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_2"></a>
Intersections</h2>
<p>The Intersections component is used to compute intersections between 2D or 3D geometrical objects:</p><ul>
<li>the intersections between two 2D curves;</li>
<li>the self-intersections of a 2D curve;</li>
<li>the intersection between a 3D curve and a surface;</li>
<li>the intersection between two surfaces.</li>
</ul>
<p>The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___inter_curve_curve.html">Geom2dAPI_InterCurveCurve</a></em> class allows the evaluation of the intersection points (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a></em>) between two geometric curves (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>) and the evaluation of the points of self-intersection of a curve.</p>
<div class="image">
<img src="modeling_algos_image003.png" alt="modeling_algos_image003.png"/>
<div class="caption">
Intersection and self-intersection of curves</div></div>
<p>In both cases, the algorithm requires a value for the tolerance (Standard_Real) for the confusion between two points. The default tolerance value used in all constructors is <em>1.0e-6.</em></p>
<div class="image">
<img src="modeling_algos_image004.png" alt="modeling_algos_image004.png"/>
<div class="caption">
Intersection and tangent intersection</div></div>
<p>The algorithm returns a point in the case of an intersection and a segment in the case of tangent intersection.</p>
<h3><a class="anchor" id="occt_modalg_2_2_1"></a>
Intersection of two curves</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___inter_curve_curve.html">Geom2dAPI_InterCurveCurve</a></em> class may be instantiated for intersection of curves <em>C1</em> and <em>C2</em>. </p><div class="fragment"><div class="line">Geom2dAPI_InterCurveCurve Intersector(C1,C2,tolerance); </div></div><!-- fragment --><p>or for self-intersection of curve <em>C3</em>. </p><div class="fragment"><div class="line">Geom2dAPI_InterCurveCurve Intersector(C3,tolerance); </div></div><!-- fragment --><div class="fragment"><div class="line">Standard_Integer N = Intersector.NbPoints(); </div></div><!-- fragment --><p> Calls the number of intersection points</p>
<p>To select the desired intersection point, pass an integer index value in argument. </p><div class="fragment"><div class="line">gp_Pnt2d P = Intersector.Point(Index); </div></div><!-- fragment --><p>To call the number of intersection segments, use </p><div class="fragment"><div class="line">Standard_Integer M = Intersector.NbSegments(); </div></div><!-- fragment --><p>To select the desired intersection segment pass integer index values in argument. </p><div class="fragment"><div class="line">Handle(Geom2d_Curve) Seg1, Seg2; </div><div class="line">Intersector.Segment(Index,Seg1,Seg2); </div><div class="line">// if intersection of 2 curves </div><div class="line">Intersector.Segment(Index,Seg1); </div><div class="line">// if self-intersection of a curve </div></div><!-- fragment --><p>If you need access to a wider range of functionalities the following method will return the algorithmic object for the calculation of intersections:</p>
<div class="fragment"><div class="line">Geom2dInt_GInter&amp; TheIntersector = Intersector.Intersector(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_2_2"></a>
Intersection of Curves and Surfaces</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___int_c_s.html">GeomAPI_IntCS</a></em> class is used to compute the intersection points between a curve and a surface.</p>
<p>This class is instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_IntCS Intersector(C, S); </div></div><!-- fragment --><p>To call the number of intersection points, use: </p><div class="fragment"><div class="line">Standard_Integer nb = Intersector.NbPoints(); </div></div><!-- fragment --><div class="fragment"><div class="line">gp_Pnt&amp; P = Intersector.Point(Index); </div></div><!-- fragment --><p>Where <em>Index</em> is an integer between 1 and <em>nb</em>, calls the intersection points.</p>
<h3><a class="anchor" id="occt_modalg_2_2_3"></a>
Intersection of two Surfaces</h3>
<p>The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___int_s_s.html">GeomAPI_IntSS</a></em> class is used to compute the intersection of two surfaces from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em> with respect to a given tolerance.</p>
<p>This class is instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_IntSS Intersector(S1, S2, Tolerance); </div></div><!-- fragment --><p> Once the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___int_s_s.html">GeomAPI_IntSS</a></em> object has been created, it can be interpreted.</p>
<div class="fragment"><div class="line">Standard_Integer nb = Intersector. NbLines(); </div></div><!-- fragment --><p> Calls the number of intersection curves.</p>
<div class="fragment"><div class="line">Handle(Geom_Curve) C = Intersector.Line(Index) </div></div><!-- fragment --><p> Where <em>Index</em> is an integer between 1 and <em>nb</em>, calls the intersection curves.</p>
<h2><a class="anchor" id="occt_modalg_2_3"></a>
Interpolations</h2>
<p>The Interpolation Laws component provides definitions of functions: <em> y=f(x) </em>.</p>
<p>In particular, it provides definitions of:</p><ul>
<li>a linear function,</li>
<li>an <em> S </em> function, and</li>
<li>an interpolation function for a range of values.</li>
</ul>
<p>Such functions can be used to define, for example, the evolution law of a fillet along the edge of a shape.</p>
<p>The validity of the function built is never checked: the <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_law.html">Law</a> package does not know for what application or to what end the function will be used. In particular, if the function is used as the evolution law of a fillet, it is important that the function is always positive. The user must check this.</p>
<h3><a class="anchor" id="occt_modalg_2_3_1"></a>
Geom2dAPI_Interpolate</h3>
<p>This class is used to interpolate a BSplineCurve passing through an array of points. If tangency is not requested at the point of interpolation, continuity will be <em>C2</em>. If tangency is requested at the point, continuity will be <em>C1</em>. If Periodicity is requested, the curve will be closed and the junction will be the first point given. The curve will then have a continuity of <em>C1</em> only. This class may be instantiated as follows: </p><div class="fragment"><div class="line">Geom2dAPI_Interpolate </div><div class="line">(const  Handle_TColgp_HArray1OfPnt2d&amp; Points, </div><div class="line">const  Standard_Boolean PeriodicFlag, </div><div class="line">const Standard_Real  Tolerance); </div><div class="line"></div><div class="line">Geom2dAPI_Interpolate Interp(Points, Standard_False, </div><div class="line">                                    Precision::Confusion()); </div></div><!-- fragment --><p>It is possible to call the BSpline curve from the object defined above it. </p><div class="fragment"><div class="line">Handle(Geom2d_BSplineCurve) C = Interp.Curve(); </div></div><!-- fragment --><p>Note that the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(Geom2d_BSplineCurve)</a></em> operator has been redefined by the method <em>Curve()</em>. Consequently, it is unnecessary to pass via the construction of an intermediate object of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___interpolate.html">Geom2dAPI_Interpolate</a></em> type and the following syntax is correct.</p>
<div class="fragment"><div class="line">Handle(Geom2d_BSplineCurve) C = </div><div class="line">Geom2dAPI_Interpolate(Points, </div><div class="line">    Standard_False, </div><div class="line">    Precision::Confusion()); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_3_2"></a>
GeomAPI_Interpolate</h3>
<p>This class may be instantiated as follows: </p><div class="fragment"><div class="line">GeomAPI_Interpolate </div><div class="line">(const  Handle_TColgp_HArray1OfPnt&amp; Points, </div><div class="line">const  Standard_Boolean PeriodicFlag, </div><div class="line">const Standard_Real  Tolerance); </div><div class="line"></div><div class="line">GeomAPI_Interpolate Interp(Points, Standard_False, </div><div class="line">                                    Precision::Confusion()); </div></div><!-- fragment --><p>It is possible to call the BSpline curve from the object defined above it. </p><div class="fragment"><div class="line">Handle(Geom_BSplineCurve) C = Interp.Curve(); </div></div><!-- fragment --><p> Note that the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(Geom_BSplineCurve)</a></em> operator has been redefined by the method <em>Curve()</em>. Thus, it is unnecessary to pass via the construction of an intermediate object of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___interpolate.html">GeomAPI_Interpolate</a></em> type and the following syntax is correct.</p>
<p><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle(Geom_BSplineCurve)</a> C = <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___interpolate.html">GeomAPI_Interpolate</a>(Points, Standard_False, 1.0e-7);</p>
<p>Boundary conditions may be imposed with the method Load. </p><div class="fragment"><div class="line">GeomAPI_Interpolate AnInterpolator </div><div class="line">(Points, Standard_False, 1.0e-5); </div><div class="line">AnInterpolator.Load (StartingTangent, EndingTangent); </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_2_4"></a>
Lines and  Circles from Constraints</h2>
<h3><a class="anchor" id="occt_modalg_2_4_1"></a>
Types of constraints</h3>
<p>The algorithms for construction of 2D circles or lines can be described with numeric or geometric constraints in relation to other curves.</p>
<p>These constraints can impose the following :</p><ul>
<li>the radius of a circle,</li>
<li>the angle that a straight line makes with another straight line,</li>
<li>the tangency of a straight line or circle in relation to a curve,</li>
<li>the passage of a straight line or circle through a point,</li>
<li>the circle with center in a point or curve.</li>
</ul>
<p>For example, these algorithms enable to easily construct a circle of a given radius, centered on a straight line and tangential to another circle.</p>
<p>The implemented algorithms are more complex than those provided by the Direct Constructions component for building 2D circles or lines.</p>
<p>The expression of a tangency problem generally leads to several results, according to the relative positions of the solution and the circles or straight lines in relation to which the tangency constraints are expressed. For example, consider the following case of a circle of a given radius (a small one) which is tangential to two secant circles C1 and C2:</p>
<div class="image">
<img src="modeling_algos_image058.png" alt="modeling_algos_image058.png"/>
<div class="caption">
Example of a Tangency Constraint</div></div>
<p>This diagram clearly shows that there are 8 possible solutions.</p>
<p>In order to limit the number of solutions, we can try to express the relative position of the required solution in relation to the circles to which it is tangential. For example, if we specify that the solution is inside the circle C1 and outside the circle C2, only two solutions referenced 3 and 4 on the diagram respond to the problem posed.</p>
<p>These definitions are very easy to interpret on a circle, where it is easy to identify the interior and exterior sides. In fact, for any kind of curve the interior is defined as the left-hand side of the curve in relation to its orientation.</p>
<p>This technique of qualification of a solution, in relation to the curves to which it is tangential, can be used in all algorithms for constructing a circle or a straight line by geometric constraints. Four qualifiers are used:</p><ul>
<li><b>Enclosing</b> &ndash; the solution(s) must enclose the argument;</li>
<li><b>Enclosed</b> &ndash; the solution(s) must be enclosed by the argument;</li>
<li><b>Outside</b> &ndash; the solution(s) and the argument must be external to one another;</li>
<li><b>Unqualified</b> &ndash; the relative position is not qualified, i.e. all solutions apply.</li>
</ul>
<p>It is possible to create expressions using the qualifiers, for example: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosing(C2),  Rad, Tolerance); </div></div><!-- fragment --><p>This expression finds all circles of radius <em>Rad</em>, which are tangent to both circle <em>C1</em> and <em>C2</em>, while <em>C1</em> is outside and <em>C2</em> is inside.</p>
<h3><a class="anchor" id="occt_modalg_2_4_2"></a>
Available types of lines and circles</h3>
<p>The following analytic algorithms using value-handled entities for creation of 2D lines or circles with geometric constraints are available:</p><ul>
<li>circle tangent to three elements (lines, circles, curves, points),</li>
<li>circle tangent to two elements and having a radius,</li>
<li>circle tangent to two elements and centered on a third element,</li>
<li>circle tangent to two elements and centered on a point,</li>
<li>circle tangent to one element and centered on a second,</li>
<li>bisector of two points,</li>
<li>bisector of two lines,</li>
<li>bisector of two circles,</li>
<li>bisector of a line and a point,</li>
<li>bisector of a circle and a point,</li>
<li>bisector of a line and a circle,</li>
<li>line tangent to two elements (points, circles, curves),</li>
<li>line tangent to one element and parallel to a line,</li>
<li>line tangent to one element and perpendicular to a line,</li>
<li>line tangent to one element and forming angle with a line.</li>
</ul>
<h4>Exterior/Interior</h4>
<p>It is not hard to define the interior and exterior of a circle. As is shown in the following diagram, the exterior is indicated by the sense of the binormal, that is to say the right side according to the sense of traversing the circle. The left side is therefore the interior (or &quot;material&quot;).</p>
<div class="image">
<img src="modeling_algos_image006.png" alt="modeling_algos_image006.png"/>
<div class="caption">
Exterior/Interior of a Circle</div></div>
<p>By extension, the interior of a line or any open curve is defined as the left side according to the passing direction, as shown in the following diagram:</p>
<div class="image">
<img src="modeling_algos_image007.png" alt="modeling_algos_image007.png"/>
<div class="caption">
Exterior/Interior of a Line and a Curve</div></div>
<h4>Orientation of a Line</h4>
<p>It is sometimes necessary to define in advance the sense of travel along a line to be created. This sense will be from first to second argument.</p>
<p>The following figure shows a line, which is first tangent to circle C1 which is interior to the line, and then passes through point P1.</p>
<div class="image">
<img src="modeling_algos_image008.png" alt="modeling_algos_image008.png"/>
<div class="caption">
An Oriented Line</div></div>
<h4>Line tangent to two circles</h4>
<p>The following four diagrams illustrate four cases of using qualifiers in the creation of a line. The fifth shows the solution if no qualifiers are given.</p>
<p><b>Example 1 Case 1</b></p>
<div class="image">
<img src="modeling_algos_image009.png" alt="modeling_algos_image009.png"/>
<div class="caption">
Both circles outside</div></div>
<p>Constraints: Tangent and Exterior to C1. Tangent and Exterior to C2.</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Outside(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 2</b></p>
<div class="image">
<img src="modeling_algos_image010.png" alt="modeling_algos_image010.png"/>
<div class="caption">
Both circles enclosed</div></div>
<p>Constraints: Tangent and Including C1. Tangent and Including C2.</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Enclosing(C1), </div><div class="line">        GccEnt::Enclosing(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 3</b></p>
<div class="image">
<img src="modeling_algos_image011.png" alt="modeling_algos_image011.png"/>
<div class="caption">
C1 enclosed and C2 outside</div></div>
<p>Constraints: Tangent and Including C1. Tangent and Exterior to C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Enclosing(C1), </div><div class="line">        GccEnt::Outside(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 4</b></p>
<div class="image">
<img src="modeling_algos_image012.png" alt="modeling_algos_image012.png"/>
<div class="caption">
C1 outside and C2 enclosed</div></div>
<p> Constraints: Tangent and Exterior to C1. Tangent and Including C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosing(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><p><b>Example 1 Case 5</b></p>
<div class="image">
<img src="modeling_algos_image013.png" alt="modeling_algos_image013.png"/>
<div class="caption">
Without qualifiers</div></div>
<p>Constraints: Tangent and Undefined with respect to C1. Tangent and Undefined with respect to C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Lin2d2Tan </div><div class="line">    Solver(GccEnt::Unqualified(C1), </div><div class="line">        GccEnt::Unqualified(C2), </div><div class="line">        Tolerance); </div></div><!-- fragment --><h4>Circle of given radius tangent to two circles</h4>
<p>The following four diagrams show the four cases in using qualifiers in the creation of a circle.</p>
<p><b>Example 2 Case 1</b> </p><div class="image">
<img src="modeling_algos_image014.png" alt="modeling_algos_image014.png"/>
<div class="caption">
Both solutions outside</div></div>
<p>Constraints: Tangent and Exterior to C1. Tangent and Exterior to C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">    GccEnt::Outside(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 2</b></p>
<div class="image">
<img src="modeling_algos_image015.png" alt="modeling_algos_image015.png"/>
<div class="caption">
C2 encompasses C1</div></div>
<p>Constraints: Tangent and Exterior to C1. Tangent and Included by C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosed(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 3</b> </p><div class="image">
<img src="modeling_algos_image016.png" alt="modeling_algos_image016.png"/>
<div class="caption">
Solutions enclose C2</div></div>
<p>Constraints: Tangent and Exterior to C1. Tangent and Including C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Outside(C1), </div><div class="line">        GccEnt::Enclosing(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 4</b> </p><div class="image">
<img src="modeling_algos_image017.png" alt="modeling_algos_image017.png"/>
<div class="caption">
Solutions enclose C1</div></div>
<p>Constraints: Tangent and Enclosing C1. Tangent and Enclosing C2.</p>
<p>Syntax: </p><div class="fragment"><div class="line">GccAna_Circ2d2TanRad </div><div class="line">    Solver(GccEnt::Enclosing(C1), </div><div class="line">        GccEnt::Enclosing(C2),  Rad, Tolerance); </div></div><!-- fragment --><p><b>Example 2 Case 5</b></p>
<p>The following syntax will give all the circles of radius <em>Rad</em>, which are tangent to <em>C1</em> and <em>C2</em> without discrimination of relative position:</p>
<div class="fragment"><div class="line">GccAna_Circ2d2TanRad  Solver(GccEnt::Unqualified(C1), </div><div class="line">                            GccEnt::Unqualified(C2), </div><div class="line">                            Rad,Tolerance); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_4_3"></a>
Types of  algorithms</h3>
<p>OCCT implements several categories of algorithms:</p>
<ul>
<li><b>Analytic</b> algorithms, where solutions are obtained by the resolution of an equation, such algorithms are used when the geometries which are worked on (tangency arguments, position of the center, etc.) are points, lines or circles;</li>
<li><b>Geometric</b> algorithms, where the solution is generally obtained by calculating the intersection of parallel or bisecting curves built from geometric arguments;</li>
<li><b>Iterative</b> algorithms, where the solution is obtained by a process of iteration.</li>
</ul>
<p>For each kind of geometric construction of a constrained line or circle, OCCT provides two types of access:</p>
<ul>
<li>algorithms from the package <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a> </em> automatically select the algorithm best suited to the problem, both in the general case and in all types of specific cases; the used arguments are <em>Geom2d</em> objects, while the computed solutions are <em> gp </em> objects;</li>
<li>algorithms from the package <em> GccAna</em> resolve the problem analytically, and can only be used when the geometries to be worked on are lines or circles; both the used arguments and the computed solutions are <em> gp </em> objects.</li>
</ul>
<p>The provided algorithms compute all solutions, which correspond to the stated geometric problem, unless the solution is found by an iterative algorithm.</p>
<p>Iterative algorithms compute only one solution, closest to an initial position. They can be used in the following cases:</p><ul>
<li>to build a circle, when an argument is more complex than a line or a circle, and where the radius is not known or difficult to determine: this is the case for a circle tangential to three geometric elements, or tangential to two geometric elements and centered on a curve;</li>
<li>to build a line, when a tangency argument is more complex than a line or a circle.</li>
</ul>
<p>Qualified curves (for tangency arguments) are provided either by:</p><ul>
<li>the <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_gcc_ent.html">GccEnt</a></em> package, for direct use by <em> GccAna</em> algorithms, or</li>
<li>the <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a> </em> package, for general use by <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a> </em> algorithms.</li>
</ul>
<p>The <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_gcc_ent.html">GccEnt</a></em> and <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a></em> packages also provide simple functions for building qualified curves in a very efficient way.</p>
<p>The <em> GccAna </em>package also provides algorithms for constructing bisecting loci between circles, lines or points. Bisecting loci between two geometric objects are such that each of their points is at the same distance from the two geometric objects. They are typically curves, such as circles, lines or conics for <em> GccAna</em> algorithms. Each elementary solution is given as an elementary bisecting locus object (line, circle, ellipse, hyperbola, parabola), described by the <em>GccInt</em> package.</p>
<p>Note: Curves used by <em>GccAna</em> algorithms to define the geometric problem to be solved, are 2D lines or circles from the <em> gp</em> package: they are not explicitly parameterized. However, these lines or circles retain an implicit parameterization, corresponding to that which they induce on equivalent Geom2d objects. This induced parameterization is the one used when returning parameter values on such curves, for instance with the functions <em> Tangency1, Tangency2, Tangency3, Intersection2</em> and <em> CenterOn3</em> provided by construction algorithms from the <em> GccAna </em> or <em> <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_gcc.html">Geom2dGcc</a></em> packages.</p>
<h2><a class="anchor" id="occt_modalg_2_5"></a>
Curves and Surfaces from Constraints</h2>
<p>The Curves and Surfaces from Constraints component groups together high level functions used in 2D and 3D geometry for:</p><ul>
<li>creation of faired and minimal variation 2D curves</li>
<li>construction of ruled surfaces</li>
<li>construction of pipe surfaces</li>
<li>filling of surfaces</li>
<li>construction of plate surfaces</li>
<li>extension of a 3D curve or surface beyond its original bounds.</li>
</ul>
<p>OPEN CASCADE company also provides a product known as <a href="http://www.opencascade.com/content/surfaces-scattered-points">Surfaces from Scattered Points</a>, which allows constructing surfaces from scattered points. This algorithm accepts or constructs an initial B-Spline surface and looks for its deformation (finite elements method) which would satisfy the constraints. Using optimized computation methods, this algorithm is able to construct a surface from more than 500 000 points.</p>
<p>SSP product is not supplied with Open CASCADE Technology, but can be purchased separately.</p>
<h3><a class="anchor" id="occt_modalg_2_5_1"></a>
Faired and Minimal Variation 2D Curves</h3>
<p>Elastic beam curves have their origin in traditional methods of modeling applied in boat-building, where a long thin piece of wood, a lathe, was forced to pass between two sets of nails and in this way, take the form of a curve based on the two points, the directions of the forces applied at those points, and the properties of the wooden lathe itself.</p>
<p>Maintaining these constraints requires both longitudinal and transversal forces to be applied to the beam in order to compensate for its internal elasticity. The longitudinal forces can be a push or a pull and the beam may or may not be allowed to slide over these fixed points.</p>
<h4>Batten Curves</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_fair_curve___batten.html">FairCurve_Batten</a></em> allows producing faired curves defined on the basis of one or more constraints on each of the two reference points. These include point, angle of tangency and curvature settings. The following constraint orders are available:</p>
<ul>
<li>0 the curve must pass through a point</li>
<li>1 the curve must pass through a point and have a given tangent</li>
<li>2 the curve must pass through a point, have a given tangent and a given curvature.</li>
</ul>
<p>Only 0 and 1 constraint orders are used. The function Curve returns the result as a 2D BSpline curve.</p>
<h4>Minimal Variation Curves</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_fair_curve___minimal_variation.html">FairCurve_MinimalVariation</a></em> allows producing curves with minimal variation in curvature at each reference point. The following constraint orders are available:</p>
<ul>
<li>0 the curve must pass through a point</li>
<li>1 the curve must pass through a point and have a given tangent</li>
<li>2 the curve must pass through a point, have a given tangent and a given curvature.</li>
</ul>
<p>Constraint orders of 0, 1 and 2 can be used. The algorithm minimizes tension, sagging and jerk energy.</p>
<p>The function <em>Curve</em> returns the result as a 2D BSpline curve.</p>
<p>If you want to give a specific length to a batten curve, use:</p>
<div class="fragment"><div class="line">b.SetSlidingFactor(L / b.SlidingOfReference()) </div></div><!-- fragment --><p> where <em>b</em> is the name of the batten curve object</p>
<p>Free sliding is generally more aesthetically pleasing than constrained sliding. However, the computation can fail with values such as angles greater than <em>p/2</em> because in this case the length is theoretically infinite.</p>
<p>In other cases, when sliding is imposed and the sliding factor is too large, the batten can collapse.</p>
<p>The constructor parameters, <em>Tolerance</em> and <em>NbIterations</em>, control how precise the computation is, and how long it will take.</p>
<h3><a class="anchor" id="occt_modalg_2_5_2"></a>
Ruled Surfaces</h3>
<p>A ruled surface is built by ruling a line along the length of two curves.</p>
<h4>Creation of Bezier surfaces</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___bezier_curves.html">GeomFill_BezierCurves</a></em> allows producing a Bezier surface from contiguous Bezier curves. Note that problems may occur with rational Bezier Curves.</p>
<h4>Creation of BSpline surfaces</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___b_spline_curves.html">GeomFill_BSplineCurves</a></em> allows producing a BSpline surface from contiguous BSpline curves. Note that problems may occur with rational BSplines.</p>
<h3><a class="anchor" id="occt_modalg_2_5_3"></a>
Pipe Surfaces</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___pipe.html">GeomFill_Pipe</a></em> allows producing a pipe by sweeping a curve (the section) along another curve (the path). The result is a BSpline surface.</p>
<p>The following types of construction are available:</p><ul>
<li>pipes with a circular section of constant radius,</li>
<li>pipes with a constant section,</li>
<li>pipes with a section evolving between two given curves.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_2_5_4"></a>
Filling a contour</h3>
<p>It is often convenient to create a surface from some curves, which will form the boundaries that define the new surface. This is done by the class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___constrained_filling.html">GeomFill_ConstrainedFilling</a></em>, which allows filling a contour defined by three or four curves as well as by tangency constraints. The resulting surface is a BSpline.</p>
<p>A case in point is the intersection of two fillets at a corner. If the radius of the fillet on one edge is different from that of the fillet on another, it becomes impossible to sew together all the edges of the resulting surfaces. This leaves a gap in the overall surface of the object which you are constructing.</p>
<div class="image">
<img src="modeling_algos_image059.png" alt="modeling_algos_image059.png"/>
<div class="caption">
Intersecting filleted edges with differing radiuses</div></div>
<p>These algorithms allow you to fill this gap from two, three or four curves. This can be done with or without constraints, and the resulting surface will be either a Bezier or a BSpline surface in one of a range of filling styles.</p>
<h4>Creation of a Boundary</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___simple_bound.html">GeomFill_SimpleBound</a></em> allows you defining a boundary for the surface to be constructed.</p>
<h4>Creation of a Boundary with an adjoining surface</h4>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_fill___bound_with_surf.html">GeomFill_BoundWithSurf</a></em> allows defining a boundary for the surface to be constructed. This boundary will already be joined to another surface.</p>
<h4>Filling styles</h4>
<p>The enumerations <em>FillingStyle</em> specify the styles used to build the surface. These include:</p>
<ul>
<li><em>Stretch</em> &ndash; the style with the flattest patches</li>
<li><em>Coons</em> &ndash; a rounded style with less depth than <em>Curved</em></li>
<li><em>Curved</em> &ndash; the style with the most rounded patches.</li>
</ul>
<div class="image">
<img src="modeling_algos_image018.png" alt="modeling_algos_image018.png"/>
<div class="caption">
Intersecting filleted edges with different radii leave a gap filled by a surface</div></div>
<h3><a class="anchor" id="occt_modalg_2_5_5"></a>
Plate surfaces</h3>
<p>In CAD, it is often necessary to generate a surface which has no exact mathematical definition, but which is defined by respective constraints. These can be of a mathematical, a technical or an aesthetic order.</p>
<p>Essentially, a plate surface is constructed by deforming a surface so that it conforms to a given number of curve or point constraints. In the figure below, you can see four segments of the outline of the plane, and a point which have been used as the curve constraints and the point constraint respectively. The resulting surface can be converted into a BSpline surface by using the function <em> MakeApprox </em>.</p>
<p>The surface is built using a variational spline algorithm. It uses the principle of deformation of a thin plate by localised mechanical forces. If not already given in the input, an initial surface is calculated. This corresponds to the plate prior to deformation. Then, the algorithm is called to calculate the final surface. It looks for a solution satisfying constraints and minimizing energy input.</p>
<div class="image">
<img src="modeling_algos_image061.png" alt="modeling_algos_image061.png"/>
<div class="caption">
Surface generated from two curves and a point</div></div>
<p>The package <em>GeomPlate</em> provides the following services for creating surfaces respecting curve and point constraints:</p>
<h4>Definition of a Framework</h4>
<p>The class <em>BuildPlateSurface</em> allows creating a framework to build surfaces according to curve and point constraints as well as tolerance settings. The result is returned with the function <em>Surface</em>.</p>
<p>Note that you do not have to specify an initial surface at the time of construction. It can be added later or, if none is loaded, a surface will be computed automatically.</p>
<h4>Definition of a Curve Constraint</h4>
<p>The class <em>CurveConstraint</em> allows defining curves as constraints to the surface, which you want to build.</p>
<h4>Definition of a Point Constraint</h4>
<p>The class <em>PointConstraint</em> allows defining points as constraints to the surface, which you want to build.</p>
<h4>Applying <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a> to Plate Surfaces</h4>
<p>The class <em>Surface</em> allows describing the characteristics of plate surface objects returned by <b>BuildPlateSurface::Surface</b> using the methods of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em></p>
<h4>Approximating a Plate surface to a BSpline</h4>
<p>The class <em>MakeApprox</em> allows converting a <em>GeomPlate</em> surface into a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___b_spline_surface.html">Geom_BSplineSurface</a></em>.</p>
<div class="image">
<img src="modeling_algos_image060.png" alt="modeling_algos_image060.png"/>
<div class="caption">
Surface generated from four curves and a point</div></div>
<p>Let us create a Plate surface and approximate it from a polyline as a curve constraint and a point constraint</p>
<div class="fragment"><div class="line">Standard_Integer NbCurFront=4, </div><div class="line">NbPointConstraint=1; </div><div class="line">gp_Pnt P1(0.,0.,0.); </div><div class="line">gp_Pnt P2(0.,10.,0.); </div><div class="line">gp_Pnt P3(0.,10.,10.); </div><div class="line">gp_Pnt P4(0.,0.,10.); </div><div class="line">gp_Pnt P5(5.,5.,5.); </div><div class="line">BRepBuilderAPI_MakePolygon W; </div><div class="line">W.Add(P1); </div><div class="line">W.Add(P2); </div><div class="line">W.Add(P3); </div><div class="line">W.Add(P4); </div><div class="line">W.Add(P1); </div><div class="line">// Initialize a BuildPlateSurface </div><div class="line">GeomPlate_BuildPlateSurface BPSurf(3,15,2); </div><div class="line">// Create the curve constraints </div><div class="line">BRepTools_WireExplorer anExp; </div><div class="line">for(anExp.Init(W); anExp.More(); anExp.Next()) </div><div class="line">{ </div><div class="line">TopoDS_Edge E = anExp.Current(); </div><div class="line">Handle(BRepAdaptor_HCurve) C = new </div><div class="line">BRepAdaptor_HCurve(); </div><div class="line">C-ChangeCurve().Initialize(E); </div><div class="line">Handle(BRepFill_CurveConstraint) Cont= new </div><div class="line">BRepFill_CurveConstraint(C,0); </div><div class="line">BPSurf.Add(Cont); </div><div class="line">} </div><div class="line">// Point constraint </div><div class="line">Handle(GeomPlate_PointConstraint) PCont= new </div><div class="line">GeomPlate_PointConstraint(P5,0); </div><div class="line">BPSurf.Add(PCont); </div><div class="line">// Compute the Plate surface </div><div class="line">BPSurf.Perform(); </div><div class="line">// Approximation of the Plate surface </div><div class="line">Standard_Integer MaxSeg=9; </div><div class="line">Standard_Integer MaxDegree=8; </div><div class="line">Standard_Integer CritOrder=0; </div><div class="line">Standard_Real dmax,Tol; </div><div class="line">Handle(GeomPlate_Surface) PSurf = BPSurf.Surface(); </div><div class="line">dmax = Max(0.0001,10*BPSurf.G0Error()); </div><div class="line">Tol=0.0001; </div><div class="line">GeomPlate_MakeApprox </div><div class="line">Mapp(PSurf,Tol,MaxSeg,MaxDegree,dmax,CritOrder); </div><div class="line">Handle (Geom_Surface) Surf (Mapp.Surface()); </div><div class="line">// create a face corresponding to the approximated Plate </div><div class="line">Surface </div><div class="line">Standard_Real Umin, Umax, Vmin, Vmax; </div><div class="line">PSurf-&gt;Bounds( Umin, Umax, Vmin, Vmax); </div><div class="line">BRepBuilderAPI_MakeFace MF(Surf,Umin, Umax, Vmin, Vmax); </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_2_6"></a>
Projections</h2>
<p>Projections provide for computing the following:</p><ul>
<li>the projections of a 2D point onto a 2D curve</li>
<li>the projections of a 3D point onto a 3D curve or surface</li>
<li>the projection of a 3D curve onto a surface.</li>
<li>the planar curve transposition from the 3D to the 2D parametric space of an underlying plane and v. s.</li>
<li>the positioning of a 2D gp object in the 3D geometric space.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_2_6_1"></a>
Projection of a 2D Point on a Curve</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> allows calculation of all normals projected from a point (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d</a></em>) onto a geometric curve (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>). The calculation may be restricted to a given domain.</p>
<div class="image">
<img src="modeling_algos_image020.png" alt="modeling_algos_image020.png"/>
<div class="caption">
Normals from a point to a curve</div></div>
<p>The curve does not have to be a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___trimmed_curve.html">Geom2d_TrimmedCurve</a></em>. The algorithm will function with any class inheriting <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em>.</p>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> may be instantiated as in the following example:</p>
<div class="fragment"><div class="line">gp_Pnt2d P; </div><div class="line">Handle(Geom2d_BezierCurve) C = </div><div class="line">    new  Geom2d_BezierCurve(args); </div><div class="line">Geom2dAPI_ProjectPointOnCurve Projector (P, C); </div></div><!-- fragment --><p>To restrict the search for normals to a given domain <em>[U1,U2]</em>, use the following constructor: </p><div class="fragment"><div class="line">Geom2dAPI_ProjectPointOnCurve Projector (P, C, U1, U2); </div></div><!-- fragment --><p> Having thus created the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> object, we can now interrogate it.</p>
<h4>Calling the number of solution points</h4>
<div class="fragment"><div class="line">Standard_Integer NumSolutions = Projector.NbPoints(); </div></div><!-- fragment --><h4>Calling the location of a solution point</h4>
<p>The solutions are indexed in a range from <em>1</em> to <em>Projector.NbPoints()</em>. The point, which corresponds to a given <em>Index</em> may be found: </p><div class="fragment"><div class="line">gp_Pnt2d Pn = Projector.Point(Index); </div></div><!-- fragment --><h4>Calling the parameter of a solution point</h4>
<p>For a given point corresponding to a given <em>Index</em>:</p>
<div class="fragment"><div class="line">Standard_Real U = Projector.Parameter(Index); </div></div><!-- fragment --><p>This can also be programmed as:</p>
<div class="fragment"><div class="line">Standard_Real U; </div><div class="line">Projector.Parameter(Index,U); </div></div><!-- fragment --><h4>Calling the distance between the start and end points</h4>
<p>We can find the distance between the initial point and a point, which corresponds to the given <em>Index</em>:</p>
<div class="fragment"><div class="line">Standard_Real D = Projector.Distance(Index); </div></div><!-- fragment --><h4>Calling the nearest solution point</h4>
<p>This class offers a method to return the closest solution point to the starting point. This solution is accessed as follows: </p><div class="fragment"><div class="line">gp_Pnt2d P1 = Projector.NearestPoint(); </div></div><!-- fragment --><h4>Calling the parameter of the nearest solution point</h4>
<div class="fragment"><div class="line">Standard_Real U = Projector.LowerDistanceParameter(); </div></div><!-- fragment --><h4>Calling the minimum distance from the point to the curve</h4>
<div class="fragment"><div class="line">Standard_Real D = Projector.LowerDistance(); </div></div><!-- fragment --><h4>Redefined operators</h4>
<p>Some operators have been redefined to find the closest solution.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real()</a></em> returns the minimum distance from the point to the curve.</p>
<div class="fragment"><div class="line">Standard_Real D = Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer()</a></em> returns the number of solutions.</p>
<div class="fragment"><div class="line">Standard_Integer N = </div><div class="line">Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d()</a></em> returns the nearest solution point.</p>
<div class="fragment"><div class="line">gp_Pnt2d P1 = Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p>Using these operators makes coding easier when you only need the nearest point. Thus: </p><div class="fragment"><div class="line">Geom2dAPI_ProjectPointOnCurve Projector (P, C); </div><div class="line">gp_Pnt2d P1 = Projector.NearestPoint(); </div></div><!-- fragment --><p> can be written more concisely as: </p><div class="fragment"><div class="line">gp_Pnt2d P1 = Geom2dAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p> However, note that in this second case no intermediate <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d_a_p_i___project_point_on_curve.html">Geom2dAPI_ProjectPointOnCurve</a></em> object is created, and thus it is impossible to have access to other solution points.</p>
<h4>Access to lower-level functionalities</h4>
<p>If you want to use the wider range of functionalities available from the <em>Extrema</em> package, a call to the <em>Extrema()</em> method will return the algorithmic object for calculating extrema. For example:</p>
<div class="fragment"><div class="line">Extrema_ExtPC2d&amp; TheExtrema = Projector.Extrema(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_6_2"></a>
Projection of a 3D Point on a Curve</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> is instantiated as in the following example:</p>
<div class="fragment"><div class="line">gp_Pnt P; </div><div class="line">Handle(Geom_BezierCurve) C = </div><div class="line">    new  Geom_BezierCurve(args); </div><div class="line">GeomAPI_ProjectPointOnCurve Projector (P, C); </div></div><!-- fragment --><p>If you wish to restrict the search for normals to the given domain [U1,U2], use the following constructor:</p>
<div class="fragment"><div class="line">GeomAPI_ProjectPointOnCurve Projector (P, C, U1, U2); </div></div><!-- fragment --><p> Having thus created the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> object, you can now interrogate it.</p>
<h4>Calling the number of solution points</h4>
<div class="fragment"><div class="line">Standard_Integer NumSolutions = Projector.NbPoints(); </div></div><!-- fragment --><h4>Calling the location of a solution point</h4>
<p>The solutions are indexed in a range from 1 to <em>Projector.NbPoints()</em>. The point, which corresponds to a given index, may be found: </p><div class="fragment"><div class="line">gp_Pnt Pn = Projector.Point(Index); </div></div><!-- fragment --><h4>Calling the parameter of a solution point</h4>
<p>For a given point corresponding to a given index:</p>
<div class="fragment"><div class="line">Standard_Real U = Projector.Parameter(Index); </div></div><!-- fragment --><p>This can also be programmed as: </p><div class="fragment"><div class="line">Standard_Real U; </div><div class="line">Projector.Parameter(Index,U); </div></div><!-- fragment --><h4>Calling the distance between the start and end point</h4>
<p>The distance between the initial point and a point, which corresponds to a given index, may be found: </p><div class="fragment"><div class="line">Standard_Real D = Projector.Distance(Index); </div></div><!-- fragment --><h4>Calling the nearest solution point</h4>
<p>This class offers a method to return the closest solution point to the starting point. This solution is accessed as follows: </p><div class="fragment"><div class="line">gp_Pnt P1 = Projector.NearestPoint(); </div></div><!-- fragment --><h4>Calling the parameter of the nearest solution point</h4>
<div class="fragment"><div class="line">Standard_Real U = Projector.LowerDistanceParameter(); </div></div><!-- fragment --><h4>Calling the minimum distance from the point to the curve</h4>
<div class="fragment"><div class="line">Standard_Real D =  Projector.LowerDistance(); </div></div><!-- fragment --><h4>Redefined operators</h4>
<p>Some operators have been redefined to find the nearest solution.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real()</a></em> returns the minimum distance from the point to the curve.</p>
<div class="fragment"><div class="line">Standard_Real D = GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer()</a></em> returns the number of solutions. </p><div class="fragment"><div class="line">Standard_Integer N =  GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d()</a></em> returns the nearest solution point.</p>
<div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p> Using these operators makes coding easier when you only need the nearest point. In this way,</p>
<div class="fragment"><div class="line">GeomAPI_ProjectPointOnCurve Projector (P, C); </div><div class="line">gp_Pnt P1 = Projector.NearestPoint(); </div></div><!-- fragment --><p>can be written more concisely as: </p><div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnCurve (P,C); </div></div><!-- fragment --><p> In the second case, however, no intermediate <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_curve.html">GeomAPI_ProjectPointOnCurve</a></em> object is created, and it is impossible to access other solutions points.</p>
<h4>Access to lower-level functionalities</h4>
<p>If you want to use the wider range of functionalities available from the <em>Extrema</em> package, a call to the <em>Extrema()</em> method will return the algorithmic object for calculating the extrema. For example:</p>
<div class="fragment"><div class="line">Extrema_ExtPC&amp; TheExtrema = Projector.Extrema(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_6_3"></a>
Projection of a Point on a Surface</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> allows calculation of all normals projected from a point from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt.html">gp_Pnt</a></em> onto a geometric surface from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em>.</p>
<div class="image">
<img src="modeling_algos_image021.png" alt="modeling_algos_image021.png"/>
<div class="caption">
Projection of normals from a point to a surface</div></div>
<p>Note that the surface does not have to be of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___rectangular_trimmed_surface.html">Geom_RectangularTrimmedSurface</a></em> type. The algorithm will function with any class inheriting <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface.html">Geom_Surface</a></em>.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> is instantiated as in the following example: </p><div class="fragment"><div class="line">gp_Pnt P; </div><div class="line">Handle (Geom_Surface) S = new Geom_BezierSurface(args); </div><div class="line">GeomAPI_ProjectPointOnSurf Proj (P, S); </div></div><!-- fragment --><p>To restrict the search for normals within the given rectangular domain [U1, U2, V1, V2], use the constructor <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a> Proj (P, S, U1, U2, V1, V2)</em></p>
<p>The values of <em>U1, U2, V1</em> and <em>V2</em> lie at or within their maximum and minimum limits, i.e.: </p><div class="fragment"><div class="line">Umin &lt;=  U1 &lt; U2 &lt;= Umax </div><div class="line">Vmin &lt;=  V1 &lt; V2 &lt;= Vmax </div></div><!-- fragment --><p> Having thus created the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> object, you can interrogate it.</p>
<h4>Calling the number of solution points</h4>
<div class="fragment"><div class="line">Standard_Integer NumSolutions = Proj.NbPoints(); </div></div><!-- fragment --><h4>Calling the location of a solution point</h4>
<p>The solutions are indexed in a range from 1 to <em>Proj.NbPoints()</em>. The point corresponding to the given index may be found:</p>
<div class="fragment"><div class="line">gp_Pnt Pn = Proj.Point(Index); </div></div><!-- fragment --><h4>Calling the parameters of a solution point</h4>
<p>For a given point corresponding to the given index:</p>
<div class="fragment"><div class="line">Standard_Real U,V; </div><div class="line">Proj.Parameters(Index, U, V); </div></div><!-- fragment --><h4>Calling the distance between the start and end point</h4>
<p>The distance between the initial point and a point corresponding to the given index may be found: </p><div class="fragment"><div class="line">Standard_Real D = Projector.Distance(Index); </div></div><!-- fragment --><h4>Calling the nearest solution point</h4>
<p>This class offers a method, which returns the closest solution point to the starting point. This solution is accessed as follows: </p><div class="fragment"><div class="line">gp_Pnt P1 = Proj.NearestPoint(); </div></div><!-- fragment --><h4>Calling the parameters of the nearest solution point</h4>
<div class="fragment"><div class="line">Standard_Real U,V; </div><div class="line">Proj.LowerDistanceParameters (U, V); </div></div><!-- fragment --><h4>Calling the minimum distance from a point to the surface</h4>
<div class="fragment"><div class="line">Standard_Real D = Proj.LowerDistance(); </div></div><!-- fragment --><h4>Redefined operators</h4>
<p>Some operators have been redefined to help you find the nearest solution.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real()</a></em> returns the minimum distance from the point to the surface.</p>
<div class="fragment"><div class="line">Standard_Real D = GeomAPI_ProjectPointOnSurf (P,S); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer()</a></em> returns the number of solutions.</p>
<div class="fragment"><div class="line">Standard_Integer N = GeomAPI_ProjectPointOnSurf (P,S); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pnt2d.html">gp_Pnt2d()</a></em> returns the nearest solution point.</p>
<div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnSurf (P,S); </div></div><!-- fragment --><p>Using these operators makes coding easier when you only need the nearest point. In this way,</p>
<div class="fragment"><div class="line">GeomAPI_ProjectPointOnSurface Proj (P, S); </div><div class="line">gp_Pnt P1 = Proj.NearestPoint(); </div></div><!-- fragment --><p>can be written more concisely as:</p>
<div class="fragment"><div class="line">gp_Pnt P1 = GeomAPI_ProjectPointOnSurface (P,S); </div></div><!-- fragment --><p>In the second case, however, no intermediate <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom_a_p_i___project_point_on_surf.html">GeomAPI_ProjectPointOnSurf</a></em> object is created, and it is impossible to access other solution points.</p>
<h4>Access to lower-level functionalities</h4>
<p>If you want to use the wider range of functionalities available from the <em>Extrema</em> package, a call to the <em>Extrema()</em> method will return the algorithmic object for calculating the extrema as follows:</p>
<div class="fragment"><div class="line">Extrema_ExtPS&amp; TheExtrema = Proj.Extrema(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_2_12_8"></a>
Switching from 2d and 3d Curves</h3>
<p>The <em>To2d</em> and <em>To3d</em> methods are used to;</p>
<ul>
<li>build a 2d curve from a 3d <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___curve.html">Geom_Curve</a></em> lying on a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pln.html">gp_Pln</a></em> plane</li>
<li>build a 3d curve from a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom2d___curve.html">Geom2d_Curve</a></em> and a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pln.html">gp_Pln</a></em> plane.</li>
</ul>
<p>These methods are called as follows: </p><div class="fragment"><div class="line">Handle(Geom2d_Curve) C2d = GeomAPI::To2d(C3d, Pln); </div><div class="line">Handle(Geom_Curve) C3d = GeomAPI::To3d(C2d, Pln); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_2_topo_tools"></a>
Topological Tools</h1>
<p>Open CASCADE Technology topological tools provide algorithms to</p><ul>
<li>Create wires from edges;</li>
<li>Create faces from wires;</li>
<li>Compute state of the shape relatively other shape;</li>
<li>Orient shapes in container;</li>
<li>Create new shapes from the existing ones;</li>
<li>Build PCurves of edges on the faces;</li>
<li>Check the validity of the shapes;</li>
<li>Take the point in the face;</li>
<li>Get the normal direction for the face.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_1"></a>
Creation of the faces from wireframe model</h2>
<p>It is possible to create the planar faces from the arbitrary set of planar edges randomly located in 3D space. This feature might be useful if you need for instance to restore the shape from the wireframe model: </p><table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_image062.png" alt="modeling_algos_image062.png"/>
<div class="caption">
Wireframe model</div></div>
 </td><td><div class="image">
<img src="modeling_algos_image063.png" alt="modeling_algos_image063.png"/>
<div class="caption">
Faces of the model</div></div>
  </td></tr>
</table>
<p>To make the faces from edges it is, firstly, necessary to create planar wires from the given edges and than create planar faces from each wire. The static methods <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#abf38b2c9278bd3b67033c9f05f60159b">BOPAlgo_Tools::EdgesToWires</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#adaaf99ff3f36d82283eea8fec64b7752">BOPAlgo_Tools::WiresToFaces</a></em> can be used for that: </p><div class="fragment"><div class="line">TopoDS_Shape anEdges = ...; /* The input edges */</div><div class="line">Standard_Real anAngTol = 1.e-8; /* The angular tolerance for distinguishing the planes in which the wires are located */</div><div class="line">Standard_Boolean bShared = Standard_False; /* Defines whether the edges are shared or not */</div><div class="line">//</div><div class="line">TopoDS_Shape aWires; /* resulting wires */</div><div class="line">Standard_Integer iErr = BOPAlgo_Tools::EdgesToWires(anEdges, aWires, bShared, anAngTol);</div><div class="line">if (iErr) {</div><div class="line">  cout &lt;&lt; &quot;Error: Unable to build wires from given edges\n&quot;;</div><div class="line">  return;</div><div class="line">}</div><div class="line">//</div><div class="line">TopoDS_Shape aFaces; /* resulting faces */</div><div class="line">Standard_Boolean bDone = BOPAlgo_Tools::WiresToFaces(aWires, aFaces, anAngTol);</div><div class="line">if (!bDone) {</div><div class="line">  cout &lt;&lt; &quot;Error: Unable to build faces from wires\n&quot;;</div><div class="line">  return;</div><div class="line">}</div></div><!-- fragment --><p>These methods can also be used separately:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#abf38b2c9278bd3b67033c9f05f60159b">BOPAlgo_Tools::EdgesToWires</a></em> allows creating planar wires from edges. The input edges may be not shared, but the output wires will be sharing the coinciding vertices and edges. For this the intersection of the edges is performed. Although, it is possible to skip the intersection stage (if the input edges are already shared) by passing the corresponding flag into the method. The input edges are expected to be planar, but the method does not check it. Thus, if the input edges are not planar, the output wires will also be not planar. In general, the output wires are non-manifold and may contain free vertices, as well as multi-connected vertices.</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#adaaf99ff3f36d82283eea8fec64b7752">BOPAlgo_Tools::WiresToFaces</a></em> allows creating planar faces from the planar wires. In general, the input wires are non-manifold and may be not closed, but should share the coinciding parts. The wires located in the same plane and completely included into other wires will create holes in the faces built from outer wires:</li>
</ul>
<table align="center">
<tr>
<td><div class="image">
<img src="modeling_algos_image064.png" alt="modeling_algos_image064.png"/>
<div class="caption">
Wireframe model</div></div>
 </td><td><div class="image">
<img src="modeling_algos_image065.png" alt="modeling_algos_image065.png"/>
<div class="caption">
Two faces (red face has a hole)</div></div>
  </td></tr>
</table>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_2"></a>
Classification of the shapes</h2>
<p>The following methods allow classifying the different shapes relatively other shapes:</p><ul>
<li>The variety of the <em>BOPTools_AlgoTools::ComputState</em> methods classify the vertex/edge/face relatively solid;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#aa0d0a2f34f08e75a8ce94b08636501c9">BOPTools_AlgoTools::IsHole</a></em> classifies wire relatively face;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___tools.html#ae41089ceb30b82099e21b12403efccc2">IntTools_Tools::ClassifyPointByFace</a></em> classifies point relatively face.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_3"></a>
Orientation of the shapes in the container</h2>
<p>The following methods allow reorienting shapes in the containers:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#af6fd9353fc803c7486e33424ba38d6f8">BOPTools_AlgoTools::OrientEdgesOnWire</a></em> correctly orients edges on the wire;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a6bbbb83dfd2bf2e281c5b18ebe3b06a5">BOPTools_AlgoTools::OrientFacesOnShell</a></em> correctly orients faces on the shell.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_4"></a>
Making new shapes</h2>
<p>The following methods allow creating new shapes from the existing ones:</p><ul>
<li>The variety of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#abef4c3e4bd5f2e294aef08f684617531">BOPTools_AlgoTools::MakeNewVertex</a></em> creates the new vertices from other vertices and edges;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a842021c09e30e6791d0b667be9c563ed">BOPTools_AlgoTools::MakeSplitEdge</a></em> splits the edge by the given parameters.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_5"></a>
Building PCurves</h2>
<p>The following methods allow building PCurves of edges on faces:</p><ul>
<li><em>BOPTools_AlgoTools::BuildPCurveForEdgeOnFace</em> computes PCurve for the edge on the face;</li>
<li><em>BOPTools_AlgoTools::BuildPCurveForEdgeOnPlane</em> and <em>BOPTools_AlgoTools::BuildPCurveForEdgesOnPlane</em> allow building PCurves for edges on the planar face;</li>
<li><em>BOPTools_AlgoTools::AttachExistingPCurve</em> takes PCurve on the face from one edge and attach this PCurve to other edge coinciding with the first one.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_6"></a>
Checking the validity of the shapes</h2>
<p>The following methods allow checking the validity of the shapes:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#af88d910ad2d5b0008d998e0008187ca6">BOPTools_AlgoTools::IsMicroEdge</a></em> detects the small edges;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#aa95381613041f0d866db022034d6d5b5">BOPTools_AlgoTools::ComputeTolerance</a></em> computes the correct tolerance of the edge on the face;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#a687f8fc914c717a03a7761550a404f8f">BOPTools_AlgoTools::CorrectShapeTolerances</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools.html#ad4272aa730e90f72b3e799fc3d97710c">BOPTools_AlgoTools::CorrectTolerances</a></em> allow correcting the tolerances of the sub-shapes.</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_lib.html#a8f2ad719749a367a78ebca99a1236850">BRepLib::FindValidRange</a></em> finds a range of 3d curve of the edge not covered by tolerance spheres of vertices.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_7"></a>
Taking a point inside the face</h2>
<p>The following methods allow taking a point located inside the face:</p><ul>
<li>The variety of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#a689018b21e0aef378041087555329bbe">BOPTools_AlgoTools3D::PointNearEdge</a></em> allows getting a point inside the face located near the edge;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#ab765c207bfc971090facfb7b4be8c1b8">BOPTools_AlgoTools3D::PointInFace</a></em> allows getting a point inside the face.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_2_topo_tools_8"></a>
Getting normal for the face</h2>
<p>The following methods allow getting the normal direction for the face/surface:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#a53a590daa1fd7d7b7f5cd91577c8d069">BOPTools_AlgoTools3D::GetNormalToSurface</a></em> computes the normal direction for the surface in the given point defined by UV parameters;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#ae2bbf90afb21348df738a5d799f1fe40">BOPTools_AlgoTools3D::GetNormalToFaceOnEdge</a></em> computes the normal direction for the face in the point located on the edge of the face;</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_tools___algo_tools3_d.html#ad8af0927c4062b3e0301097d9c6ab57f">BOPTools_AlgoTools3D::GetApproxNormalToFaceOnEdge</a></em> computes the normal direction for the face in the point located near the edge of the face.</li>
</ul>
<h1><a class="anchor" id="occt_modalg_3a"></a>
The Topology API</h1>
<p>The Topology API of Open CASCADE Technology (<b>OCCT</b>) includes the following six packages:</p><ul>
<li><em>BRepAlgoAPI</em></li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em></li>
<li><em>BRepFilletAPI</em></li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em></li>
<li><em>BRepOffsetAPI</em></li>
<li><em>BRepPrimAPI</em></li>
</ul>
<p>The classes provided by the API have the following features:</p><ul>
<li>The constructors of classes provide different construction methods;</li>
<li>The class retains different tools used to build objects as fields;</li>
<li>The class provides a casting method to obtain the result automatically with a function-like call.</li>
</ul>
<p>Let us use the class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> to create a linear edge from two points.</p>
<div class="fragment"><div class="line">gp_Pnt P1(10,0,0), P2(20,0,0); </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(P1,P2);</div></div><!-- fragment --><p>This is the simplest way to create edge E from two points P1, P2, but the developer can test for errors when he is not as confident of the data as in the previous example.</p>
<div class="fragment"><div class="line">#include &lt;gp_Pnt.hxx&gt; </div><div class="line">#include &lt;TopoDS_Edge.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeEdge.hxx&gt; </div><div class="line">void EdgeTest() </div><div class="line">{ </div><div class="line">gp_Pnt P1; </div><div class="line">gp_Pnt P2; </div><div class="line">BRepBuilderAPI_MakeEdge ME(P1,P2); </div><div class="line">if (!ME.IsDone()) </div><div class="line">{ </div><div class="line">// doing ME.Edge() or E = ME here </div><div class="line">// would raise StdFail_NotDone </div><div class="line">Standard_DomainError::Raise </div><div class="line">(ProcessPoints::Failed to createan edge); </div><div class="line">} </div><div class="line">TopoDS_Edge E = ME; </div><div class="line">} </div></div><!-- fragment --><p>In this example an intermediary object ME has been introduced. This can be tested for the completion of the function before accessing the result. More information on <b>error handling</b> in the topology programming interface can be found in the next section.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> provides valuable information. For example, when creating an edge from two points, two vertices have to be created from the points. Sometimes you may be interested in getting these vertices quickly without exploring the new edge. Such information can be provided when using a class. The following example shows a function creating an edge and two vertices from two points.</p>
<div class="fragment"><div class="line">void MakeEdgeAndVertices(const gp_Pnt&amp; P1, </div><div class="line">const gp_Pnt&amp; P2, </div><div class="line">TopoDS_Edge&amp; E, </div><div class="line">TopoDS_Vertex&amp; V1, </div><div class="line">TopoDS_Vertex&amp; V2) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakeEdge ME(P1,P2); </div><div class="line">if (!ME.IsDone()) { </div><div class="line">Standard_DomainError::Raise </div><div class="line">(MakeEdgeAndVerices::Failed  to create an edge); </div><div class="line">} </div><div class="line">E = ME; </div><div class="line">V1 = ME.Vextex1(); </div><div class="line">V2 = ME.Vertex2(); </div></div><!-- fragment --><p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> provides two methods <em>Vertex1</em> and <em>Vertex2</em>, which return two vertices used to create the edge.</p>
<p>How can <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> be both a function and a class? It can do this because it uses the casting capabilities of C++. The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> class has a method called Edge; in the previous example the line <em>E = ME</em> could have been written.</p>
<div class="fragment"><div class="line">E = ME.Edge(); </div></div><!-- fragment --><p>This instruction tells the C++ compiler that there is an <b>implicit casting</b> of a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> into a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> using the <em>Edge</em> method. It means this method is automatically called when a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> is found where a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> is required.</p>
<p>This feature allows you to provide classes, which have the simplicity of function calls when required and the power of classes when advanced processing is necessary. All the benefits of this approach are explained when describing the topology programming interface classes.</p>
<h2><a class="anchor" id="occt_modalg_3a_1"></a>
Error Handling in the Topology API</h2>
<p>A method can report an error in the two following situations:</p><ul>
<li>The data or arguments of the method are incorrect, i.e. they do not respect the restrictions specified by the methods in its specifications. Typical example: creating a linear edge from two identical points is likely to lead to a zero divide when computing the direction of the line.</li>
<li>Something unexpected happened. This situation covers every error not included in the first category. Including: interruption, programming errors in the method or in another method called by the first method, bad specifications of the arguments (i.e. a set of arguments that was not expected to fail).</li>
</ul>
<p>The second situation is supposed to become increasingly exceptional as a system is debugged and it is handled by the <b>exception mechanism</b>. Using exceptions avoids handling error statuses in the call to a method: a very cumbersome style of programming.</p>
<p>In the first situation, an exception is also supposed to be raised because the calling method should have verified the arguments and if it did not do so, there is a bug. For example, if before calling <em>MakeEdge</em> you are not sure that the two points are non-identical, this situation must be tested.</p>
<p>Making those validity checks on the arguments can be tedious to program and frustrating as you have probably correctly surmised that the method will perform the test twice. It does not trust you. As the test involves a great deal of computation, performing it twice is also time-consuming.</p>
<p>Consequently, you might be tempted to adopt the highly inadvisable style of programming illustrated in the following example:</p>
<div class="fragment"><div class="line">#include &lt;Standard_ErrorHandler.hxx&gt; </div><div class="line">try { </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(P1,P2); </div><div class="line">// go on with the edge </div><div class="line">} </div><div class="line">catch { </div><div class="line">// process the error. </div><div class="line">} </div></div><!-- fragment --><p>To help the user, the Topology API classes only raise the exception <em>StdFail_NotDone</em>. Any other exception means that something happened which was unforeseen in the design of this API.</p>
<p>The <em>NotDone</em> exception is only raised when the user tries to access the result of the computation and the original data is corrupted. At the construction of the class instance, if the algorithm cannot be completed, the internal flag <em>NotDone</em> is set. This flag can be tested and in some situations a more complete description of the error can be queried. If the user ignores the <em>NotDone</em> status and tries to access the result, an exception is raised.</p>
<div class="fragment"><div class="line">BRepBuilderAPI_MakeEdge ME(P1,P2); </div><div class="line">if (!ME.IsDone()) { </div><div class="line">// doing ME.Edge() or E = ME here </div><div class="line">// would raise StdFail_NotDone </div><div class="line">Standard_DomainError::Raise </div><div class="line">(ProcessPoints::Failed to create an edge); </div><div class="line">} </div><div class="line">TopoDS_Edge E = ME; </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_3"></a>
Standard  Topological Objects</h1>
<p>The following standard topological objects can be created:</p><ul>
<li>Vertices</li>
<li>Edges</li>
<li>Faces</li>
<li>Wires</li>
<li>Polygonal wires</li>
<li>Shells</li>
<li>Solids.</li>
</ul>
<p>There are two root classes for their construction and modification:</p><ul>
<li>The deferred class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html">BRepBuilderAPI_MakeShape</a></em> is the root of all <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> classes, which build shapes. It inherits from the class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___command.html">BRepBuilderAPI_Command</a></em> and provides a field to store the constructed shape.</li>
<li>The deferred class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___modify_shape.html">BRepBuilderAPI_ModifyShape</a></em> is used as a root for the shape modifications. It inherits <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html">BRepBuilderAPI_MakeShape</a></em> and implements the methods used to trace the history of all sub-shapes.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_3_1"></a>
Vertex</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_vertex.html">BRepBuilderAPI_MakeVertex</a></em> creates a new vertex from a 3D point from gp. </p><div class="fragment"><div class="line">gp_Pnt P(0,0,10); </div><div class="line">TopoDS_Vertex V = BRepBuilderAPI_MakeVertex(P); </div></div><!-- fragment --><p>This class always creates a new vertex and has no other methods.</p>
<h2><a class="anchor" id="occt_modalg_3_2"></a>
Edge</h2>
<h3><a class="anchor" id="occt_modalg_3_2_1"></a>
Basic edge construction method</h3>
<p>Use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> to create from a curve and vertices. The basic method constructs an edge from a curve, two vertices, and two parameters.</p>
<div class="fragment"><div class="line">Handle(Geom_Curve) C = ...; // a curve </div><div class="line">TopoDS_Vertex V1 = ...,V2 = ...;// two Vertices </div><div class="line">Standard_Real p1 = ..., p2 = ..;// two parameters </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(C,V1,V2,p1,p2); </div></div><!-- fragment --><p>where C is the domain of the edge; V1 is the first vertex oriented FORWARD; V2 is the second vertex oriented REVERSED; p1 and p2 are the parameters for the vertices V1 and V2 on the curve. The default tolerance is associated with this edge.</p>
<div class="image">
<img src="modeling_algos_image022.png" alt="modeling_algos_image022.png"/>
<div class="caption">
Basic Edge Construction</div></div>
<p>The following rules apply to the arguments:</p>
<p><b>The curve</b></p><ul>
<li>Must not be a Null Handle.</li>
<li>If the curve is a trimmed curve, the basis curve is used.</li>
</ul>
<p><b>The vertices</b></p><ul>
<li>Can be null shapes. When V1 or V2 is Null the edge is open in the corresponding direction and the corresponding parameter p1 or p2 must be infinite (i.e p1 is <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___real_8hxx.html#ad3de9dafc2ae3ca21ca628732ae6e209">RealFirst()</a>, p2 is <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/_standard___real_8hxx.html#a95979d57361a0a66ceaec655be8757da">RealLast()</a>).</li>
<li>Must be different vertices if they have different 3d locations and identical vertices if they have the same 3d location (identical vertices are used when the curve is closed).</li>
</ul>
<p><b>The parameters</b></p><ul>
<li>Must be increasing and in the range of the curve, i.e.:</li>
</ul>
<div class="fragment"><div class="line">C-&gt;FirstParameter() &lt;=  p1 &lt; p2 &lt;= C-&gt;LastParameter() </div></div><!-- fragment --><ul>
<li>If the parameters are decreasing, the Vertices are switched, i.e. V2 becomes V1 and V1 becomes V2.</li>
<li>On a periodic curve the parameters p1 and p2 are adjusted by adding or subtracting the period to obtain p1 in the range of the curve and p2 in the range p1 &lt; p2 &lt;= p1+ Period. So on a parametric curve p2 can be greater than the second parameter, see the figure below.</li>
<li>Can be infinite but the corresponding vertex must be Null (see above).</li>
<li>The distance between the Vertex 3d location and the point evaluated on the curve with the parameter must be lower than the default precision.</li>
</ul>
<p>The figure below illustrates two special cases, a semi-infinite edge and an edge on a periodic curve.</p>
<div class="image">
<img src="modeling_algos_image023.png" alt="modeling_algos_image023.png"/>
<div class="caption">
Infinite and Periodic Edges</div></div>
<h3><a class="anchor" id="occt_modalg_3_2_2"></a>
Supplementary edge construction methods</h3>
<p>There exist supplementary edge construction methods derived from the basic one.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> class provides methods, which are all simplified calls of the previous one:</p>
<ul>
<li>The parameters can be omitted. They are computed by projecting the vertices on the curve.</li>
<li>3d points (Pnt from gp) can be given in place of vertices. Vertices are created from the points. Giving vertices is useful when creating connected vertices.</li>
<li>The vertices or points can be omitted if the parameters are given. The points are computed by evaluating the parameters on the curve.</li>
<li>The vertices or points and the parameters can be omitted. The first and the last parameters of the curve are used.</li>
</ul>
<p>The five following methods are thus derived from the basic construction:</p>
<div class="fragment"><div class="line">Handle(Geom_Curve) C = ...; // a curve </div><div class="line">TopoDS_Vertex V1 = ...,V2 = ...;// two Vertices </div><div class="line">Standard_Real p1 = ..., p2 = ..;// two parameters </div><div class="line">gp_Pnt P1 = ..., P2 = ...;// two points </div><div class="line">TopoDS_Edge E; </div><div class="line">// project the vertices on the curve </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,V1,V2); </div><div class="line">// Make vertices from points </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,P1,P2,p1,p2); </div><div class="line">// Make vertices from points and project them </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,P1,P2); </div><div class="line">// Computes the points from the parameters </div><div class="line">E = BRepBuilderAPI_MakeEdge(C,p1,p2); </div><div class="line">// Make an edge from the whole curve </div><div class="line">E = BRepBuilderAPI_MakeEdge(C); </div></div><!-- fragment --><p>Six methods (the five above and the basic method) are also provided for curves from the gp package in place of Curve from Geom. The methods create the corresponding Curve from Geom and are implemented for the following classes:</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___lin.html">gp_Lin</a></em> creates a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___line.html">Geom_Line</a></em> <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___circ.html">gp_Circ</a></em> creates a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___circle.html">Geom_Circle</a></em> <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___elips.html">gp_Elips</a></em> creates a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___ellipse.html">Geom_Ellipse</a></em> <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___hypr.html">gp_Hypr</a></em> creates a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___hyperbola.html">Geom_Hyperbola</a></em> <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___parab.html">gp_Parab</a></em> creates a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___parabola.html">Geom_Parabola</a></em></p>
<p>There are also two methods to construct edges from two vertices or two points. These methods assume that the curve is a line; the vertices or points must have different locations.</p>
<div class="fragment"><div class="line">TopoDS_Vertex V1 = ...,V2 = ...;// two Vertices </div><div class="line">gp_Pnt P1 = ..., P2 = ...;// two points </div><div class="line">TopoDS_Edge E; </div><div class="line"></div><div class="line">// linear edge from two vertices </div><div class="line">E = BRepBuilderAPI_MakeEdge(V1,V2); </div><div class="line"></div><div class="line">// linear edge from two points </div><div class="line">E = BRepBuilderAPI_MakeEdge(P1,P2); </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_3_2_3"></a>
Other information and error status</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> can provide extra information and return an error status.</p>
<p>If <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em> is used as a class, it can provide two vertices. This is useful when the vertices were not provided as arguments, for example when the edge was constructed from a curve and parameters. The two methods <em>Vertex1</em> and <em>Vertex2</em> return the vertices. Note that the returned vertices can be null if the edge is open in the corresponding direction.</p>
<p>The <em>Error</em> method returns a term of the <em>BRepBuilderAPI_EdgeError</em> enumeration. It can be used to analyze the error when <em>IsDone</em> method returns False. The terms are:</p>
<ul>
<li><b>EdgeDone</b> &ndash; No error occurred, <em>IsDone</em> returns True.</li>
<li><b>PointProjectionFailed</b> &ndash; No parameters were given, but the projection of the 3D points on the curve failed. This happens if the point distance to the curve is greater than the precision.</li>
<li><b>ParameterOutOfRange</b> &ndash; The given parameters are not in the range <em>C-&gt;FirstParameter()</em>, <em>C-&gt;LastParameter()</em></li>
<li><b>DifferentPointsOnClosedCurve</b> &ndash; The two vertices or points have different locations but they are the extremities of a closed curve.</li>
<li><b>PointWithInfiniteParameter</b> &ndash; A finite coordinate point was associated with an infinite parameter (see the <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_precision.html">Precision</a> package for a definition of infinite values).</li>
<li><b>DifferentsPointAndParameter</b> &ndash; The distance of the 3D point and the point evaluated on the curve with the parameter is greater than the precision.</li>
<li><b>LineThroughIdenticPoints</b> &ndash; Two identical points were given to define a line (construction of an edge without curve), <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp.html#aa61870781423b3eb351676856c99894f">gp::Resolution</a></em> is used to test confusion .</li>
</ul>
<p>The following example creates a rectangle centered on the origin of dimensions H, L with fillets of radius R. The edges and the vertices are stored in the arrays <em>theEdges</em> and <em>theVertices</em>. We use class <em>Array1OfShape</em> (i.e. not arrays of edges or vertices). See the image below.</p>
<div class="image">
<img src="modeling_algos_image024.png" alt="modeling_algos_image024.png"/>
<div class="caption">
Creating a Wire</div></div>
<div class="fragment"><div class="line">#include &lt;BRepBuilderAPI_MakeEdge.hxx&gt; </div><div class="line">#include &lt;TopoDS_Shape.hxx&gt; </div><div class="line">#include &lt;gp_Circ.hxx&gt; </div><div class="line">#include &lt;gp.hxx&gt; </div><div class="line">#include &lt;TopoDS_Wire.hxx&gt; </div><div class="line">#include &lt;TopTools_Array1OfShape.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeWire.hxx&gt; </div><div class="line"></div><div class="line">// Use MakeArc method to make an edge and two vertices </div><div class="line">void MakeArc(Standard_Real x,Standard_Real y, </div><div class="line">Standard_Real R, </div><div class="line">Standard_Real ang, </div><div class="line">TopoDS_Shape&amp; E, </div><div class="line">TopoDS_Shape&amp; V1, </div><div class="line">TopoDS_Shape&amp; V2) </div><div class="line">{ </div><div class="line">gp_Ax2 Origin = gp::XOY(); </div><div class="line">gp_Vec Offset(x, y, 0.); </div><div class="line">Origin.Translate(Offset); </div><div class="line">BRepBuilderAPI_MakeEdge </div><div class="line">ME(gp_Circ(Origin,R),  ang, ang+PI/2); </div><div class="line">E = ME; </div><div class="line">V1 = ME.Vertex1(); </div><div class="line">V2 = ME.Vertex2(); </div><div class="line">} </div><div class="line"></div><div class="line">TopoDS_Wire MakeFilletedRectangle(const Standard_Real H, </div><div class="line">const Standard_Real L, </div><div class="line">const Standard_Real  R) </div><div class="line">{ </div><div class="line">TopTools_Array1OfShape theEdges(1,8); </div><div class="line">TopTools_Array1OfShape theVertices(1,8); </div><div class="line"></div><div class="line">// First create the circular edges and the vertices </div><div class="line">// using the MakeArc function described above. </div><div class="line">void MakeArc(Standard_Real, Standard_Real, </div><div class="line">Standard_Real, Standard_Real, </div><div class="line">TopoDS_Shape&amp;, TopoDS_Shape&amp;,  TopoDS_Shape&amp;); </div><div class="line"></div><div class="line">Standard_Real x = L/2 - R, y = H/2 - R; </div><div class="line">MakeArc(x,-y,R,3.*PI/2.,theEdges(2),theVertices(2), </div><div class="line">theVertices(3)); </div><div class="line">MakeArc(x,y,R,0.,theEdges(4),theVertices(4), </div><div class="line">theVertices(5)); </div><div class="line">MakeArc(-x,y,R,PI/2.,theEdges(6),theVertices(6), </div><div class="line">theVertices(7)); </div><div class="line">MakeArc(-x,-y,R,PI,theEdges(8),theVertices(8), </div><div class="line">theVertices(1)); </div><div class="line">// Create the linear edges </div><div class="line">for (Standard_Integer i = 1; i &lt;= 7; i += 2) </div><div class="line">{ </div><div class="line">theEdges(i) = BRepBuilderAPI_MakeEdge </div><div class="line">(TopoDS::Vertex(theVertices(i)),TopoDS::Vertex </div><div class="line">(theVertices(i+1))); </div><div class="line">} </div><div class="line">// Create the wire using the BRepBuilderAPI_MakeWire </div><div class="line">BRepBuilderAPI_MakeWire MW; </div><div class="line">for (i = 1; i &lt;= 8; i++) </div><div class="line">{ </div><div class="line">MW.Add(TopoDS::Edge(theEdges(i))); </div><div class="line">} </div><div class="line">return MW.Wire(); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_3_3"></a>
Edge 2D</h2>
<p>Use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge2d.html">BRepBuilderAPI_MakeEdge2d</a></em> class to make edges on a working plane from 2d curves. The working plane is a default value of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> package (see the <em>Plane</em> methods).</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge2d.html">BRepBuilderAPI_MakeEdge2d</a></em> class is strictly similar to <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a>, but it uses 2D geometry from gp and Geom2d instead of 3D geometry.</p>
<h2><a class="anchor" id="occt_modalg_3_4"></a>
Polygon</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> class is used to build polygonal wires from vertices or points. Points are automatically changed to vertices as in <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em>.</p>
<p>The basic usage of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> is to create a wire by adding vertices or points using the Add method. At any moment, the current wire can be extracted. The close method can be used to close the current wire. In the following example, a closed wire is created from an array of points.</p>
<div class="fragment"><div class="line">#include &lt;TopoDS_Wire.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakePolygon.hxx&gt; </div><div class="line">#include &lt;TColgp_Array1OfPnt.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Wire ClosedPolygon(const TColgp_Array1OfPnt&amp;  Points) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakePolygon MP; </div><div class="line">for(Standard_Integer i=Points.Lower();i=Points.Upper();i++) </div><div class="line">{ </div><div class="line">MP.Add(Points(i)); </div><div class="line">} </div><div class="line">MP.Close(); </div><div class="line">return MP; </div><div class="line">} </div></div><!-- fragment --><p>Short-cuts are provided for 2, 3, or 4 points or vertices. Those methods have a Boolean last argument to tell if the polygon is closed. The default value is False.</p>
<p>Two examples:</p>
<p>Example of a closed triangle from three vertices: </p><div class="fragment"><div class="line">TopoDS_Wire W =  BRepBuilderAPI_MakePolygon(V1,V2,V3,Standard_True); </div></div><!-- fragment --><p>Example of an open polygon from four points: </p><div class="fragment"><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakePolygon(P1,P2,P3,P4); </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> class maintains a current wire. The current wire can be extracted at any moment and the construction can proceed to a longer wire. After each point insertion, the class maintains the last created edge and vertex, which are returned by the methods <em>Edge, FirstVertex</em> and <em>LastVertex</em>.</p>
<p>When the added point or vertex has the same location as the previous one it is not added to the current wire but the most recently created edge becomes Null. The <em>Added</em> method can be used to test this condition. The <em>MakePolygon</em> class never raises an error. If no vertex has been added, the <em>Wire</em> is <em>Null</em>. If two vertices are at the same location, no edge is created.</p>
<h2><a class="anchor" id="occt_modalg_3_5"></a>
Face</h2>
<p>Use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_face.html">BRepBuilderAPI_MakeFace</a></em> class to create a face from a surface and wires. An underlying surface is constructed from a surface and optional parametric values. Wires can be added to the surface. A planar surface can be constructed from a wire. An error status can be returned after face construction.</p>
<h3><a class="anchor" id="occt_modalg_3_5_1"></a>
Basic face construction method</h3>
<p>A face can be constructed from a surface and four parameters to determine a limitation of the UV space. The parameters are optional, if they are omitted the natural bounds of the surface are used. Up to four edges and vertices are created with a wire. No edge is created when the parameter is infinite.</p>
<div class="fragment"><div class="line">Handle(Geom_Surface) S = ...; // a surface </div><div class="line">Standard_Real umin,umax,vmin,vmax; // parameters </div><div class="line">TopoDS_Face F =  BRepBuilderAPI_MakeFace(S,umin,umax,vmin,vmax); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image025.png" alt="modeling_algos_image025.png"/>
<div class="caption">
Basic Face Construction</div></div>
<p>To make a face from the natural boundary of a surface, the parameters are not required:</p>
<div class="fragment"><div class="line">Handle(Geom_Surface) S = ...; // a surface </div><div class="line">TopoDS_Face F = BRepBuilderAPI_MakeFace(S); </div></div><!-- fragment --><p>Constraints on the parameters are similar to the constraints in <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_edge.html">BRepBuilderAPI_MakeEdge</a></em>.</p><ul>
<li><em>umin,umax (vmin,vmax)</em> must be in the range of the surface and must be increasing.</li>
<li>On a <em>U (V)</em> periodic surface <em>umin</em> and <em>umax (vmin,vmax)</em> are adjusted.</li>
<li><em>umin, umax, vmin, vmax</em> can be infinite. There will be no edge in the corresponding direction.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_3_5_2"></a>
Supplementary face construction methods</h3>
<p>The two basic constructions (from a surface and from a surface and parameters) are implemented for all <em>gp</em> package surfaces, which are transformed in the corresponding Surface from Geom.</p>
<table class="doxtable">
<tr>
<th align="left">gp package surface </th><th align="left"></th><th align="left">Geom package surface  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___pln.html">gp_Pln</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___plane.html">Geom_Plane</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___cylinder.html">gp_Cylinder</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___cylindrical_surface.html">Geom_CylindricalSurface</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___cone.html">gp_Cone</a></em> </td><td align="left">creates a </td><td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___conical_surface.html">Geom_ConicalSurface</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___sphere.html">gp_Sphere</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___spherical_surface.html">Geom_SphericalSurface</a></em> </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___torus.html">gp_Torus</a></em> </td><td align="left"></td><td align="left"><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___toroidal_surface.html">Geom_ToroidalSurface</a></em> </td></tr>
</table>
<p>Once a face has been created, a wire can be added using the <em>Add</em> method. For example, the following code creates a cylindrical surface and adds a wire.</p>
<div class="fragment"><div class="line">gp_Cylinder C = ..; // a cylinder </div><div class="line">TopoDS_Wire W = ...;// a wire </div><div class="line">BRepBuilderAPI_MakeFace MF(C); </div><div class="line">MF.Add(W); </div><div class="line">TopoDS_Face F = MF; </div></div><!-- fragment --><p>More than one wire can be added to a face, provided that they do not cross each other and they define only one area on the surface. (Note that this is not checked). The edges on a Face must have a parametric curve description.</p>
<p>If there is no parametric curve for an edge of the wire on the Face it is computed by projection.</p>
<p>For one wire, a simple syntax is provided to construct the face from the surface and the wire. The above lines could be written:</p>
<div class="fragment"><div class="line">TopoDS_Face F = BRepBuilderAPI_MakeFace(C,W); </div></div><!-- fragment --><p>A planar face can be created from only a wire, provided this wire defines a plane. For example, to create a planar face from a set of points you can use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_polygon.html">BRepBuilderAPI_MakePolygon</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_face.html">BRepBuilderAPI_MakeFace</a></em>.</p>
<div class="fragment"><div class="line">#include &lt;TopoDS_Face.hxx&gt; </div><div class="line">#include &lt;TColgp_Array1OfPnt.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakePolygon.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeFace.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Face PolygonalFace(const TColgp_Array1OfPnt&amp;  thePnts) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakePolygon MP; </div><div class="line">for(Standard_Integer i=thePnts.Lower(); </div><div class="line">i&lt;=thePnts.Upper(); i++) </div><div class="line">{ </div><div class="line">MP.Add(thePnts(i)); </div><div class="line">} </div><div class="line">MP.Close(); </div><div class="line">TopoDS_Face F = BRepBuilderAPI_MakeFace(MP.Wire()); </div><div class="line">return F; </div><div class="line">} </div></div><!-- fragment --><p>The last use of <em>MakeFace</em> is to copy an existing face to add new wires. For example, the following code adds a new wire to a face:</p>
<div class="fragment"><div class="line">TopoDS_Face F = ...; // a face </div><div class="line">TopoDS_Wire W = ...; // a wire </div><div class="line">F = BRepBuilderAPI_MakeFace(F,W); </div></div><!-- fragment --><p>To add more than one wire an instance of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_face.html">BRepBuilderAPI_MakeFace</a></em> class can be created with the face and the first wire and the new wires inserted with the <em>Add</em> method.</p>
<h3><a class="anchor" id="occt_modalg_3_5_3"></a>
Error status</h3>
<p>The <em>Error</em> method returns an error status, which is a term from the <em>BRepBuilderAPI_FaceError</em> enumeration.</p>
<ul>
<li><em>FaceDone</em> &ndash; no error occurred.</li>
<li><em>NoFace</em> &ndash; no initialization of the algorithm; an empty constructor was used.</li>
<li><em>NotPlanar</em> &ndash; no surface was given and the wire was not planar.</li>
<li><em>CurveProjectionFailed</em> &ndash; no curve was found in the parametric space of the surface for an edge.</li>
<li><em>ParametersOutOfRange</em> &ndash; the parameters <em>umin, umax, vmin, vmax</em> are out of the surface.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_3_6"></a>
Wire</h2>
<p>The wire is a composite shape built not from a geometry, but by the assembly of edges. <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_wire.html">BRepBuilderAPI_MakeWire</a></em> class can build a wire from one or more edges or connect new edges to an existing wire.</p>
<p>Up to four edges can be used directly, for example:</p>
<div class="fragment"><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakeWire(E1,E2,E3,E4); </div></div><!-- fragment --><p>For a higher or unknown number of edges the Add method must be used; for example, to build a wire from an array of shapes (to be edges).</p>
<div class="fragment"><div class="line">TopTools_Array1OfShapes theEdges; </div><div class="line">BRepBuilderAPI_MakeWire MW; </div><div class="line">for (Standard_Integer i = theEdge.Lower(); </div><div class="line">i &lt;= theEdges.Upper(); i++) </div><div class="line">MW.Add(TopoDS::Edge(theEdges(i)); </div><div class="line">TopoDS_Wire W = MW; </div></div><!-- fragment --><p>The class can be constructed with a wire. A wire can also be added. In this case, all the edges of the wires are added. For example to merge two wires:</p>
<div class="fragment"><div class="line">#include &lt;TopoDS_Wire.hxx&gt; </div><div class="line">#include &lt;BRepBuilderAPI_MakeWire.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Wire MergeWires (const TopoDS_Wire&amp; W1, </div><div class="line">const  TopoDS_Wire&amp; W2) </div><div class="line">{ </div><div class="line">BRepBuilderAPI_MakeWire MW(W1); </div><div class="line">MW.Add(W2); </div><div class="line">return MW; </div><div class="line">} </div></div><!-- fragment --><p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_wire.html">BRepBuilderAPI_MakeWire</a></em> class connects the edges to the wire. When a new edge is added if one of its vertices is shared with the wire it is considered as connected to the wire. If there is no shared vertex, the algorithm searches for a vertex of the edge and a vertex of the wire, which are at the same location (the tolerances of the vertices are used to test if they have the same location). If such a pair of vertices is found, the edge is copied with the vertex of the wire in place of the original vertex. All the vertices of the edge can be exchanged for vertices from the wire. If no connection is found the wire is considered to be disconnected. This is an error.</p>
<p><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_wire.html">BRepBuilderAPI_MakeWire</a> class can return the last edge added to the wire (Edge method). This edge can be different from the original edge if it was copied.</p>
<p>The Error method returns a term of the <em>BRepBuilderAPI_WireError</em> enumeration: <em>WireDone</em> &ndash; no error occurred. <em>EmptyWire</em> &ndash; no initialization of the algorithm, an empty constructor was used. <em>DisconnectedWire</em> &ndash; the last added edge was not connected to the wire. <em>NonManifoldWire</em> &ndash; the wire with some singularity.</p>
<h2><a class="anchor" id="occt_modalg_3_7"></a>
Shell</h2>
<p>The shell is a composite shape built not from a geometry, but by the assembly of faces. Use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shell.html">BRepBuilderAPI_MakeShell</a></em> class to build a Shell from a set of Faces. What may be important is that each face should have the required continuity. That is why an initial surface is broken up into faces.</p>
<h2><a class="anchor" id="occt_modalg_3_8"></a>
Solid</h2>
<p>The solid is a composite shape built not from a geometry, but by the assembly of shells. Use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_solid.html">BRepBuilderAPI_MakeSolid</a></em> class to build a Solid from a set of Shells. Its use is similar to the use of the MakeWire class: shells are added to the solid in the same way that edges are added to the wire in MakeWire.</p>
<h1><a class="anchor" id="occt_modalg_3b"></a>
Object Modification</h1>
<h2><a class="anchor" id="occt_modalg_3b_1"></a>
Transformation</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___transform.html">BRepBuilderAPI_Transform</a></em> class can be used to apply a transformation to a shape (see class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___trsf.html">gp_Trsf</a></em>). The methods have a boolean argument to copy or share the original shape, as long as the transformation allows (it is only possible for direct isometric transformations). By default, the original shape is shared.</p>
<p>The following example deals with the rotation of shapes.</p>
<div class="fragment"><div class="line">TopoDS_Shape myShape1 = ...; </div><div class="line">// The original shape 1 </div><div class="line">TopoDS_Shape myShape2 = ...; </div><div class="line">// The original shape2 </div><div class="line">gp_Trsf T; </div><div class="line">T.SetRotation(gp_Ax1(gp_Pnt(0.,0.,0.),gp_Vec(0.,0.,1.)), </div><div class="line">2.*PI/5.); </div><div class="line">BRepBuilderAPI_Transformation theTrsf(T); </div><div class="line">theTrsf.Perform(myShape1); </div><div class="line">TopoDS_Shape myNewShape1 = theTrsf.Shape() </div><div class="line">theTrsf.Perform(myShape2,Standard_True); </div><div class="line">// Here duplication is forced </div><div class="line">TopoDS_Shape myNewShape2 = theTrsf.Shape() </div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_3b_2"></a>
Duplication</h2>
<p>Use the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___copy.html">BRepBuilderAPI_Copy</a></em> class to duplicate a shape. A new shape is thus created. In the following example, a solid is copied:</p>
<div class="fragment"><div class="line">TopoDS Solid MySolid; </div><div class="line">....// Creates a solid </div><div class="line"></div><div class="line">TopoDS_Solid myCopy = BRepBuilderAPI_Copy(mySolid); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_4"></a>
Primitives</h1>
<p>The <em> BRepPrimAPI</em> package provides an API (Application Programming Interface) for construction of primitives such as:</p><ul>
<li>Boxes;</li>
<li>Cones;</li>
<li>Cylinders;</li>
<li>Prisms.</li>
</ul>
<p>It is possible to create partial solids, such as a sphere limited by longitude. In real models, primitives can be used for easy creation of specific sub-parts.</p>
<ul>
<li>Construction by sweeping along a profile:<ul>
<li>Linear;</li>
<li>Rotational (through an angle of rotation).</li>
</ul>
</li>
</ul>
<p>Sweeps are objects obtained by sweeping a profile along a path. The profile can be any topology and the path is usually a curve or a wire. The profile generates objects according to the following rules:</p><ul>
<li>Vertices generate Edges</li>
<li>Edges generate Faces.</li>
<li>Wires generate Shells.</li>
<li>Faces generate Solids.</li>
<li>Shells generate Composite Solids.</li>
</ul>
<p>It is not allowed to sweep Solids and Composite Solids. Swept constructions along complex profiles such as BSpline curves also available in the <em> BRepOffsetAPI </em> package. This API provides simple, high level calls for the most common operations.</p>
<h2><a class="anchor" id="occt_modalg_4_1"></a>
Making  Primitives</h2>
<h3><a class="anchor" id="occt_modalg_4_1_1"></a>
Box</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_box.html">BRepPrimAPI_MakeBox</a></em> allows building a parallelepiped box. The result is either a <b>Shell</b> or a <b>Solid</b>. There are four ways to build a box:</p>
<ul>
<li>From three dimensions <em>dx, dy</em> and <em>dz</em>. The box is parallel to the axes and extends for <em>[0,dx] [0,dy] [0,dz] </em>.</li>
<li>From a point and three dimensions. The same as above but the point is the new origin.</li>
<li>From two points, the box is parallel to the axes and extends on the intervals defined by the coordinates of the two points.</li>
<li>From a system of axes <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em> and three dimensions. Same as the first way but the box is parallel to the given system of axes.</li>
</ul>
<p>An error is raised if the box is flat in any dimension using the default precision. The following code shows how to create a box: </p><div class="fragment"><div class="line">TopoDS_Solid theBox = BRepPrimAPI_MakeBox(10.,20.,30.); </div></div><!-- fragment --><p>The four methods to build a box are shown in the figure:</p>
<div class="image">
<img src="modeling_algos_image026.png" alt="modeling_algos_image026.png"/>
<div class="caption">
Making Boxes</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_2"></a>
Wedge</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_wedge.html">BRepPrimAPI_MakeWedge</a></em> class allows building a wedge, which is a slanted box, i.e. a box with angles. The wedge is constructed in much the same way as a box i.e. from three dimensions dx,dy,dz plus arguments or from an axis system, three dimensions, and arguments.</p>
<p>The following figure shows two ways to build wedges. One is to add a dimension <em>ltx</em>, which is the length in <em>x</em> of the face at <em>dy</em>. The second is to add <em>xmin, xmax, zmin</em> and <em>zmax</em> to describe the face at <em>dy</em>.</p>
<p>The first method is a particular case of the second with <em>xmin = 0, xmax = ltx, zmin = 0, zmax = dz</em>. To make a centered pyramid you can use <em>xmin = xmax = dx / 2, zmin = zmax = dz / 2</em>.</p>
<div class="image">
<img src="modeling_algos_image027.png" alt="modeling_algos_image027.png"/>
<div class="caption">
Making Wedges</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_3"></a>
Rotation object</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_one_axis.html">BRepPrimAPI_MakeOneAxis</a></em> is a deferred class used as a root class for all classes constructing rotational primitives. Rotational primitives are created by rotating a curve around an axis. They cover the cylinder, the cone, the sphere, the torus, and the revolution, which provides all other curves.</p>
<p>The particular constructions of these primitives are described, but they all have some common arguments, which are:</p>
<ul>
<li>A system of coordinates, where the Z axis is the rotation axis..</li>
<li>An angle in the range [0,2*PI].</li>
<li>A vmin, vmax parameter range on the curve.</li>
</ul>
<p>The result of the OneAxis construction is a Solid, a Shell, or a Face. The face is the face covering the rotational surface. Remember that you will not use the OneAxis directly but one of the derived classes, which provide improved constructions. The following figure illustrates the OneAxis arguments.</p>
<div class="image">
<img src="modeling_algos_image028.png" alt="modeling_algos_image028.png"/>
<div class="caption">
MakeOneAxis arguments</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_4"></a>
Cylinder</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_cylinder.html">BRepPrimAPI_MakeCylinder</a></em> class allows creating cylindrical primitives. A cylinder is created either in the default coordinate system or in a given coordinate system <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em>. There are two constructions:</p>
<ul>
<li>Radius and height, to build a full cylinder.</li>
<li>Radius, height and angle to build a portion of a cylinder.</li>
</ul>
<p>The following code builds the cylindrical face of the figure, which is a quarter of cylinder along the <em>Y</em> axis with the origin at <em>X,Y,Z</em> the length of <em>DY</em> and radius <em>R</em>.</p>
<div class="fragment"><div class="line">Standard_Real X = 20, Y = 10, Z = 15, R = 10, DY = 30; </div><div class="line">// Make the system of coordinates </div><div class="line">gp_Ax2 axes = gp::ZOX(); </div><div class="line">axes.Translate(gp_Vec(X,Y,Z)); </div><div class="line">TopoDS_Face F = </div><div class="line">BRepPrimAPI_MakeCylinder(axes,R,DY,PI/2.); </div></div><!-- fragment --> <div class="image">
<img src="modeling_algos_image029.png" alt="modeling_algos_image029.png"/>
<div class="caption">
Cylinder</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_5"></a>
Cone</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_cone.html">BRepPrimAPI_MakeCone</a></em> class allows creating conical primitives. Like a cylinder, a cone is created either in the default coordinate system or in a given coordinate system (<a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a>). There are two constructions:</p>
<ul>
<li>Two radii and height, to build a full cone. One of the radii can be null to make a sharp cone.</li>
<li>Radii, height and angle to build a truncated cone.</li>
</ul>
<p>The following code builds the solid cone of the figure, which is located in the default system with radii <em>R1</em> and <em>R2</em> and height <em>H</em>.</p>
<div class="fragment"><div class="line">Standard_Real R1 = 30, R2 = 10, H = 15; </div><div class="line">TopoDS_Solid S = BRepPrimAPI_MakeCone(R1,R2,H); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image030.png" alt="modeling_algos_image030.png"/>
<div class="caption">
Cone</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_6"></a>
Sphere</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_sphere.html">BRepPrimAPI_MakeSphere</a></em> class allows creating spherical primitives. Like a cylinder, a sphere is created either in the default coordinate system or in a given coordinate system <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em>. There are four constructions:</p>
<ul>
<li>From a radius &ndash; builds a full sphere.</li>
<li>From a radius and an angle &ndash; builds a lune (digon).</li>
<li>From a radius and two angles &ndash; builds a wraparound spherical segment between two latitudes. The angles <em>a1</em> and <em>a2</em> must follow the relation: <em>PI/2 &lt;= a1 &lt; a2 &lt;= PI/2 </em>.</li>
<li>From a radius and three angles &ndash; a combination of two previous methods builds a portion of spherical segment.</li>
</ul>
<p>The following code builds four spheres from a radius and three angles.</p>
<div class="fragment"><div class="line">Standard_Real R = 30, ang = </div><div class="line">    PI/2, a1 = -PI/2.3,  a2 = PI/4; </div><div class="line">TopoDS_Solid S1 = BRepPrimAPI_MakeSphere(R); </div><div class="line">TopoDS_Solid S2 = BRepPrimAPI_MakeSphere(R,ang); </div><div class="line">TopoDS_Solid S3 = BRepPrimAPI_MakeSphere(R,a1,a2); </div><div class="line">TopoDS_Solid S4 = BRepPrimAPI_MakeSphere(R,a1,a2,ang); </div></div><!-- fragment --><p>Note that we could equally well choose to create Shells instead of Solids.</p>
<div class="image">
<img src="modeling_algos_image031.png" alt="modeling_algos_image031.png"/>
<div class="caption">
Examples of Spheres</div></div>
<h3><a class="anchor" id="occt_modalg_4_1_7"></a>
Torus</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_torus.html">BRepPrimAPI_MakeTorus</a></em> class allows creating toroidal primitives. Like the other primitives, a torus is created either in the default coordinate system or in a given coordinate system <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax2.html">gp_Ax2</a></em>. There are four constructions similar to the sphere constructions:</p>
<ul>
<li>Two radii &ndash; builds a full torus.</li>
<li>Two radii and an angle &ndash; builds an angular torus segment.</li>
<li>Two radii and two angles &ndash; builds a wraparound torus segment between two radial planes. The angles a1, a2 must follow the relation 0 &lt; a2 - a1 &lt; 2*PI.</li>
<li>Two radii and three angles &ndash; a combination of two previous methods builds a portion of torus segment.</li>
</ul>
<div class="image">
<img src="modeling_algos_image032.png" alt="modeling_algos_image032.png"/>
<div class="caption">
Examples of Tori</div></div>
<p>The following code builds four toroidal shells from two radii and three angles.</p>
<div class="fragment"><div class="line">Standard_Real R1 = 30, R2 = 10, ang = PI, a1 = 0, </div><div class="line">    a2 = PI/2; </div><div class="line">TopoDS_Shell S1 = BRepPrimAPI_MakeTorus(R1,R2); </div><div class="line">TopoDS_Shell S2 = BRepPrimAPI_MakeTorus(R1,R2,ang); </div><div class="line">TopoDS_Shell S3 = BRepPrimAPI_MakeTorus(R1,R2,a1,a2); </div><div class="line">TopoDS_Shell S4 = </div><div class="line">    BRepPrimAPI_MakeTorus(R1,R2,a1,a2,ang); </div></div><!-- fragment --><p>Note that we could equally well choose to create Solids instead of Shells.</p>
<h3><a class="anchor" id="occt_modalg_4_1_8"></a>
Revolution</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revolution.html">BRepPrimAPI_MakeRevolution</a></em> class allows building a uniaxial primitive from a curve. As other uniaxial primitives it can be created in the default coordinate system or in a given coordinate system.</p>
<p>The curve can be any <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___curve.html">Geom_Curve</a></em>, provided it is planar and lies in the same plane as the Z-axis of local coordinate system. There are four modes of construction:</p>
<ul>
<li>From a curve, use the full curve and make a full rotation.</li>
<li>From a curve and an angle of rotation.</li>
<li>From a curve and two parameters to trim the curve. The two parameters must be growing and within the curve range.</li>
<li>From a curve, two parameters, and an angle. The two parameters must be growing and within the curve range.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_4_2"></a>
Sweeping:  Prism, Revolution and Pipe</h2>
<h3><a class="anchor" id="occt_modalg_4_2_1"></a>
Sweeping</h3>
<p>Sweeps are the objects you obtain by sweeping a <b>profile</b> along a <b>path</b>. The profile can be of any topology. The path is usually a curve or a wire. The profile generates objects according to the following rules:</p>
<ul>
<li>Vertices generate Edges</li>
<li>Edges generate Faces.</li>
<li>Wires generate Shells.</li>
<li>Faces generate Solids.</li>
<li>Shells generate Composite Solids</li>
</ul>
<p>It is forbidden to sweep Solids and Composite Solids. A Compound generates a Compound with the sweep of all its elements.</p>
<div class="image">
<img src="modeling_algos_image033.png" alt="modeling_algos_image033.png"/>
<div class="caption">
Generating a sweep</div></div>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_sweep.html">BRepPrimAPI_MakeSweep</a> class</em> is a deferred class used as a root of the the following sweep classes:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_prism.html">BRepPrimAPI_MakePrism</a></em> &ndash; produces a linear sweep</li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revol.html">BRepPrimAPI_MakeRevol</a></em> &ndash; produces a rotational sweep</li>
<li><em>BRepPrimAPI_MakePipe</em> &ndash; produces a general sweep.</li>
</ul>
<h3><a class="anchor" id="occt_modalg_4_2_2"></a>
Prism</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_prism.html">BRepPrimAPI_MakePrism</a></em> class allows creating a linear <b>prism</b> from a shape and a vector or a direction.</p><ul>
<li>A vector allows creating a finite prism;</li>
<li>A direction allows creating an infinite or semi-infinite prism. The semi-infinite or infinite prism is toggled by a Boolean argument. All constructors have a boolean argument to copy the original shape or share it (by default).</li>
</ul>
<p>The following code creates a finite, an infinite and a semi-infinite solid using a face, a direction and a length.</p>
<div class="fragment"><div class="line">TopoDS_Face F = ..; // The swept face </div><div class="line">gp_Dir direc(0,0,1); </div><div class="line">Standard_Real l = 10; </div><div class="line">// create a vector from the direction and the length </div><div class="line">gp_Vec v = direc; </div><div class="line">v *= l; </div><div class="line">TopoDS_Solid P1 = BRepPrimAPI_MakePrism(F,v); </div><div class="line">// finite </div><div class="line">TopoDS_Solid P2 = BRepPrimAPI_MakePrism(F,direc); </div><div class="line">// infinite </div><div class="line">TopoDS_Solid P3 =  BRepPrimAPI_MakePrism(F,direc,Standard_False); </div><div class="line">// semi-infinite </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image034.png" alt="modeling_algos_image034.png"/>
<div class="caption">
,"Finite, infinite, and semi-infinite prisms",420</div></div>
<h3><a class="anchor" id="occt_modalg_4_2_3"></a>
Rotational Sweep</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revol.html">BRepPrimAPI_MakeRevol</a></em> class allows creating a rotational sweep from a shape, an axis (<a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/classgp___ax1.html">gp_Ax1</a>), and an angle. The angle has a default value of 2*PI which means a closed revolution.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_prim_a_p_i___make_revol.html">BRepPrimAPI_MakeRevol</a></em> constructors have a last argument to copy or share the original shape. The following code creates a a full and a partial rotation using a face, an axis and an angle.</p>
<div class="fragment"><div class="line">TopoDS_Face F = ...; // the profile </div><div class="line">gp_Ax1 axis(gp_Pnt(0,0,0),gp_Dir(0,0,1)); </div><div class="line">Standard_Real ang = PI/3; </div><div class="line">TopoDS_Solid R1 = BRepPrimAPI_MakeRevol(F,axis); </div><div class="line">// Full revol </div><div class="line">TopoDS_Solid R2 = BRepPrimAPI_MakeRevol(F,axis,ang); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image035.png" alt="modeling_algos_image035.png"/>
<div class="caption">
Full and partial rotation</div></div>
<h1><a class="anchor" id="occt_modalg_5"></a>
Boolean  Operations</h1>
<p>Boolean operations are used to create new shapes from the combinations of two shapes.</p>
<table class="doxtable">
<tr>
<th align="left">Operation </th><th align="left">Result  </th></tr>
<tr>
<td align="left">Fuse </td><td align="left">all points in S1 or S2 </td></tr>
<tr>
<td align="left">Common </td><td align="left">all points in S1 and S2 </td></tr>
<tr>
<td align="left">Cut S1 by S2</td><td align="left">all points in S1 and not in S2 </td></tr>
</table>
<div class="image">
<img src="modeling_algos_image036.png" alt="modeling_algos_image036.png"/>
<div class="caption">
Boolean Operations</div></div>
<p>From the viewpoint of Topology these are topological operations followed by blending (putting fillets onto edges created after the topological operation).</p>
<p>Topological operations are the most convenient way to create real industrial parts. As most industrial parts consist of several simple elements such as gear wheels, arms, holes, ribs, tubes and pipes. It is usually easy to create those elements separately and then to combine them by Boolean operations in the whole final part.</p>
<p>See <a class="el" href="occt_user_guides__boolean_operations.html">Boolean Operations</a> for detailed documentation.</p>
<h2><a class="anchor" id="occt_modalg_5_1"></a>
Input and Result Arguments</h2>
<p>Boolean Operations have the following types of the arguments and produce the following results:</p><ul>
<li>For arguments having the same shape type (e.g. SOLID / SOLID) the type of the resulting shape will be a COMPOUND, containing shapes of this type;</li>
<li>For arguments having different shape types (e.g. SHELL / SOLID) the type of the resulting shape will be a COMPOUND, containing shapes of the type that is the same as that of the low type of the argument. Example: For SHELL/SOLID the result is a COMPOUND of SHELLs.</li>
<li>For arguments with different shape types some of Boolean Operations can not be done using the default implementation, because of a non-manifold type of the result. Example: the FUSE operation for SHELL and SOLID can not be done, but the CUT operation can be done, where SHELL is the object and SOLID is the tool.</li>
<li>It is possible to perform Boolean Operations on arguments of the COMPOUND shape type. In this case each compound must not be heterogeneous, i.e. it must contain equidimensional shapes (EDGEs or/and WIREs, FACEs or/and SHELLs, SOLIDs). SOLIDs inside the COMPOUND must not contact (intersect or touch) each other. The same condition should be respected for SHELLs or FACEs, WIREs or EDGEs.</li>
<li>Boolean Operations for COMPSOLID type of shape are not supported.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_5_2"></a>
Implementation</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em> class is the deferred root class for Boolean operations.</p>
<h4>Fuse</h4>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___fuse.html">BRepAlgoAPI_Fuse</a></em> performs the Fuse operation.</p>
<div class="fragment"><div class="line">TopoDS_Shape A = ..., B = ...; </div><div class="line">TopoDS_Shape S = BRepAlgoAPI_Fuse(A,B); </div></div><!-- fragment --><h4>Common</h4>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___common.html">BRepAlgoAPI_Common</a></em> performs the Common operation.</p>
<div class="fragment"><div class="line">TopoDS_Shape A = ..., B = ...; </div><div class="line">TopoDS_Shape S = BRepAlgoAPI_Common(A,B); </div></div><!-- fragment --><h4>Cut</h4>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___cut.html">BRepAlgoAPI_Cut</a></em> performs the Cut operation.</p>
<div class="fragment"><div class="line">TopoDS_Shape A = ..., B = ...; </div><div class="line">TopoDS_Shape S = BRepAlgoAPI_Cut(A,B); </div></div><!-- fragment --><h4>Section</h4>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___section.html">BRepAlgoAPI_Section</a></em> performs the section, described as a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___compound.html">TopoDS_Compound</a></em> made of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em>.</p>
<div class="image">
<img src="modeling_algos_image037.png" alt="modeling_algos_image037.png"/>
<div class="caption">
Section operation</div></div>
<div class="fragment"><div class="line">TopoDS_Shape A = ...,  TopoDS_ShapeB = ...; </div><div class="line">TopoDS_Shape S =  BRepAlgoAPI_Section(A,B); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_6"></a>
Fillets and  Chamfers</h1>
<p>This library provides algorithms to make fillets and chamfers on shape edges. The following cases are addressed:</p>
<ul>
<li>Corners and apexes with different radii;</li>
<li>Corners and apexes with different concavity.</li>
</ul>
<p>If there is a concavity, both surfaces that need to be extended and those, which do not, are processed.</p>
<h2><a class="anchor" id="occt_modalg_6_1"></a>
Fillets</h2>
<h2><a class="anchor" id="occt_modalg_6_1_1"></a>
Fillet on shape</h2>
<p>A fillet is a smooth face replacing a sharp edge.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_fillet.html">BRepFilletAPI_MakeFillet</a></em> class allows filleting a shape.</p>
<p>To produce a fillet, it is necessary to define the filleted shape at the construction of the class and add fillet descriptions using the <em>Add</em> method.</p>
<p>A fillet description contains an edge and a radius. The edge must be shared by two faces. The fillet is automatically extended to all edges in a smooth continuity with the original edge. It is not an error to add a fillet twice, the last description holds.</p>
<div class="image">
<img src="modeling_algos_image038.png" alt="modeling_algos_image038.png"/>
<div class="caption">
Filleting two edges using radii r1 and r2.</div></div>
<p>In the following example a filleted box with dimensions a,b,c and radius r is created.</p>
<h3>Constant radius</h3>
<div class="fragment"><div class="line">#include &lt;TopoDS_Shape.hxx&gt; </div><div class="line">#include &lt;TopoDS.hxx&gt; </div><div class="line">#include &lt;BRepPrimAPI_MakeBox.hxx&gt; </div><div class="line">#include &lt;TopoDS_Solid.hxx&gt; </div><div class="line">#include &lt;BRepFilletAPI_MakeFillet.hxx&gt; </div><div class="line">#include &lt;TopExp_Explorer.hxx&gt; </div><div class="line"></div><div class="line">TopoDS_Shape FilletedBox(const Standard_Real a, </div><div class="line">                        const Standard_Real  b, </div><div class="line">                        const Standard_Real  c, </div><div class="line">                        const Standard_Real  r) </div><div class="line">{ </div><div class="line">    TopoDS_Solid Box =  BRepPrimAPI_MakeBox(a,b,c); </div><div class="line">    BRepFilletAPI_MakeFillet  MF(Box); </div><div class="line"></div><div class="line">    // add all the edges  to fillet </div><div class="line">    TopExp_Explorer  ex(Box,TopAbs_EDGE); </div><div class="line">    while (ex.More()) </div><div class="line">    { </div><div class="line">    MF.Add(r,TopoDS::Edge(ex.Current())); </div><div class="line">    ex.Next(); </div><div class="line">    } </div><div class="line">    return MF.Shape(); </div><div class="line">    } </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image039.png" alt="modeling_algos_image039.png"/>
<div class="caption">
Fillet with constant radius</div></div>
<h4>Changing radius</h4>
<div class="fragment"><div class="line">void CSampleTopologicalOperationsDoc::OnEvolvedblend1() </div><div class="line">{ </div><div class="line">    TopoDS_Shape theBox  = BRepPrimAPI_MakeBox(200,200,200); </div><div class="line"></div><div class="line">    BRepFilletAPI_MakeFillet  Rake(theBox); </div><div class="line">    ChFi3d_FilletShape  FSh = ChFi3d_Rational; </div><div class="line">    Rake.SetFilletShape(FSh); </div><div class="line"></div><div class="line">    TColgp_Array1OfPnt2d  ParAndRad(1, 6); </div><div class="line">    ParAndRad(1).SetCoord(0.,  10.); </div><div class="line">    ParAndRad(1).SetCoord(50.,  20.); </div><div class="line">    ParAndRad(1).SetCoord(70.,  20.); </div><div class="line">    ParAndRad(1).SetCoord(130.,  60.); </div><div class="line">    ParAndRad(1).SetCoord(160.,  30.); </div><div class="line">    ParAndRad(1).SetCoord(200.,  20.); </div><div class="line"></div><div class="line">    TopExp_Explorer  ex(theBox,TopAbs_EDGE); </div><div class="line">    Rake.Add(ParAndRad, TopoDS::Edge(ex.Current())); </div><div class="line">    TopoDS_Shape  evolvedBox = Rake.Shape(); </div><div class="line">} </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image040.png" alt="modeling_algos_image040.png"/>
<div class="caption">
Fillet with changing radius</div></div>
<h2><a class="anchor" id="occt_modalg_6_1_2"></a>
Chamfer</h2>
<p>A chamfer is a rectilinear edge replacing a sharp vertex of the face.</p>
<p>The use of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_chamfer.html">BRepFilletAPI_MakeChamfer</a></em> class is similar to the use of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_fillet.html">BRepFilletAPI_MakeFillet</a></em>, except for the following:</p><ul>
<li>The surfaces created are ruled and not smooth.</li>
<li>The <em>Add</em> syntax for selecting edges requires one or two distances, one edge and one face (contiguous to the edge).</li>
</ul>
<div class="fragment"><div class="line">Add(dist,  E, F) </div><div class="line">Add(d1,  d2, E, F) with d1 on the face F. </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image041.png" alt="modeling_algos_image041.png"/>
<div class="caption">
Chamfer</div></div>
<h2><a class="anchor" id="occt_modalg_6_1_3"></a>
Fillet on a planar face</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_fillet_a_p_i___make_fillet2d.html">BRepFilletAPI_MakeFillet2d</a></em> class allows constructing fillets and chamfers on planar faces. To create a fillet on planar face: define it, indicate, which vertex is to be deleted, and give the fillet radius with <em>AddFillet</em> method.</p>
<p>A chamfer can be calculated with <em>AddChamfer</em> method. It can be described by</p><ul>
<li>two edges and two distances</li>
<li>one edge, one vertex, one distance and one angle. Fillets and chamfers are calculated when addition is complete.</li>
</ul>
<p>If face F2 is created by 2D fillet and chamfer builder from face F1, the builder can be rebuilt (the builder recovers the status it had before deletion). To do so, use the following syntax: </p><div class="fragment"><div class="line">BRepFilletAPI_MakeFillet2d builder; </div><div class="line">builder.Init(F1,F2); </div></div><!-- fragment --><h2>Planar Fillet </h2>
<div class="fragment"><div class="line">#include BRepPrimAPI_MakeBox.hxx </div><div class="line">#include TopoDS_Shape.hxx </div><div class="line">#include TopExp_Explorer.hxx </div><div class="line">#include BRepFilletAPI_MakeFillet2d.hxx </div><div class="line">#include TopoDS.hxx </div><div class="line">#include TopoDS_Solid.hxx </div><div class="line"></div><div class="line">TopoDS_Shape FilletFace(const Standard_Real a, </div><div class="line">                        const Standard_Real  b, </div><div class="line">                        const Standard_Real c, </div><div class="line">                        const Standard_Real  r) </div><div class="line"></div><div class="line">{ </div><div class="line">    TopoDS_Solid Box =  BRepPrimAPI_MakeBox (a,b,c); </div><div class="line">    TopExp_Explorer  ex1(Box,TopAbs_FACE); </div><div class="line"></div><div class="line">    const  TopoDS_Face&amp; F = TopoDS::Face(ex1.Current()); </div><div class="line">    BRepFilletAPI_MakeFillet2d  MF(F); </div><div class="line">    TopExp_Explorer  ex2(F, TopAbs_VERTEX); </div><div class="line">    while (ex2.More()) </div><div class="line">    { </div><div class="line">    MF.AddFillet(TopoDS::Vertex(ex2.Current()),r); </div><div class="line">    ex2.Next(); </div><div class="line">    } </div><div class="line">    // while... </div><div class="line">    return MF.Shape(); </div><div class="line">} </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_7"></a>
Offsets, Drafts, Pipes and Evolved shapes</h1>
<p>These classes provide the following services:</p>
<ul>
<li>Creation of offset shapes and their variants such as:<ul>
<li>Hollowing;</li>
<li>Shelling;</li>
<li>Lofting;</li>
</ul>
</li>
<li>Creation of tapered shapes using draft angles;</li>
<li>Creation of sweeps.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_7_1"></a>
Offset computation</h2>
<p>Offset computation can be performed using <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html">BRepOffsetAPI_MakeOffsetShape</a></em>. This class provides API to the two different offset algorithms:</p>
<p>Offset algorithm based on computation of the analytical continuation. Meaning of the parameters can be found in <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html#a23130ef38ae1b07bc2eca631385ac9be">BRepOffsetAPI_MakeOffsetShape::PerformByJoin</a></em> method description. The list below demonstrates principal scheme of this algorithm:</p>
<ul>
<li>At the first step, the offsets are computed.</li>
<li>After this, the analytical continuations are computed for each offset.</li>
<li>Pairwise intersection is computed according to the original topological information (sharing, number of neighbors, etc.).</li>
<li>The offset shape is assembled.</li>
</ul>
<p>The second algorithm is based on the fact that the offset computation for a single face without continuation can always be built. The list below shows simple offset algorithm:</p><ul>
<li>Each surface is mapped to its geometric offset surface.</li>
<li>For each edge, pcurves are mapped to the same pcurves on offset surfaces.</li>
<li>For each edge, 3d curve is constructed by re-approximation of pcurve on the first offset face.</li>
<li>Position of each vertex in a result shell is computed as average point of all ends of edges sharing that vertex.</li>
<li>Tolerances are updated according to the resulting geometry. The possible drawback of the simple algorithm is that it leads, in general case, to tolerance increasing. The tolerances have to grow in order to cover the gaps between the neighbor faces in the output. It should be noted that the actual tolerance growth depends on the offset distance and the quality of joints between the input faces. Anyway the good input shell (smooth connections between adjacent faces) will lead to good result.</li>
</ul>
<p>The snippets below show usage examples: </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html">BRepOffsetAPI_MakeOffsetShape</a> OffsetMaker1;</div><div class="line"><span class="comment">// Computes offset shape using analytical continuation mechanism.</span></div><div class="line">OffsetMaker1.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html#a23130ef38ae1b07bc2eca631385ac9be">PerformByJoin</a>(Shape, OffsetValue, Tolerance);</div><div class="line"><span class="keywordflow">if</span> (OffsetMaker1.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___command.html#ac474eda9b2643b64815bad4b34d39f84">IsDone</a>())</div><div class="line">  NewShape = OffsetMaker1.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html#a5b5b6e22f99b84ee579f163ce4ffd9a9">Shape</a>();</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html">BRepOffsetAPI_MakeOffsetShape</a> OffsetMaker2;</div><div class="line"><span class="comment">// Computes offset shape using simple algorithm.</span></div><div class="line">OffsetMaker2.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_offset_shape.html#a517286824abd82c44010eb2332775c32">PerformBySimple</a>(Shape, OffsetValue);</div><div class="line"><span class="keywordflow">if</span> (OffsetMaker2.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___command.html#ac474eda9b2643b64815bad4b34d39f84">IsDone</a>())</div><div class="line">  NewShape = OffsetMaker2.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html#a5b5b6e22f99b84ee579f163ce4ffd9a9">Shape</a>();</div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_7_2"></a>
Shelling</h2>
<p>Shelling is used to offset given faces of a solid by a specific value. It rounds or intersects adjacent faces along its edges depending on the convexity of the edge. The MakeThickSolidByJoin method of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html">BRepOffsetAPI_MakeThickSolid</a></em> takes the solid, the list of faces to remove and an offset value as input.</p>
<div class="fragment"><div class="line">TopoDS_Solid SolidInitial = ...;</div><div class="line"></div><div class="line">Standard_Real           Of      = ...;</div><div class="line">TopTools_ListOfShape    LCF;</div><div class="line">TopoDS_Shape            Result;</div><div class="line">Standard_Real           Tol = Precision::Confusion();</div><div class="line"></div><div class="line">for (Standard_Integer i = 1 ;i &lt;= n; i++) {</div><div class="line">    TopoDS_Face SF = ...; // a face from SolidInitial</div><div class="line">    LCF.Append(SF);</div><div class="line">}</div><div class="line"></div><div class="line">BRepOffsetAPI_MakeThickSolid SolidMaker;</div><div class="line">SolidMaker.MakeThickSolidByJoin(SolidInitial,</div><div class="line">                                LCF,</div><div class="line">                                Of,</div><div class="line">                                Tol);</div><div class="line">if (SolidMaker.IsDone())</div><div class="line">  Result = SolidMaker.Shape();</div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image042.png" alt="modeling_algos_image042.png"/>
<div class="caption">
Shelling</div></div>
<p>Also it is possible to create solid between shell, offset shell. This functionality can be called using <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html#a3a27e7e4444c98838a93bafb13256188">BRepOffsetAPI_MakeThickSolid::MakeThickSolidBySimple</a></em> method. The code below shows usage example:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html">BRepOffsetAPI_MakeThickSolid</a> SolidMaker;</div><div class="line">SolidMaker.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_thick_solid.html#a3a27e7e4444c98838a93bafb13256188">MakeThickSolidBySimple</a>(Shell, OffsetValue);</div><div class="line"><span class="keywordflow">if</span> (myDone.IsDone())</div><div class="line">  Solid = SolidMaker.<a class="codeRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___make_shape.html#a5b5b6e22f99b84ee579f163ce4ffd9a9">Shape</a>();</div></div><!-- fragment --><h2><a class="anchor" id="occt_modalg_7_3"></a>
Draft Angle</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___draft_angle.html">BRepOffsetAPI_DraftAngle</a></em> class allows modifying a shape by applying draft angles to its planar, cylindrical and conical faces.</p>
<p>The class is created or initialized from a shape, then faces to be modified are added; for each face, three arguments are used:</p><ul>
<li>Direction: the direction with which the draft angle is measured</li>
<li>Angle: value of the angle</li>
<li>Neutral plane: intersection between the face and the neutral plane is invariant.</li>
</ul>
<p>The following code places a draft angle on several faces of a shape; the same direction, angle and neutral plane are used for each face:</p>
<div class="fragment"><div class="line">TopoDS_Shape myShape = ... </div><div class="line">// The original shape </div><div class="line">TopTools_ListOfShape ListOfFace; </div><div class="line">// Creation of the list of faces to be modified </div><div class="line">... </div><div class="line"></div><div class="line">gp_Dir Direc(0.,0.,1.); </div><div class="line">// Z direction </div><div class="line">Standard_Real Angle = 5.*PI/180.; </div><div class="line">// 5 degree angle </div><div class="line">gp_Pln Neutral(gp_Pnt(0.,0.,5.), Direc); </div><div class="line">// Neutral plane Z=5 </div><div class="line">BRepOffsetAPI_DraftAngle theDraft(myShape); </div><div class="line">TopTools_ListIteratorOfListOfShape itl; </div><div class="line">for (itl.Initialize(ListOfFace); itl.More(); itl.Next())  { </div><div class="line">    theDraft.Add(TopoDS::Face(itl.Value()),Direc,Angle,Neutral); </div><div class="line">    if  (!theDraft.AddDone()) { </div><div class="line">        // An error has occurred. The faulty face is given by //  ProblematicShape </div><div class="line">        break; </div><div class="line">        } </div><div class="line">} </div><div class="line">if (!theDraft.AddDone()) { </div><div class="line">    // An error has  occurred </div><div class="line">    TopoDS_Face guilty =  theDraft.ProblematicShape(); </div><div class="line">    ... </div><div class="line">} </div><div class="line">theDraft.Build(); </div><div class="line">if (!theDraft.IsDone()) { </div><div class="line">    // Problem  encountered during reconstruction </div><div class="line">    ... </div><div class="line">} </div><div class="line">else { </div><div class="line">    TopoDS_Shape  myResult = theDraft.Shape(); </div><div class="line">    ... </div><div class="line">} </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image043.png" alt="modeling_algos_image043.png"/>
<div class="caption">
DraftAngle</div></div>
<h2><a class="anchor" id="occt_modalg_7_4"></a>
Pipe  Constructor</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_pipe.html">BRepOffsetAPI_MakePipe</a></em> class allows creating a pipe from a Spine, which is a Wire and a Profile which is a Shape. This implementation is limited to spines with smooth transitions, sharp transitions are precessed by <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_pipe_shell.html">BRepOffsetAPI_MakePipeShell</a></em>. To be more precise the continuity must be G1, which means that the tangent must have the same direction, though not necessarily the same magnitude, at neighboring edges.</p>
<p>The angle between the spine and the profile is preserved throughout the pipe.</p>
<div class="fragment"><div class="line">TopoDS_Wire Spine = ...; </div><div class="line">TopoDS_Shape Profile = ...; </div><div class="line">TopoDS_Shape Pipe =  BRepOffsetAPI_MakePipe(Spine,Profile); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image044.png" alt="modeling_algos_image044.png"/>
<div class="caption">
Example of a Pipe</div></div>
<h2><a class="anchor" id="occt_modalg_7_5"></a>
Evolved Solid</h2>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_offset_a_p_i___make_evolved.html">BRepOffsetAPI_MakeEvolved</a></em> class allows creating an evolved solid from a Spine (planar face or wire) and a profile (wire).</p>
<p>The evolved solid is an unlooped sweep generated by the spine and the profile.</p>
<p>The evolved solid is created by sweeping the profiles reference axes on the spine. The origin of the axes moves to the spine, the X axis and the local tangent coincide and the Z axis is normal to the face.</p>
<p>The reference axes of the profile can be defined following two distinct modes:</p>
<ul>
<li>The reference axes of the profile are the origin axes.</li>
<li>The references axes of the profile are calculated as follows:<ul>
<li>the origin is given by the point on the spine which is the closest to the profile</li>
<li>the X axis is given by the tangent to the spine at the point defined above</li>
<li>the Z axis is the normal to the plane which contains the spine.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Face Spine = ...; </div><div class="line">TopoDS_Wire Profile = ...; </div><div class="line">TopoDS_Shape Evol = </div><div class="line">BRepOffsetAPI_MakeEvolved(Spine,Profile); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_8"></a>
Sewing</h1>
<h2><a class="anchor" id="occt_modalg_8_1"></a>
Introduction</h2>
<p>Sewing allows creation of connected topology (shells and wires) from a set of separate topological elements (faces and edges). For example, Sewing can be used to create of shell from a compound of separate faces.</p>
<div class="image">
<img src="modeling_algos_image045.png" alt="modeling_algos_image045.png"/>
<div class="caption">
Shapes with partially shared edges</div></div>
<p>It is important to distinguish between sewing and other procedures, which modify the geometry, such as filling holes or gaps, gluing, bending curves and surfaces, etc.</p>
<p>Sewing does not change geometrical representation of the shapes. Sewing applies to topological elements (faces, edges) which are not connected but can be connected because they are geometrically coincident : it adds the information about topological connectivity. Already connected elements are left untouched in case of manifold sewing.</p>
<p>Let us define several terms:</p><ul>
<li><b>Floating edges</b> do not belong to any face;</li>
<li><b>Free boundaries</b> belong to one face only;</li>
<li><b>Shared edges</b> belong to several faces, (i.e. two faces in a manifold topology).</li>
<li><b>Sewn faces</b> should have edges shared with each other.</li>
<li><b>Sewn edges</b> should have vertices shared with each other.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_8_2"></a>
Sewing Algorithm</h2>
<p>The sewing algorithm is one of the basic algorithms used for shape processing, therefore its quality is very important.</p>
<p>Sewing algorithm is implemented in the class <em>BRepBuilder_Sewing</em>. This class provides the following methods:</p><ul>
<li>loading initial data for global or local sewing;</li>
<li>setting customization parameters, such as special operation modes, tolerances and output results;</li>
<li>applying analysis methods that can be used to obtain connectivity data required by external algorithms;</li>
<li>sewing of the loaded shapes.</li>
</ul>
<p>Sewing supports working mode with big value tolerance. It is not necessary to repeat sewing step by step while smoothly increasing tolerance.</p>
<p>It is also possible to sew edges to wire and to sew locally separate faces and edges from a shape.</p>
<p>The Sewing algorithm can be subdivided into several independent stages, some of which can be turned on or off using Boolean or other flags.</p>
<p>In brief, the algorithm should find a set of merge candidates for each free boundary, filter them according to certain criteria, and finally merge the found candidates and build the resulting sewn shape.</p>
<p>Each stage of the algorithm or the whole algorithm can be adjusted with the following parameters:</p><ul>
<li><b>Working tolerance</b> defines the maximal distance between topological elements which can be sewn. It is not ultimate that such elements will be actually sewn as many other criteria are applied to make the final decision.</li>
<li><b>Minimal tolerance</b> defines the size of the smallest element (edge) in the resulting shape. It is declared that no edges with size less than this value are created after sewing. If encountered, such topology becomes degenerated.</li>
<li><b>Non-manifold mode</b> enables sewing of non-manifold topology.</li>
</ul>
<h4>Example</h4>
<p>To connect a set of <em>n</em> contiguous but independent faces, do the following:</p>
<div class="fragment"><div class="line">BRepBuilderAPI_Sewing Sew;</div><div class="line">Sew.Add(Face1); </div><div class="line">Sew.Add(Face2); </div><div class="line">...</div><div class="line">Sew.Add(Facen); </div><div class="line">Sew.Perform();</div><div class="line">TopoDS_Shape result= Sew.SewedShape();</div></div><!-- fragment --><p>If all faces have been sewn correctly, the result is a shell. Otherwise, it is a compound. After a successful sewing operation all faces have a coherent orientation.</p>
<h2><a class="anchor" id="occt_modalg_8_3"></a>
Tolerance Management</h2>
<p>To produce a closed shell, Sewing allows specifying the value of working tolerance, exceeding the size of small faces belonging to the shape.</p>
<p>However, if we produce an open shell, it is possible to get incorrect sewing results if the value of working tolerance is too large (i.e. it exceeds the size of faces lying on an open boundary).</p>
<p>The following recommendations can be proposed for tuning-up the sewing process:</p><ul>
<li>Use as small working tolerance as possible. This will reduce the sewing time and, consequently, the number of incorrectly sewn edges for shells with free boundaries.</li>
<li>Use as large minimal tolerance as possible. This will reduce the number of small geometry in the shape, both original and appearing after cutting.</li>
<li>If it is expected to obtain a shell with holes (free boundaries) as a result of sewing, the working tolerance should be set to a value not greater than the size of the smallest element (edge) or smallest distance between elements of such free boundary. Otherwise the free boundary may be sewn only partially.</li>
<li>It should be mentioned that the Sewing algorithm is unable to understand which small (less than working tolerance) free boundary should be kept and which should be sewn.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_8_4"></a>
Manifold and Non-manifold Sewing</h2>
<p>To create one or several shells from a set of faces, sewing merges edges, which belong to different faces or one closed face.</p>
<p>Face sewing supports manifold and non manifold modes. Manifold mode can produce only a manifold shell. Sewing should be used in the non manifold mode to create non manifold shells.</p>
<p>Manifold sewing of faces merges only two nearest edges belonging to different faces or one closed face with each other. Non manifold sewing of faces merges all edges at a distance less than the specified tolerance.</p>
<p>For a complex topology it is advisable to apply first the manifold sewing and then the non manifold sewing a minimum possible working tolerance. However, this is not necessary for a easy topology.</p>
<p>Giving a large tolerance value to non manifold sewing will cause a lot of incorrectness since all nearby geometry will be sewn.</p>
<h2><a class="anchor" id="occt_modalg_8_5"></a>
Local Sewing</h2>
<p>If a shape still has some non-sewn faces or edges after sewing, it is possible to use local sewing with a greater tolerance.</p>
<p>Local sewing is especially good for open shells. It allows sewing an unwanted hole in one part of the shape and keeping a required hole, which is smaller than the working tolerance specified for the local sewing in the other part of the shape. Local sewing is much faster than sewing on the whole shape.</p>
<p>All preexisting connections of the whole shape are kept after local sewing.</p>
<p>For example, if you want to sew two open shells having coincided free edges using local sewing, it is necessary to create a compound from two shells then load the full compound using method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___sewing.html#a03bf44122d6368f558ef396aad190c7c">BRepBuilderAPI_Sewing::Load()</a></em>. After that it is necessary to add local sub-shapes, which should be sewn using method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___sewing.html#ace5bd7514b7e9047ca4c0289f3deb96a">BRepBuilderAPI_Sewing::Add()</a></em>. The result of sewing can be obtained using method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i___sewing.html#ac778fbb2e0f0694fda5e9ab287914b10">BRepBuilderAPI_Sewing::SewedShape()</a></em>.</p>
<p>See the example:</p>
<div class="fragment"><div class="line">//initial sewn shapes</div><div class="line">TopoDS_Shape aS1, aS2;  // these shapes are expected to be well sewn shells</div><div class="line">TopoDS_Shape aComp;</div><div class="line">BRep_Builder aB;</div><div class="line">aB.MakeCompound(aComp);</div><div class="line">aB.Add(aComp, aS1);</div><div class="line">aB.Add(aComp, aS2);</div><div class="line">................................</div><div class="line">aSewing.Load(aComp);</div><div class="line"></div><div class="line">//sub shapes which should be locally sewed</div><div class="line">aSewing.Add(aF1);</div><div class="line">aSewing.Add(aF2);</div><div class="line">//performing sewing</div><div class="line">aSewing.Perform();</div><div class="line">//result shape</div><div class="line">TopoDS_Shape aRes = aSewing.SewedShape();</div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_9"></a>
Features</h1>
<p>This library contained in <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em> package is necessary for creation and manipulation of form and mechanical features that go beyond the classical boundary representation of shapes. In that sense, <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em> is an extension of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> package.</p>
<h2><a class="anchor" id="occt_modalg_9_1"></a>
Form Features</h2>
<p>The form features are depressions or protrusions including the following types:</p>
<ul>
<li>Cylinder;</li>
<li><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_draft.html">Draft</a> Prism;</li>
<li>Prism;</li>
<li>Revolved feature;</li>
<li>Pipe.</li>
</ul>
<p>Depending on whether you wish to make a depression or a protrusion, you can choose either to remove matter (Boolean cut: Fuse equal to 0) or to add it (Boolean fusion: Fuse equal to 1).</p>
<p>The semantics of form feature creation is based on the construction of shapes:</p>
<ul>
<li>for a certain length in a certain direction;</li>
<li>up to the limiting face;</li>
<li>from the limiting face at a height;</li>
<li>above and/or below a plane.</li>
</ul>
<p>The shape defining the construction of a feature can be either a supporting edge or a concerned area of a face.</p>
<p>In case of supporting edge, this contour can be attached to a face of the basis shape by binding. When the contour is bound to this face, the information that the contour will slide on the face becomes available to the relevant class methods. In case of the concerned area of a face, you can, for example, cut it out and move it at a different height, which defines the limiting face of a protrusion or depression.</p>
<p>Topological definition with local operations of this sort makes calculations simpler and faster than a global operation. The latter would entail a second phase of removing unwanted matter to get the same result.</p>
<p>The <em>Form</em> from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat.html">BRepFeat</a></em> package is a deferred class used as a root for form features. It inherits <em>MakeShape</em> from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_builder_a_p_i.html">BRepBuilderAPI</a></em> and provides implementation of methods keep track of all sub-shapes.</p>
<h3><a class="anchor" id="occt_modalg_9_1_1"></a>
Prism</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_prism.html">BRepFeat_MakePrism</a></em> is used to build a prism interacting with a shape. It is created or initialized from</p><ul>
<li>a shape (the basic shape),</li>
<li>the base of the prism,</li>
<li>a face (the face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>a direction,</li>
<li>a Boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another Boolean indicating if the self-intersections have to be found (not used in every case).</li>
</ul>
<p>There are six Perform methods: </p><table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>Perform(Height)</em> </td><td align="left">The resulting prism is of the given length. </td></tr>
<tr>
<td align="left"><em>Perform(Until)</em> </td><td align="left">The prism is defined between the position of the base and the given face. </td></tr>
<tr>
<td align="left"><em>Perform(From, Until)</em> </td><td align="left">The prism is defined between the two faces From and Until. </td></tr>
<tr>
<td align="left"><em>PerformUntilEnd()</em> </td><td align="left">The prism is semi-infinite, limited by the actual position of the base. </td></tr>
<tr>
<td align="left"><em>PerformFromEnd(Until)</em> </td><td align="left">The prism is semi-infinite, limited by the face Until. </td></tr>
<tr>
<td align="left"><em>PerformThruAll()</em> </td><td align="left">The prism is infinite. In the case of a depression, the result is similar to a cut with an infinite prism. In the case of a protrusion, infinite parts are not kept in the result. </td></tr>
</table>
<p><b>Note</b> that <em>Add</em> method can be used before <em>Perform</em> methods to indicate that a face generated by an edge slides onto a face of the base shape.</p>
<p>In the following sequence, a protrusion is performed, i.e. a face of the shape is changed into a prism.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...;  // an initial shape </div><div class="line">TopoDS_Face Fbase = ....; // a base of prism </div><div class="line"></div><div class="line">gp_Dir Extrusion (.,.,.); </div><div class="line"></div><div class="line">// An empty face is given as the sketch face </div><div class="line"></div><div class="line">BRepFeat_MakePrism thePrism(Sbase, Fbase, TopoDS_Face(),  Extrusion, Standard_True, Standard_True); </div><div class="line"></div><div class="line">thePrism, Perform(100.); </div><div class="line">if (thePrism.IsDone()) { </div><div class="line">    TopoDS_Shape  theResult = thePrism; </div><div class="line">    ... </div><div class="line">} </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image047.png" alt="modeling_algos_image047.png"/>
<div class="caption">
Fusion with MakePrism</div></div>
<div class="image">
<img src="modeling_algos_image048.png" alt="modeling_algos_image048.png"/>
<div class="caption">
Creating a prism between two faces with Perform()</div></div>
<h3><a class="anchor" id="occt_modalg_9_1_2"></a>
Draft Prism</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_d_prism.html">BRepFeat_MakeDPrism</a></em> is used to build draft prism topologies interacting with a basis shape. These can be depressions or protrusions. A class object is created or initialized from:</p><ul>
<li>a shape (basic shape),</li>
<li>the base of the prism,</li>
<li>a face (face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>an angle,</li>
<li>a Boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another Boolean indicating if self-intersections have to be found (not used in every case).</li>
</ul>
<p>Evidently the input data for MakeDPrism are the same as for MakePrism except for a new parameter Angle and a missing parameter Direction: the direction of the prism generation is determined automatically as the normal to the base of the prism. The semantics of draft prism feature creation is based on the construction of shapes:</p><ul>
<li>along a length</li>
<li>up to a limiting face</li>
<li>from a limiting face to a height.</li>
</ul>
<p>The shape defining construction of the draft prism feature can be either the supporting edge or the concerned area of a face.</p>
<p>In case of the supporting edge, this contour can be attached to a face of the basis shape by binding. When the contour is bound to this face, the information that the contour will slide on the face becomes available to the relevant class methods. In case of the concerned area of a face, it is possible to cut it out and move it to a different height, which will define the limiting face of a protrusion or depression direction .</p>
<p>The <em>Perform</em> methods are the same as for <em>MakePrism</em>.</p>
<div class="fragment"><div class="line">TopoDS_Shape S = BRepPrimAPI_MakeBox(400.,250.,300.); </div><div class="line">TopExp_Explorer Ex; </div><div class="line">Ex.Init(S,TopAbs_FACE); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">TopoDS_Face F = TopoDS::Face(Ex.Current()); </div><div class="line">Handle(Geom_Surface) surf = BRep_Tool::Surface(F); </div><div class="line">gp_Circ2d </div><div class="line">c(gp_Ax2d(gp_Pnt2d(200.,130.),gp_Dir2d(1.,0.)),50.); </div><div class="line">BRepBuilderAPI_MakeWire MW; </div><div class="line">Handle(Geom2d_Curve) aline = new Geom2d_Circle(c); </div><div class="line">MW.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,PI)); </div><div class="line">MW.Add(BRepBuilderAPI_MakeEdge(aline,surf,PI,2.*PI)); </div><div class="line">BRepBuilderAPI_MakeFace MKF; </div><div class="line">MKF.Init(surf,Standard_False); </div><div class="line">MKF.Add(MW.Wire()); </div><div class="line">TopoDS_Face FP = MKF.Face(); </div><div class="line">BRepLib::BuildCurves3d(FP); </div><div class="line">BRepFeat_MakeDPrism MKDP (S,FP,F,10*PI180,Standard_True, </div><div class="line">                            Standard_True); </div><div class="line">MKDP.Perform(200); </div><div class="line">TopoDS_Shape res1 = MKDP.Shape(); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image049.png" alt="modeling_algos_image049.png"/>
<div class="caption">
A tapered prism</div></div>
<h3><a class="anchor" id="occt_modalg_9_1_3"></a>
Revolution</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_revol.html">BRepFeat_MakeRevol</a></em> is used to build a revolution interacting with a shape. It is created or initialized from:</p><ul>
<li>a shape (the basic shape,)</li>
<li>the base of the revolution,</li>
<li>a face (the face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>an axis of revolution,</li>
<li>a boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another boolean indicating whether the self-intersections have to be found (not used in every case).</li>
</ul>
<p>There are four Perform methods: </p><table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>Perform(Angle)</em> </td><td align="left">The resulting revolution is of the given magnitude. </td></tr>
<tr>
<td align="left"><em>Perform(Until)</em> </td><td align="left">The revolution is defined between the actual position of the base and the given face. </td></tr>
<tr>
<td align="left"><em>Perform(From, Until)</em> </td><td align="left">The revolution is defined between the two faces, From and Until. </td></tr>
<tr>
<td align="left"><em>PerformThruAll()</em> </td><td align="left">The result is similar to Perform(2*PI). </td></tr>
</table>
<p><b>Note</b> that <em>Add</em> method can be used before <em>Perform</em> methods to indicate that a face generated by an edge slides onto a face of the base shape.</p>
<p>In the following sequence, a face is revolved and the revolution is limited by a face of the base shape.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...;  // an initial shape </div><div class="line">TopoDS_Face Frevol = ....; // a base of prism </div><div class="line">TopoDS_Face FUntil = ....; // face limiting the revol </div><div class="line"></div><div class="line">gp_Dir RevolDir (.,.,.); </div><div class="line">gp_Ax1 RevolAx(gp_Pnt(.,.,.), RevolDir); </div><div class="line"></div><div class="line">// An empty face is given as the sketch face </div><div class="line"></div><div class="line">BRepFeat_MakeRevol theRevol(Sbase, Frevol, TopoDS_Face(), RevolAx,  Standard_True, Standard_True); </div><div class="line"></div><div class="line">theRevol.Perform(FUntil); </div><div class="line">if (theRevol.IsDone()) { </div><div class="line">    TopoDS_Shape  theResult = theRevol; </div><div class="line">    ... </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_9_1_4"></a>
Pipe</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___make_pipe.html">BRepFeat_MakePipe</a></em> constructs compound shapes with pipe features: depressions or protrusions. A class object is created or initialized from:</p><ul>
<li>a shape (basic shape),</li>
<li>a base face (profile of the pipe)</li>
<li>a face (face of sketch on which the base has been defined and used to determine whether the base has been defined on the basic shape or not),</li>
<li>a spine wire</li>
<li>a Boolean indicating the type of operation (fusion=protrusion or cut=depression) on the basic shape,</li>
<li>another Boolean indicating if self-intersections have to be found (not used in every case).</li>
</ul>
<p>There are three Perform methods: </p><table class="doxtable">
<tr>
<th align="left">Method </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>Perform()</em> </td><td align="left">The pipe is defined along the entire path (spine wire) </td></tr>
<tr>
<td align="left"><em>Perform(Until)</em> </td><td align="left">The pipe is defined along the path until a given face </td></tr>
<tr>
<td align="left"><em>Perform(From, Until)</em> </td><td align="left">The pipe is defined between the two faces From and Until </td></tr>
</table>
<p>Let us have a look at the example:</p>
<div class="fragment"><div class="line">TopoDS_Shape S = BRepPrimAPI_MakeBox(400.,250.,300.); </div><div class="line">TopExp_Explorer Ex; </div><div class="line">Ex.Init(S,TopAbs_FACE); </div><div class="line">Ex.Next(); </div><div class="line">Ex.Next(); </div><div class="line">TopoDS_Face F1 = TopoDS::Face(Ex.Current()); </div><div class="line">Handle(Geom_Surface) surf = BRep_Tool::Surface(F1); </div><div class="line">BRepBuilderAPI_MakeWire MW1; </div><div class="line">gp_Pnt2d p1,p2; </div><div class="line">p1 = gp_Pnt2d(100.,100.); </div><div class="line">p2 = gp_Pnt2d(200.,100.); </div><div class="line">Handle(Geom2d_Line) aline = GCE2d_MakeLine(p1,p2).Value(); </div><div class="line"></div><div class="line">MW1.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,p1.Distance(p2))); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt2d(150.,200.); </div><div class="line">aline = GCE2d_MakeLine(p1,p2).Value(); </div><div class="line"></div><div class="line">MW1.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,p1.Distance(p2))); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt2d(100.,100.); </div><div class="line">aline = GCE2d_MakeLine(p1,p2).Value(); </div><div class="line"></div><div class="line">MW1.Add(BRepBuilderAPI_MakeEdge(aline,surf,0.,p1.Distance(p2))); </div><div class="line">BRepBuilderAPI_MakeFace MKF1; </div><div class="line">MKF1.Init(surf,Standard_False); </div><div class="line">MKF1.Add(MW1.Wire()); </div><div class="line">TopoDS_Face FP = MKF1.Face(); </div><div class="line">BRepLib::BuildCurves3d(FP); </div><div class="line">TColgp_Array1OfPnt CurvePoles(1,3); </div><div class="line">gp_Pnt pt = gp_Pnt(150.,0.,150.); </div><div class="line">CurvePoles(1) = pt; </div><div class="line">pt = gp_Pnt(200.,100.,150.); </div><div class="line">CurvePoles(2) = pt; </div><div class="line">pt = gp_Pnt(150.,200.,150.); </div><div class="line">CurvePoles(3) = pt; </div><div class="line">Handle(Geom_BezierCurve) curve = new Geom_BezierCurve </div><div class="line">(CurvePoles); </div><div class="line">TopoDS_Edge E = BRepBuilderAPI_MakeEdge(curve); </div><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakeWire(E); </div><div class="line">BRepFeat_MakePipe MKPipe (S,FP,F1,W,Standard_False, </div><div class="line">Standard_True); </div><div class="line">MKPipe.Perform(); </div><div class="line">TopoDS_Shape res1 = MKPipe.Shape(); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image050.png" alt="modeling_algos_image050.png"/>
<div class="caption">
Pipe depression</div></div>
<h2><a class="anchor" id="occt_modalg_9_2"></a>
Mechanical Features</h2>
<p>Mechanical features include ribs, protrusions and grooves (or slots), depressions along planar (linear) surfaces or revolution surfaces.</p>
<p>The semantics of mechanical features is built around giving thickness to a contour. This thickness can either be symmetrical &ndash; on one side of the contour &ndash; or dissymmetrical &ndash; on both sides. As in the semantics of form features, the thickness is defined by construction of shapes in specific contexts.</p>
<p>The development contexts differ, however, in the case of mechanical features. Here they include extrusion:</p><ul>
<li>to a limiting face of the basis shape;</li>
<li>to or from a limiting plane;</li>
<li>to a height.</li>
</ul>
<p>A class object is created or initialized from</p><ul>
<li>a shape (basic shape);</li>
<li>a wire (base of rib or groove);</li>
<li>a plane (plane of the wire);</li>
<li>direction1 (a vector along which thickness will be built up);</li>
<li>direction2 (vector opposite to the previous one along which thickness will be built up, may be null);</li>
<li>a Boolean indicating the type of operation (fusion=rib or cut=groove) on the basic shape;</li>
<li>another Boolean indicating if self-intersections have to be found (not used in every case).</li>
</ul>
<h3><a class="anchor" id="occt_modalg_9_2_1"></a>
Linear Form</h3>
<p>Linear form is implemented in <em>MakeLinearForm</em> class, which creates a rib or a groove along a planar surface. There is one <em>Perform()</em> method, which performs a prism from the wire along the <em>direction1</em> and <em>direction2</em> interacting with base shape <em>Sbase</em>. The height of the prism is <em>Magnitude(Direction1)+Magnitude(direction2)</em>.</p>
<div class="fragment"><div class="line">BRepBuilderAPI_MakeWire mkw; </div><div class="line">gp_Pnt p1 = gp_Pnt(0.,0.,0.); </div><div class="line">gp_Pnt p2 = gp_Pnt(200.,0.,0.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(200.,0.,50.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(50.,0.,50.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(50.,0.,200.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">p2 = gp_Pnt(0.,0.,200.); </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p1,p2)); </div><div class="line">p1 = p2; </div><div class="line">mkw.Add(BRepBuilderAPI_MakeEdge(p2,gp_Pnt(0.,0.,0.))); </div><div class="line">TopoDS_Shape S = BRepBuilderAPI_MakePrism(BRepBuilderAPI_MakeFace </div><div class="line">    (mkw.Wire()),gp_Vec(gp_Pnt(0.,0.,0.),gp_P </div><div class="line">     nt(0.,100.,0.))); </div><div class="line">TopoDS_Wire W = BRepBuilderAPI_MakeWire(BRepBuilderAPI_MakeEdge(gp_Pnt </div><div class="line">    (50.,45.,100.), </div><div class="line">gp_Pnt(100.,45.,50.))); </div><div class="line">Handle(Geom_Plane) aplane = </div><div class="line">    new Geom_Plane(gp_Pnt(0.,45.,0.),  gp_Vec(0.,1.,0.)); </div><div class="line">BRepFeat_MakeLinearForm aform(S, W, aplane, gp_Dir </div><div class="line">    (0.,5.,0.), gp_Dir(0.,-3.,0.),  1, Standard_True); </div><div class="line">aform.Perform(); </div><div class="line">TopoDS_Shape res = aform.Shape(); </div></div><!-- fragment --><div class="image">
<img src="modeling_algos_image051.png" alt="modeling_algos_image051.png"/>
<div class="caption">
Creating a rib</div></div>
<h3><a class="anchor" id="occt_modalg_9_2_3"></a>
Gluer</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___gluer.html">BRepFeat_Gluer</a></em> allows gluing two solids along faces. The contact faces of the glued shape must not have parts outside the contact faces of the basic shape. Upon completion the algorithm gives the glued shape with cut out parts of faces inside the shape.</p>
<p>The class is created or initialized from two shapes: the glued shape and the basic shape (on which the other shape is glued). Two <em>Bind</em> methods are used to bind a face of the glued shape to a face of the basic shape and an edge of the glued shape to an edge of the basic shape.</p>
<p><b>Note</b> that every face and edge has to be bounded, if two edges of two glued faces are coincident they must be explicitly bounded.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...; // the basic shape </div><div class="line">TopoDS_Shape Sglued = ...; // the glued shape </div><div class="line"></div><div class="line">TopTools_ListOfShape Lfbase; </div><div class="line">TopTools_ListOfShape Lfglued; </div><div class="line">// Determination of the glued faces </div><div class="line">... </div><div class="line"></div><div class="line">BRepFeat_Gluer theGlue(Sglue, Sbase); </div><div class="line">TopTools_ListIteratorOfListOfShape itlb(Lfbase); </div><div class="line">TopTools_ListIteratorOfListOfShape itlg(Lfglued); </div><div class="line">for (; itlb.More(); itlb.Next(), itlg(Next()) { </div><div class="line">const TopoDS_Face&amp; f1 = TopoDS::Face(itlg.Value()); </div><div class="line">const TopoDS_Face&amp; f2 = TopoDS::Face(itlb.Value()); </div><div class="line">theGlue.Bind(f1,f2); </div><div class="line">// for example, use the class FindEdges from LocOpe to </div><div class="line">// determine coincident edges </div><div class="line">LocOpe_FindEdge fined(f1,f2); </div><div class="line">for (fined.InitIterator(); fined.More(); fined.Next()) { </div><div class="line">theGlue.Bind(fined.EdgeFrom(),fined.EdgeTo()); </div><div class="line">} </div><div class="line">} </div><div class="line">theGlue.Build(); </div><div class="line">if (theGlue.IsDone() { </div><div class="line">TopoDS_Shape  theResult = theGlue; </div><div class="line">... </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_modalg_9_2_4"></a>
Split Shape</h3>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_feat___split_shape.html">BRepFeat_SplitShape</a></em> is used to split faces of a shape into wires or edges. The shape containing the new entities is rebuilt, sharing the unmodified ones.</p>
<p>The class is created or initialized from a shape (the basic shape). Three Add methods are available:</p><ul>
<li><em>Add(Wire, Face)</em> &ndash; adds a new wire on a face of the basic shape.</li>
<li><em>Add(Edge, Face)</em> &ndash; adds a new edge on a face of the basic shape.</li>
<li><em>Add(EdgeNew, EdgeOld)</em> &ndash; adds a new edge on an existing one (the old edge must contain the new edge).</li>
</ul>
<p><b>Note</b> The added wires and edges must define closed wires on faces or wires located between two existing edges. Existing edges must not be intersected.</p>
<div class="fragment"><div class="line">TopoDS_Shape Sbase = ...; // basic shape </div><div class="line">TopoDS_Face Fsplit = ...; // face of Sbase </div><div class="line">TopoDS_Wire Wsplit = ...; // new wire contained in Fsplit </div><div class="line">BRepFeat_SplitShape Spls(Sbase); </div><div class="line">Spls.Add(Wsplit, Fsplit); </div><div class="line">TopoDS_Shape theResult = Spls; </div><div class="line">...</div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_10"></a>
Hidden Line  Removal</h1>
<p>To provide the precision required in industrial design, drawings need to offer the possibility of removing lines, which are hidden in a given projection.</p>
<p>For this the Hidden Line Removal component provides two algorithms: <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em>.</p>
<p>These algorithms are based on the principle of comparing each edge of the shape to be visualized with each of its faces, and calculating the visible and the hidden parts of each edge. Note that these are not the algorithms used in generating shading, which calculate the visible and hidden parts of each face in a shape to be visualized by comparing each face in the shape with every other face in the same shape. These algorithms operate on a shape and remove or indicate edges hidden by faces. For a given projection, they calculate a set of lines characteristic of the object being represented. They are also used in conjunction with extraction utilities, which reconstruct a new, simplified shape from a selection of the results of the calculation. This new shape is made up of edges, which represent the shape visualized in the projection.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> allows working with the shape itself, whereas <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> works with a polyhedral simplification of the shape. When you use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em>, you obtain an exact result, whereas, when you use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em>, you reduce the computation time, but obtain polygonal segments.</p>
<p>No smoothing algorithm is provided. Consequently, a polyhedron will be treated as such and the algorithms will give the results in form of line segments conforming to the mathematical definition of the polyhedron. This is always the case with <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em>.</p>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> can deal with any kind of object, for example, assemblies of volumes, surfaces, and lines, as long as there are no unfinished objects or points within it.</p>
<p>However, there some restrictions in HLR use:</p><ul>
<li>Points are not processed;</li>
<li>Infinite faces or lines are not processed.</li>
</ul>
<div class="image">
<img src="modeling_algos_image052.png" alt="modeling_algos_image052.png"/>
<div class="caption">
,"Sharp, smooth and sewn edges  in a simple screw shape",320</div></div>
<div class="image">
<img src="modeling_algos_image053.png" alt="modeling_algos_image053.png"/>
<div class="caption">
Outline edges and isoparameters in the same shape</div></div>
<div class="image">
<img src="modeling_algos_image054.png" alt="modeling_algos_image054.png"/>
<div class="caption">
A simple screw shape seen with shading</div></div>
<div class="image">
<img src="modeling_algos_image055.png" alt="modeling_algos_image055.png"/>
<div class="caption">
An extraction showing hidden sharp edges</div></div>
<p>The following services are related to Hidden Lines Removal :</p>
<h3>Loading Shapes</h3>
<p>To pass a <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em> to an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em> object, use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html#a0eadaefc85e28011fce6a08077d2a2b0">HLRBRep_Algo::Add</a></em>. With an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> object, use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html#a56179512a3ad0dae960185e54227c33b">HLRBRep_PolyAlgo::Load</a></em>. If you wish to add several shapes, use Add or Load as often as necessary.</p>
<h3>Setting view parameters</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___internal_algo.html#a8e2bbecb941db0a6b20d7a9d56cc0275">HLRBRep_Algo::Projector</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html#ac523c08aa18008c7f1b2a8aa8d7771fb">HLRBRep_PolyAlgo::Projector</a></em> set a projector object which defines the parameters of the view. This object is an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_algo___projector.html">HLRAlgo_Projector</a></em>.</p>
<h3>Computing the projections</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html#a4ca601b6c97f27d62e2bea14c36f0820">HLRBRep_PolyAlgo::Update</a></em> launches the calculation of outlines of the shape visualized by the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> framework.</p>
<p>In the case of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></em>, use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___internal_algo.html#abff0f03c57628a1748cb5066865aacbb">HLRBRep_Algo::Update</a></em>. With this algorithm, you must also call the method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___internal_algo.html#aef401192a7b5f910dc8682a1b8426f05">HLRBRep_Algo::Hide</a></em> to calculate visible and hidden lines of the shape to be visualized. With an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> object, visible and hidden lines are computed by <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html">HLRBRep_PolyHLRToShape</a></em>.</p>
<h3>Extracting edges</h3>
<p>The classes <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___h_l_r_to_shape.html">HLRBRep_HLRToShape</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html">HLRBRep_PolyHLRToShape</a></em> present a range of extraction filters for an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a> object</em> and an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></em> object, respectively. They highlight the type of edge from the results calculated by the algorithm on a shape. With both extraction classes, you can highlight the following types of output:</p><ul>
<li>visible/hidden sharp edges;</li>
<li>visible/hidden smooth edges;</li>
<li>visible/hidden sewn edges;</li>
<li>visible/hidden outline edges.</li>
</ul>
<p>To perform extraction on an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html">HLRBRep_PolyHLRToShape</a></em> object, use <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_h_l_r_to_shape.html#a8114cd998c5f8a42f2f4b9745f9585a4">HLRBRep_PolyHLRToShape::Update</a></em> function.</p>
<p>For an <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___h_l_r_to_shape.html">HLRBRep_HLRToShape</a></em> object built from an <em>HLRBRepAlgo</em> object you can also highlight:</p><ul>
<li>visible isoparameters and</li>
<li>hidden isoparameters.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_10_1"></a>
Examples</h2>
<h3><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___algo.html">HLRBRep_Algo</a></h3>
<div class="fragment"><div class="line">// Build The algorithm object </div><div class="line">myAlgo = new HLRBRep_Algo(); </div><div class="line"></div><div class="line">// Add Shapes into the algorithm </div><div class="line">TopTools_ListIteratorOfListOfShape anIterator(myListOfShape); </div><div class="line">for (;anIterator.More();anIterator.Next()) </div><div class="line">myAlgo-Add(anIterator.Value(),myNbIsos); </div><div class="line"></div><div class="line">// Set The Projector (myProjector is a </div><div class="line">HLRAlgo_Projector) </div><div class="line">myAlgo-Projector(myProjector); </div><div class="line"></div><div class="line">// Build HLR </div><div class="line">myAlgo-&gt;Update(); </div><div class="line"></div><div class="line">// Set The Edge Status </div><div class="line">myAlgo-&gt;Hide(); </div><div class="line"></div><div class="line">// Build the extraction object : </div><div class="line">HLRBRep_HLRToShape aHLRToShape(myAlgo); </div><div class="line"></div><div class="line">// extract the results : </div><div class="line">TopoDS_Shape VCompound           = aHLRToShape.VCompound(); </div><div class="line">TopoDS_Shape Rg1LineVCompound                            = </div><div class="line">aHLRToShape.Rg1LineVCompound(); </div><div class="line">TopoDS_Shape RgNLineVCompound                            = </div><div class="line">aHLRToShape.RgNLineVCompound(); </div><div class="line">TopoDS_Shape OutLineVCompound                            = </div><div class="line">aHLRToShape.OutLineVCompound(); </div><div class="line">TopoDS_Shape IsoLineVCompound                            = </div><div class="line">aHLRToShape.IsoLineVCompound(); </div><div class="line">TopoDS_Shape HCompound           = aHLRToShape.HCompound(); </div><div class="line">TopoDS_Shape Rg1LineHCompound                            = </div><div class="line">aHLRToShape.Rg1LineHCompound(); </div><div class="line">TopoDS_Shape RgNLineHCompound                            = </div><div class="line">aHLRToShape.RgNLineHCompound(); </div><div class="line">TopoDS_Shape OutLineHCompound                            = </div><div class="line">aHLRToShape.OutLineHCompound(); </div><div class="line">TopoDS_Shape IsoLineHCompound                            = </div><div class="line">aHLRToShape.IsoLineHCompound(); </div></div><!-- fragment --><h3><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_h_l_r_b_rep___poly_algo.html">HLRBRep_PolyAlgo</a></h3>
<div class="fragment"><div class="line">// Build The algorithm object </div><div class="line">myPolyAlgo = new HLRBRep_PolyAlgo(); </div><div class="line"></div><div class="line">// Add Shapes into the algorithm </div><div class="line">TopTools_ListIteratorOfListOfShape </div><div class="line">anIterator(myListOfShape); </div><div class="line">for (;anIterator.More();anIterator.Next()) </div><div class="line">myPolyAlgo-Load(anIterator.Value()); </div><div class="line"></div><div class="line">// Set The Projector (myProjector is a </div><div class="line">HLRAlgo_Projector) </div><div class="line">myPolyAlgo-&gt;Projector(myProjector); </div><div class="line"></div><div class="line">// Build HLR </div><div class="line">myPolyAlgo-&gt;Update(); </div><div class="line"></div><div class="line">// Build the extraction object : </div><div class="line">HLRBRep_PolyHLRToShape aPolyHLRToShape; </div><div class="line">aPolyHLRToShape.Update(myPolyAlgo); </div><div class="line"></div><div class="line">// extract the results : </div><div class="line">TopoDS_Shape VCompound = </div><div class="line">aPolyHLRToShape.VCompound(); </div><div class="line">TopoDS_Shape Rg1LineVCompound = </div><div class="line">aPolyHLRToShape.Rg1LineVCompound(); </div><div class="line">TopoDS_Shape RgNLineVCompound = </div><div class="line">aPolyHLRToShape.RgNLineVCompound(); </div><div class="line">TopoDS_Shape OutLineVCompound = </div><div class="line">aPolyHLRToShape.OutLineVCompound(); </div><div class="line">TopoDS_Shape HCompound = </div><div class="line">aPolyHLRToShape.HCompound(); </div><div class="line">TopoDS_Shape Rg1LineHCompound = </div><div class="line">aPolyHLRToShape.Rg1LineHCompound(); </div><div class="line">TopoDS_Shape RgNLineHCompound = </div><div class="line">aPolyHLRToShape.RgNLineHCompound(); </div><div class="line">TopoDS_Shape OutLineHCompound = </div><div class="line">aPolyHLRToShape.OutLineHCompound(); </div></div><!-- fragment --><h1><a class="anchor" id="occt_modalg_11"></a>
Meshing</h1>
<h2><a class="anchor" id="occt_modalg_11_1"></a>
Mesh presentations</h2>
<p>In addition to support of exact geometrical representation of 3D objects Open CASCADE Technology provides functionality to work with tessellated representations of objects in form of meshes.</p>
<p>Open CASCADE Technology mesh functionality provides:</p><ul>
<li>data structures to store surface mesh data associated to shapes, and some basic algorithms to handle these data</li>
<li>data structures and algorithms to build surface triangular mesh from <em>BRep</em> objects (shapes).</li>
<li>tools to extend 3D visualization capabilities of Open CASCADE Technology with displaying meshes along with associated pre- and post-processor data.</li>
</ul>
<p>Open CASCADE Technology includes two mesh converters:</p><ul>
<li>VRML converter translates Open CASCADE shapes to VRML 1.0 files (Virtual Reality Modeling Language). Open CASCADE shapes may be translated in two representations: shaded or wireframe. A shaded representation present shapes as sets of triangles computed by a mesh algorithm while a wireframe representation present shapes as sets of curves.</li>
<li>STL converter translates Open CASCADE shapes to STL files. STL (STtereoLithography) format is widely used for rapid prototyping.</li>
</ul>
<p>Open CASCADE SAS also offers Advanced Mesh Products:</p><ul>
<li><a href="http://www.opencascade.com/content/mesh-framework">Open CASCADE Mesh Framework (OMF)</a></li>
<li><a href="http://www.opencascade.com/content/express-mesh">Express Mesh</a></li>
</ul>
<p>Besides, we can efficiently help you in the fields of surface and volume meshing algorithms, mesh optimization algorithms etc. If you require a qualified advice about meshing algorithms, do not hesitate to benefit from the expertise of our team in that domain.</p>
<p>The projects dealing with numerical simulation can benefit from using SALOME - an Open Source Framework for CAE with CAD data interfaces, generic Pre- and Post- F.E. processors and API for integrating F.E. solvers.</p>
<p>Learn more about SALOME platform on <a href="http://www.salome-platform.org">http://www.salome-platform.org</a></p>
<h2><a class="anchor" id="occt_modalg_11_2"></a>
Meshing algorithm</h2>
<p>The algorithm of shape triangulation is provided by the functionality of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___incremental_mesh.html">BRepMesh_IncrementalMesh</a></em> class, which adds a triangulation of the shape to its topological data structure. This triangulation is used to visualize the shape in shaded mode.</p>
<div class="fragment"><div class="line">const Standard_Real aRadius = 10.0; </div><div class="line">const Standard_Real aHeight = 25.0; </div><div class="line">BRepPrimAPI_MakeCylinder aCylinder(aRadius, aHeight); </div><div class="line">TopoDS_Shape aShape = aCylinder.Shape();</div><div class="line"></div><div class="line">const Standard_Real aLinearDeflection   = 0.01;</div><div class="line">const Standard_Real anAngularDeflection = 0.5;</div><div class="line"></div><div class="line">BRepMesh_IncrementalMesh aMesh(aShape, aLinearDeflection, Standard_False, anAngularDeflection);</div></div><!-- fragment --><p>The default meshing algorithm <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_mesh___incremental_mesh.html">BRepMesh_IncrementalMesh</a></em> has two major options to define triangulation &ndash; linear and angular deflections.</p>
<p>At the first step all edges from a face are discretized according to the specified parameters.</p>
<p>At the second step, the faces are tessellated. Linear deflection limits the distance between a curve and its tessellation, whereas angular deflection limits the angle between subsequent segments in a polyline.</p>
<div class="image">
<img src="modeling_algos_image056.png" alt="modeling_algos_image056.png"/>
<div class="caption">
Deflection parameters of BRepMesh_IncrementalMesh algorithm</div></div>
<p>Linear deflection limits the distance between triangles and the face interior.</p>
<div class="image">
<img src="modeling_algos_image057.png" alt="modeling_algos_image057.png"/>
<div class="caption">
Linear deflection</div></div>
<p>Note that if a given value of linear deflection is less than shape tolerance then the algorithm will skip this value and will take into account the shape tolerance.</p>
<p>The application should provide deflection parameters to compute a satisfactory mesh. Angular deflection is relatively simple and allows using a default value (12-20 degrees). Linear deflection has an absolute meaning and the application should provide the correct value for its models. Giving small values may result in a too huge mesh (consuming a lot of memory, which results in a long computation time and slow rendering) while big values result in an ugly mesh.</p>
<p>For an application working in dimensions known in advance it can be reasonable to use the absolute linear deflection for all models. This provides meshes according to metrics and precision used in the application (for example, it it is known that the model will be stored in meters, 0.004 m is enough for most tasks).</p>
<p>However, an application that imports models created in other applications may not use the same deflection for all models. Note that actually this is an abnormal situation and this application is probably just a viewer for CAD models with dimensions varying by an order of magnitude. This problem can be solved by introducing the concept of a relative linear deflection with some LOD (level of detail). The level of detail is a scale factor for absolute deflection, which is applied to model dimensions.</p>
<p>Meshing covers a shape with a triangular mesh. Other than hidden line removal, you can use meshing to transfer the shape to another tool: a manufacturing tool, a shading algorithm, a finite element algorithm, or a collision algorithm.</p>
<p>You can obtain information on the shape by first exploring it. To access triangulation of a face in the shape later, use <em>BRepTool::Triangulation</em>. To access a polygon, which is the approximation of an edge of the face, use <em>BRepTool::PolygonOnTriangulation</em>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 30 2017 17:08:49 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
