<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Shape Healing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__shape_healing.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Shape Healing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_shg_1">Overview</a><ul><li class="level2"><a href="#occt_shg_1_1">Introduction</a></li>
<li class="level2"><a href="#occt_shg_1_2">Examples of use</a></li>
<li class="level2"><a href="#occt_shg_1_3">Toolkit Structure</a></li>
<li class="level2"><a href="#occt_shg_1_4">Querying the statuses</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_shg_2">Repair</a><ul><li class="level2"><a href="#occt_shg_2_1">Basic Shape Repair</a></li>
<li class="level2"><a href="#occt_shg_2_2">Shape Correction.</a><ul><li class="level3"><a href="#occt_shg_2_2_1">Fixing sub-shapes</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_shg_2_3">Repairing tools</a><ul><li class="level3"><a href="#occt_shg_2_3_1">General Workflow</a></li>
<li class="level3"><a href="#occt_shg_2_3_2">Flags Management</a></li>
<li class="level3"><a href="#occt_shg_2_3_3">Repairing tool for shapes</a></li>
<li class="level3"><a href="#occt_shg_2_3_4">Repairing tool for solids</a></li>
<li class="level3"><a href="#occt_shg_2_3_5">Repairing tool for shells</a></li>
<li class="level3"><a href="#occt_shg_2_3_6">Repairing tool for faces</a></li>
<li class="level3"><a href="#occt_shg_2_3_7">Repairing tool for wires</a></li>
<li class="level3"><a href="#occt_shg_2_3_8">Repairing tool for edges</a></li>
<li class="level3"><a href="#occt_shg_2_3_9">Repairing tool for the wireframe of a shape</a></li>
<li class="level3"><a href="#occt_shg_2_3_10">Tool for removing small faces from a shape</a></li>
<li class="level3"><a href="#occt_shg_2_3_11">Tool to modify  tolerances of shapes (Class ShapeFix_ShapeTolerance).</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_shg_3">Analysis</a><ul><li class="level2"><a href="#occt_shg_3_1">Analysis of shape validity</a><ul><li class="level3"><a href="#occt_shg_3_1_1">Analysis of orientation of wires on a face.</a></li>
<li class="level3"><a href="#occt_shg_3_1_2">Analysis of wire validity</a></li>
<li class="level3"><a href="#occt_shg_3_1_3">Analysis of edge validity</a></li>
<li class="level3"><a href="#occt_shg_3_1_4">Analysis of presence of small faces</a></li>
<li class="level3"><a href="#occt_shg_3_1_5">Analysis of shell validity and closure</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_shg_3_2">Analysis of shape properties.</a><ul><li class="level3"><a href="#occt_shg_3_2_1">Analysis of tolerance on shape</a></li>
<li class="level3"><a href="#occt_shg_3_2_2">Analysis of free boundaries.</a></li>
<li class="level3"><a href="#occt_shg_3_2_3">Analysis of shape contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_shg_4">Upgrading</a><ul><li class="level2"><a href="#occt_shg_4_1">Tools for splitting a shape according to a specified criterion</a><ul><li class="level3"><a href="#occt_shg_4_1_1">Overview</a></li>
<li class="level3"><a href="#occt_shg_4_1_2">Using tools available for shape splitting.</a></li>
<li class="level3"><a href="#occt_shg_4_1_3">Creation of a new tool for splitting a shape.</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_shg_4_2">General splitting tools.</a><ul><li class="level3"><a href="#occt_shg_4_2_1">General tool for shape splitting</a></li>
<li class="level3"><a href="#occt_shg_4_2_2">General tool for face splitting</a></li>
<li class="level3"><a href="#occt_shg_4_2_3">General tool for wire splitting</a></li>
<li class="level3"><a href="#occt_shg_4_2_4">General tool for edge splitting</a></li>
<li class="level3"><a href="#occt_shg_4_2_5">General tools for geometry splitting</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_shg_4_3">Specific splitting tools.</a><ul><li class="level3"><a href="#occt_shg_4_3_1">Conversion of shape geometry to the target continuity</a></li>
<li class="level3"><a href="#occt_shg_4_3_2">Splitting by angle</a></li>
<li class="level3"><a href="#occt_shg_4_3_3">Conversion of 2D, 3D curves and surfaces to Bezier</a></li>
<li class="level3"><a href="#occt_shg_4_3_4">Tool for splitting closed faces</a></li>
<li class="level3"><a href="#occt_shg_4_3_5">Tool for splitting a C0 BSpline 2D or 3D curve to a sequence C1 BSpline curves</a></li>
<li class="level3"><a href="#occt_shg_4_3_6">Tool for splitting faces</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_shg_4_4">Customization of shapes</a><ul><li class="level3"><a href="#occt_shg_4_4_1">Conversion of indirect surfaces.</a></li>
<li class="level3"><a href="#occt_shg_4_4_2">Shape Scaling</a></li>
<li class="level3"><a href="#occt_shg_4_4_3">Conversion of curves and surfaces to BSpline</a></li>
<li class="level3"><a href="#occt_shg_4_4_4">Conversion of elementary surfaces into surfaces of revolution</a></li>
<li class="level3"><a href="#occt_shg_4_4_5">Conversion of elementary surfaces into Bspline surfaces</a></li>
<li class="level3"><a href="#occt_shg_4_4_6">Getting the history of modification of sub-shapes.</a></li>
<li class="level3"><a href="#occt_shg_4_4_7">Remove internal wires</a></li>
<li class="level3"><a href="#occt_shg_4_4_8">Conversion of surfaces</a></li>
<li class="level3"><a href="#occt_shg_4_4_9">Unify Same Domain</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_shg_5_">Auxiliary tools for repairing, analysis and upgrading</a><ul><li class="level2"><a href="#occt_shg_5_1">Tool for rebuilding shapes</a></li>
<li class="level2"><a href="#occt_shg_5_2">Status definition</a></li>
<li class="level2"><a href="#occt_shg_5_3">Tool representing a wire</a></li>
<li class="level2"><a href="#occt_shg_5_4">Tool for exploring shapes</a></li>
<li class="level2"><a href="#occt_shg_5_5">Tool for attaching messages to objects</a></li>
<li class="level2"><a href="#occt_shg_5_6">Tools for performance measurement</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_shg_6">Shape Processing</a><ul><li class="level2"><a href="#occt_shg_6_1">Usage Workflow</a></li>
<li class="level2"><a href="#occt_shg_6_2">Operators</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_shg_7">Messaging mechanism</a><ul><li class="level2"><a href="#occt_shg_7_1">Message Gravity</a></li>
<li class="level2"><a href="#occt_shg_7_2">Tool for loading a message file into memory</a></li>
<li class="level2"><a href="#occt_shg_7_3">Tool for managing filling messages</a></li>
<li class="level2"><a href="#occt_shg_7_4">Tool for managing trace files</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_shg_1"></a>
Overview</h1>
<h2><a class="anchor" id="occt_shg_1_1"></a>
Introduction</h2>
<p>This manual explains how to use Shape Healing. It provides basic documentation on its operation. For advanced information on Shape Healing and its applications, see our <a href="http://www.opencascade.com/content/tutorial-learning">E-learning &amp; Training</a> offerings.</p>
<p>The <b>Shape Healing</b> toolkit provides a set of tools to work on the geometry and topology of Open CASCADE Technology (<b>OCCT</b>) shapes. Shape Healing adapts shapes so as to make them as appropriate for use by Open CASCADE Technology as possible.</p>
<h2><a class="anchor" id="occt_shg_1_2"></a>
Examples of use</h2>
<p>Here are a few examples of typical problems with illustrations of how Shape Healing deals with them:</p>
<h4>Face with missing seam edge</h4>
<p>The problem: Face on a periodical surface is limited by wires which make a full trip around the surface. These wires are closed in 3d but not closed in parametric space of the surface. This is not valid in Open CASCADE. The solution: Shape Healing fixes this face by inserting seam edge which combines two open wires and thus closes the parametric space. Note that internal wires are processed correctly.</p>
<h4>Wrong orientation of wires</h4>
<p>The problem: Wires on face have incorrect orientation, so that interior and outer parts of the face are mixed. The solution: Shape Healing recovers correct orientation of wires.</p>
<h4>Self-intersecting wire</h4>
<p>The problem: Face is invalid because its boundary wire has self-intersection (on two adjacent edges) The solution: Shape Healing cuts intersecting edges at intersection points thus making boundary valid.</p>
<h4>Lacking edge</h4>
<p>The problem: There is a gap between two edges in the wire, so that wire is not closed The solution: Shape Healing closes a gap by inserting lacking edge.</p>
<h2><a class="anchor" id="occt_shg_1_3"></a>
Toolkit Structure</h2>
<p><b>Shape Healing</b> currently includes several packages that are designed to help you to:</p><ul>
<li>analyze shape characteristics and, in particular, identify shapes that do not comply with Open CASCADE Technology validity rules</li>
<li>fix some of the problems shapes may have</li>
<li>upgrade shape characteristics for users needs, for example a C0 supporting surface can be upgraded so that it becomes C1 continuous.</li>
</ul>
<p>The following diagram shows dependencies of API packages:</p>
<div class="image">
<object type="image/svg+xml" data="shape_healing_image009.svg">shape_healing_image009.svg</object>
<div class="caption">
Shape Healing packages</div></div>
<p>Each sub-domain has its own scope of functionality:</p><ul>
<li>analysis &ndash; exploring shape properties, computing shape features, detecting violation of OCCT requirements (shape itself is not modified);</li>
<li>fixing &ndash; fixing shape to meet the OCCT requirements (the shape may change its original form: modifying, removing, constructing sub-shapes, etc.);</li>
<li>upgrade &ndash; shape improvement for better usability in Open CASCADE Technology or other algorithms (the shape is replaced with a new one, but geometrically they are the same);</li>
<li>customization &ndash; modifying shape representation to fit specific needs (shape is not modified, only the form of its representation is modified);</li>
<li>processing &ndash; mechanism of managing shape modification via a user-editable resource file.</li>
</ul>
<p><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message.html">Message</a> management is used for creating messages, filling them with various parameters and storing them in the trace file. This tool provides functionality for attaching messages to the shapes for deferred analysis of various run-time events. In this document only general principles of using Shape Healing will be described. For more detailed information please see the corresponding header files.</p>
<p>Tools responsible for analysis, fixing and upgrading of shapes can give the information about how these operations were performed. This information can be obtained by the user with the help of mechanism of status querying.</p>
<h2><a class="anchor" id="occt_shg_1_4"></a>
Querying the statuses</h2>
<p>Each fixing and upgrading tool has its own status, which is reset when their methods are called. The status can contain several flags, which give the information about how the method was performed. For exploring the statuses, a set of methods named <em>Status...()</em> is provided. These methods accept enumeration <em>ShapeExtend_Status</em> and return True if the status has the corresponding flag set. The meaning of flags for each method is described below.</p>
<p>The status may contain a set of Boolean flags (internally represented by bits). Flags are coded by enumeration ShapeExtend_Status. This enumeration provides the following families of statuses:</p><ul>
<li><em>ShapeExtend_OK</em> &ndash; The situation is OK, no operation is necessary and has not been performed.</li>
<li><em>ShapeExtend_DONE</em> &ndash; The operation has been successfully performed.</li>
<li><em>ShapeExtend_FAIL</em> &ndash; An error has occurred during operation.</li>
</ul>
<p>It is possible to test the status for the presence of some flag(s), using Status...() method(s) provided by the class:</p>
<div class="fragment"><div class="line">if ( object.Status.. ( ShapeExtend_DONE ) ) {// something was done </div><div class="line">} </div></div><!-- fragment --><p>8 'DONE' and 8 'FAIL' flags, named ShapeExtend_DONE1 ... ShapeExtend_FAIL8, are defined for a detailed analysis of the encountered situation. Each method assigns its own meaning to each flag, documented in the header for that method. There are also three enumerative values used for testing several flags at a time:</p><ul>
<li><em>ShapeExtend_OK</em> &ndash; if no flags have been set;</li>
<li><em>ShapeExtend_DONE</em> &ndash; if at least one ShapeExtend_DONEi has been set;</li>
<li><em>ShapeExtend_FAIL</em> &ndash; if at least one ShapeExtend_FAILi has been set.</li>
</ul>
<h1><a class="anchor" id="occt_shg_2"></a>
Repair</h1>
<p>Algorithms for fixing problematic (violating the OCCT requirements) shapes are placed in package <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em>.</p>
<p>Each class of package <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em> deals with one certain type of shapes or with some family of problems.</p>
<p>There is no necessity for you to detect problems before using <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em> because all components of package <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em> make an analysis of existing problems before fixing them by a corresponding tool from package of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis.html">ShapeAnalysis</a></em> and then fix the discovered problems.</p>
<p>The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em> package currently includes functions that:</p><ul>
<li>add a 2D curve or a 3D curve where one is missing,</li>
<li>correct a deviation of a 2D curve from a 3D curve when it exceeds a given tolerance value,</li>
<li>limit the tolerance value of shapes within a given range,</li>
<li>set a given tolerance value for shapes,</li>
<li>repair the connections between adjacent edges of a wire,</li>
<li>correct self-intersecting wires,</li>
<li>add seam edges,</li>
<li>correct gaps between 3D and 2D curves,</li>
<li>merge and remove small edges,</li>
<li>correct orientation of shells and solids.</li>
</ul>
<h2><a class="anchor" id="occt_shg_2_1"></a>
Basic Shape Repair</h2>
<p>The simplest way for fixing shapes is to use classes <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shape.html">ShapeFix_Shape</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wireframe.html">ShapeFix_Wireframe</a></em> on a whole shape with default parameters. A combination of these tools can fix most of the problems that shapes may have. The sequence of actions is as follows :</p>
<ol type="1">
<li>Create tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shape.html">ShapeFix_Shape</a></em> and initialize it by shape: <pre class="fragment">Handle(ShapeFix_Shape) sfs = new ShapeFix_Shape; 
sfs-&gt;Init ( shape ); 
</pre></li>
<li><p class="startli">Set the basic precision, the maximum allowed tolerance, the minimal allowed tolerance: </p><pre class="fragment"> sfs-&gt;SetPrecision ( Prec ); 
 sfs-&gt;SetMaxTolerance ( maxTol ); 
 sfs-&gt;SetMinTolerance ( mintol );
</pre><p class="startli">where:</p><ul>
<li><em>Prec</em> &ndash; basic precision.</li>
<li><em>maxTol</em> &ndash; maximum allowed tolerance. All problems will be detected for cases when a dimension of invalidity is larger than the basic precision or a tolerance of sub-shape on that problem is detected. The maximum tolerance value limits the increasing tolerance for fixing a problem such as fix of not connected and self-intersected wires. If a value larger than the maximum allowed tolerance is necessary for correcting a detected problem the problem can not be fixed. The maximal tolerance is not taking into account during computation of tolerance of edges in <em>ShapeFix_SameParameter()</em> method and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#afe9ae0b11c21dd2d22f12c8751ebd285">ShapeFix_Edge::FixVertexTolerance()</a></em> method. See <a class="el" href="occt_user_guides__shape_healing.html#occt_shg_2_3_8">Repairing tool for edges</a> for details.</li>
<li><em>minTol</em> &ndash; minimal allowed tolerance. It defines the minimal allowed length of edges. Detected edges having length less than the specified minimal tolerance will be removed if <em>ModifyTopologyMode</em> in Repairing tool for wires is set to true. See <a class="el" href="occt_user_guides__shape_healing.html#occt_shg_2_3_7">Repairing tool for wires</a> for details.</li>
</ul>
</li>
<li>Launch fixing: <pre class="fragment"> sfs-&gt;Perform(); 
</pre></li>
<li><p class="startli">Get the result: </p><pre class="fragment"> TopoDS_Shape aResult = sfs-&gt;Shape(); 
</pre><p class="startli">In some cases using only <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shape.html">ShapeFix_Shape</a></em> can be insufficient. It is possible to use tools for merging and removing small edges and fixing gaps between 2D and 3D curves.</p>
</li>
<li>Create <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wireframe.html">ShapeFix_Wireframe</a></em> tool and initialize it by shape: <div class="fragment"><div class="line">Handle(ShapeFix_Wirefarme) SFWF = new ShapeFix_Wirefarme(shape); </div><div class="line">Or </div><div class="line">Handle(ShapeFix_Wirefarme) SFWF = new ShapeFix_Wirefarme; </div><div class="line">SFWF-&gt;Load(shape); </div></div><!-- fragment --></li>
<li>Set the basic precision and the maximum allowed tolerance: <div class="fragment"><div class="line">sfs-&gt;SetPrecision ( Prec ); </div><div class="line">sfs-&gt;SetMaxTolerance ( maxTol ); </div></div><!-- fragment --> See the description for <em>Prec</em> and <em>maxTol</em> above.</li>
<li>Merge and remove small edges: <div class="fragment"><div class="line">SFWF-&gt;DropSmallEdgesMode() = Standard_True; </div><div class="line">SFWF-&gt;FixSmallEdges(); </div></div><!-- fragment --> <b>Note:</b> Small edges are not removed with the default mode, but in many cases removing small edges is very useful for fixing a shape.</li>
<li>Fix gaps for 2D and 3D curves <div class="fragment"><div class="line">SFWF-&gt;FixWireGaps(); </div></div><!-- fragment --></li>
<li>Get the result <div class="fragment"><div class="line">TopoDS_Shape Result = SFWF-&gt;Shape(); </div></div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="occt_shg_2_2"></a>
Shape Correction.</h2>
<p>If you do not want to make fixes on the whole shape or make a definite set of fixes you can set flags for separate fix cases (marking them ON or OFF) and you can also use classes for fixing specific types of sub-shapes such as solids, shells, faces, wires, etc.</p>
<p>For each type of sub-shapes there are specific types of fixing tools such as <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___solid.html">ShapeFix_Solid</a>, <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shell.html">ShapeFix_Shell</a>, <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___face.html">ShapeFix_Face</a>, <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wire.html">ShapeFix_Wire</a>,</em> etc.</p>
<h3><a class="anchor" id="occt_shg_2_2_1"></a>
Fixing sub-shapes</h3>
<p>If you want to make a fix on one sub-shape of a certain shape it is possible to take the following steps:</p><ul>
<li>create a tool for a specified sub-shape type and initialize this tool by the sub-shape;</li>
<li>create a tool for rebuilding the shape and initialize it by the whole shape (section 5.1);</li>
<li>set a tool for rebuilding the shape in the tool for fixing the sub-shape;</li>
<li>fix the sub-shape;</li>
<li>get the resulting whole shape containing a new corrected sub-shape.</li>
</ul>
<p>For example, in the following way it is possible to fix face <em>Face1</em> of shape <em>Shape1</em>:</p>
<div class="fragment"><div class="line">//create tools for fixing a face </div><div class="line">Handle(ShapeFix_Face)  SFF= new ShapeFix_Face; </div><div class="line"></div><div class="line">// create tool for rebuilding a shape and initialize it by shape </div><div class="line">Handle(ShapeBuild_ReShape) Context = new ShapeBuild_ReShape;  </div><div class="line">Context-&gt;Apply(Shape1); </div><div class="line"></div><div class="line">//set a tool for rebuilding a shape in the tool for fixing </div><div class="line">SFF-&gt;SetContext(Context); </div><div class="line"></div><div class="line">//initialize the fixing tool by one face </div><div class="line">SFF-&gt;Init(Face1); </div><div class="line"></div><div class="line">//fix the set face </div><div class="line">SFF-&gt;Perform(); </div><div class="line"></div><div class="line">//get the result </div><div class="line">TopoDS_Shape  NewShape = Context-&gt;Apply(Shape1); </div><div class="line">//Resulting shape contains the fixed face. </div></div><!-- fragment --><p>A set of required fixes and invalid sub-shapes can be obtained with the help of tools responsible for the analysis of shape validity (section 3.2).</p>
<h2><a class="anchor" id="occt_shg_2_3"></a>
Repairing tools</h2>
<p>Each class of package <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a> deals with one certain type of shapes or with a family of problems. Each repairing tool makes fixes for the specified shape and its sub-shapes with the help of method <em>Perform()</em> containing an optimal set of fixes. The execution of these fixes in the method Perform can be managed with help of a set of control flags (fixes can be either forced or forbidden).</p>
<h3><a class="anchor" id="occt_shg_2_3_1"></a>
General Workflow</h3>
<p>The following sequence of actions should be applied to perform fixes:</p><ol type="1">
<li>Create a tool.</li>
<li>Set the following values:<ul>
<li>the working precision by method <em>SetPrecision()</em> (default 1.e-7)</li>
<li>set the maximum allowed tolerance by method <em>SetMaxTolerance()</em> (by default it is equal to the working precision).</li>
<li>set the minimum tolerance by method <em>SetMinTolerance()</em> (by default it is equal to the working precision).</li>
<li>set a tool for rebuilding shapes after the modification (tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em>) by method <em>SetContext()</em>. For separate faces, wires and edges this tool is set optionally.</li>
<li>to force or forbid some of fixes, set the corresponding flag to 0 or 1.</li>
</ul>
</li>
<li>Initialize the tool by the shape with the help of methods Init or Load</li>
<li>Use method <em>Perform()</em> or create a custom set of fixes.</li>
<li>Check the statuses of fixes by the general method <em>Status</em> or specialized methods <em>Status_</em>(for example <em>StatusSelfIntersection</em> (<em>ShapeExtentd_DONE</em>)). See the description of statuses below.</li>
<li>Get the result in two ways :<ul>
<li>with help of a special method <em>Shape(),Face(),Wire().Edge()</em>.</li>
<li>from the rebuilding tool by method <em>Apply</em> (for access to rebuilding tool use method <em>Context()</em>): <div class="fragment"><div class="line">TopoDS_Shape resultShape = fixtool-&gt;Context()-&gt;Apply(initialShape); </div></div><!-- fragment --> Modification fistory for the shape and its sub-shapes can be obtained from the tool for shape re-building (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em>).</li>
</ul>
</li>
</ol>
<div class="fragment"><div class="line">TopoDS_Shape modifsubshape = fixtool-&gt;Context() -&gt; Apply(initsubshape); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_2_3_2"></a>
Flags Management</h3>
<p>The flags <em>Fix...Mode()</em> are used to control the execution of fixing procedures from the API fixing methods. By default, these flags have values equal to -1, this means that the corresponding procedure will either be called or not called, depending on the situation. If the flag is set to 1, the procedure is executed anyway; if the flag is 0, the procedure is not executed. The name of the flag corresponds to the fixing procedure that is controlled. For each fixing tool there exists its own set of flags. To set a flag to the desired value, get a tool containing this flag and set the flag to the required value.</p>
<p>For example, it is possible to forbid performing fixes to remove small edges - <em>FixSmall</em></p>
<div class="fragment"><div class="line">Handle(ShapeFix_Shape) Sfs = new ShapeFix_Shape(shape); </div><div class="line">Sfs-&gt; FixWireTool ()-&gt;FixSmallMode () =0; </div><div class="line">if(Sfs-&gt;Perform()) </div><div class="line">    TopoDS_Shape resShape = Sfs-&gt;Shape(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_2_3_3"></a>
Repairing tool for shapes</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shape.html">ShapeFix_Shape</a></em> allows using repairing tools for all sub-shapes of a shape. It provides access to all repairing tools for fixing sub-shapes of the specified shape and to all control flags from these tools.</p>
<p>For example, it is possible to force the removal of invalid 2D curves from a face.</p>
<div class="fragment"><div class="line">TopoDS_Face face â€¦ // face with invalid 2D curves. </div><div class="line">//creation of tool and its initialization by shape. </div><div class="line">Handle(ShapeFix_Shape) sfs = new ShapeFix_Shape(face); </div><div class="line">//set work precision and max allowed tolerance. </div><div class="line">sfs-&gt;SetPrecision(prec); </div><div class="line">sfs-&gt;SetMaxTolerance(maxTol); </div><div class="line">//set the value of flag for forcing the removal of 2D curves </div><div class="line">sfs-&gt;FixWireTool()-&gt;FixRemovePCurveMode() =1; </div><div class="line">//reform fixes </div><div class="line">sfs-&gt;Perform(); </div><div class="line">//getting the result </div><div class="line">if(sfs-&gt;Status(ShapeExtend_DONE) ) { </div><div class="line"> cout &lt;&lt; &quot;Shape was fixed&quot; &lt;&lt; endl; </div><div class="line"> TopoDS_Shape resFace = sfs-&gt;Shape(); </div><div class="line">} </div><div class="line">else if(sfs-&gt;Status(ShapeExtend_FAIL)) { </div><div class="line">cout&lt;&lt; &quot;Shape could not be fixed&quot; &lt;&lt; endl; </div><div class="line">} </div><div class="line">else if(sfs-&gt;Status(ShapeExtent_OK)) { </div><div class="line">cout&lt;&lt; &quot;Initial face is valid with specified precision =&quot;&lt;&lt; precendl; </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_2_3_4"></a>
Repairing tool for solids</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___solid.html">ShapeFix_Solid</a></em> allows fixing solids and building a solid from a shell to obtain a valid solid with a finite volume. The tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shell.html">ShapeFix_Shell</a></em> is used for correction of shells belonging to a solid.</p>
<p>This tool has the following control flags:</p><ul>
<li><em>FixShellMode</em> &ndash; Mode for applying fixes of <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shell.html">ShapeFix_Shell</a>, True by default.</li>
<li><em>CreateOpenShellMode</em> &ndash; If it is equal to true solids are created from open shells, else solids are created from closed shells only, False by default.</li>
</ul>
<h3><a class="anchor" id="occt_shg_2_3_5"></a>
Repairing tool for shells</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___shell.html">ShapeFix_Shell</a></em> allows fixing wrong orientation of faces in a shell. It changes the orientation of faces in the shell so that all faces in the shell have coherent orientations. If it is impossible to orient all faces in the shell (like in case of Mebious tape), then a few manifold or non-manifold shells will be created depending on the specified Non-manifold mode. The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___face.html">ShapeFix_Face</a></em> tool is used to correct faces in the shell. This tool has the following control flags:</p><ul>
<li><em>FixFaceMode</em> &ndash; mode for applying the fixes of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___face.html">ShapeFix_Face</a></em>, <em>True</em> by default.</li>
<li><em>FixOrientationMode</em> &ndash; mode for applying a fix for the orientation of faces in the shell.</li>
</ul>
<h3><a class="anchor" id="occt_shg_2_3_6"></a>
Repairing tool for faces</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___face.html">ShapeFix_Face</a></em> allows fixing the problems connected with wires of a face. It allows controlling the creation of a face (adding wires), and fixing wires by means of tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wire.html">ShapeFix_Wire</a></em>. When a wire is added to a face, it can be reordered and degenerated edges can be fixed. This is performed or not depending on the user-defined flags (by default, False). The following fixes are available:</p><ul>
<li>fixing of wires orientation on the face. If the face has no wire, the natural bounds are computed. If the face is on a spherical surface and has two or more wires on it describing holes, the natural bounds are added. In case of a single wire, it is made to be an outer one. If the face has several wires, they are oriented to lay one outside another (if possible). If the supporting surface is periodic, 2D curves of internal wires can be shifted on integer number of periods to put them inside the outer wire.</li>
<li>fixing the case when the face on the closed surface is defined by a set of closed wires, and the seam is missing (this is not valid in OCCT). In that case, these wires are connected by means of seam edges into the same wire.</li>
</ul>
<p>This tool has the following control flags:</p><ul>
<li><em>FixWireMode</em> &ndash; mode for applying fixes of a wire, True by default.</li>
<li><em>FixOrientationMode</em> &ndash; mode for orienting a wire to border a limited square, True by default.</li>
<li><em>FixAddNaturalBoundMode</em> &ndash; mode for adding natural bounds to a face, False by default.</li>
<li><em>FixMissingSeamMode</em> &ndash; mode to fix a missing seam, True by default. If True, tries to insert a seam.</li>
<li><em>FixSmallAreaWireMode</em> &ndash; mode to fix a small-area wire, False by default. If True, drops wires bounding small areas.</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Face face = ...; </div><div class="line">TopoDS_Wire wire = ...; </div><div class="line"></div><div class="line">//Creates a tool and adds a wire to the face </div><div class="line">ShapeFix_Face sff (face); </div><div class="line">sff.Add (wire); </div><div class="line"></div><div class="line">//use method Perform to fix the wire and the face </div><div class="line">sff.Perfom(); </div><div class="line"></div><div class="line">//or make a separate fix for the orientation of wire on the face </div><div class="line">sff.FixOrientation(); </div><div class="line"></div><div class="line">//Get the resulting face </div><div class="line">TopoDS_Face newface = sff.Face(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_2_3_7"></a>
Repairing tool for wires</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wire.html">ShapeFix_Wire</a></em> allows fixing a wire. Its method <em>Perform()</em> performs all the available fixes in addition to the geometrical filling of gaps. The geometrical filling of gaps can be made with the help of the tool for fixing the wireframe of shape <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wireframe.html">ShapeFix_Wireframe</a></em>.</p>
<p>The fixing order and the default behavior of <em>Perform()</em> is as follows:</p><ul>
<li>Edges in the wire are reordered by <em>FixReorder</em>. Most of fixing methods expect edges in a wire to be ordered, so it is necessary to make call to <em>FixReorder()</em> before making any other fixes. Even if it is forbidden, the analysis of whether the wire is ordered or not is performed anyway.</li>
<li>Small edges are removed by <em>FixSmall</em> .</li>
<li>Edges in the wire are connected (topologically) by <em>FixConnected</em> (if the wire is ordered).</li>
<li>Edges (3Dcurves and 2D curves) are fixed by <em>FixEdgeCurves</em> (without <em>FixShifted</em> if the wire is not ordered).</li>
<li>Degenerated edges are added by <em>FixDegenerated</em>(if the wire is ordered).</li>
<li>Self-intersection is fixed by <em>FixSelfIntersection</em> (if the wire is ordered and <em>ClosedMode</em> is True).</li>
<li>Lacking edges are fixed by <em>FixLacking</em> (if the wire is ordered).</li>
</ul>
<p>The flag <em>ClosedWireMode</em> specifies whether the wire is (or should be) closed or not. If that flag is True (by default), fixes that require or force connection between edges are also executed for the last and the first edges.</p>
<p>The fixing methods can be turned on/off by using their corresponding control flags:</p><ul>
<li><em>FixReorderMode,</em></li>
<li><em>FixSmallMode,</em></li>
<li><em>FixConnectedMode,</em></li>
<li><em>FixEdgeCurvesMode,</em></li>
<li><em>FixDegeneratedMode,</em></li>
<li><em>FixSelfIntersectionMode</em></li>
</ul>
<p>Some fixes can be made in three ways:</p><ul>
<li>Increasing the tolerance of an edge or a vertex.</li>
<li>Changing topology (adding/removing/replacing an edge in the wire and/or replacing the vertex in the edge, copying the edge etc.).</li>
<li>Changing geometry (shifting a vertex or adjusting ends of an edge curve to vertices, or recomputing a 3D curve or 2D curves of the edge).</li>
</ul>
<p>When it is possible to make a fix in more than one way (e.g., either by increasing the tolerance or shifting a vertex), it is chosen according to the user-defined flags:</p><ul>
<li><em>ModifyTopologyMode</em> &ndash; allows modifying topology, False by default.</li>
<li><em>ModifyGeometryMode</em> &ndash; allows modifying geometry. Now this flag is used only in fixing self-intersecting edges (allows to modify 2D curves) and is True by default.</li>
</ul>
<h4>Fixing disordered edges</h4>
<p><em>FixReorder</em> is necessary for most other fixes (but is not necessary for Open CASCADE Technology). It checks whether edges in the wire go in a sequential order (the end of a preceding edge is the start of a following one). If it is not so, an attempt to reorder the edges is made.</p>
<h4>Fixing small edges</h4>
<p><em>FixSmall</em> method searches for the edges, which have a length less than the given value (degenerated edges are ignored). If such an edge is found, it is removed provided that one of the following conditions is satisfied:</p><ul>
<li>both end vertices of that edge are one and the same vertex,</li>
<li>end vertices of the edge are different, but the flag <em>ModifyTopologyMode</em> is True. In the latter case, method <em>FixConnected</em> is applied to the preceding and the following edges to ensure their connection.</li>
</ul>
<h4>Fixing disconnected edges</h4>
<p><em>FixConnected</em> method forces two adjacent edges to share the same common vertex (if they do not have a common one). It checks whether the end vertex of the preceding edge coincides with the start vertex of the following edge with the given precision, and then creates a new vertex and sets it as a common vertex for the fixed edges. At that point, edges are copied, hence the wire topology is changed (regardless of the <em>ModifyTopologyMode</em> flag). If the vertices do not coincide, this method fails.</p>
<h4>Fixing the consistency of edge curves</h4>
<p><em>FixEdgeCurves</em> method performs a set of fixes dealing with 3D curves and 2D curves of edges in a wire.</p>
<p>These fixes will be activated with the help of a set of fixes from the repairing tool for edges called <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html">ShapeFix_Edge</a></em>. Each of these fixes can be forced or forbidden by means of setting the corresponding flag to either True or False.</p>
<p>The mentioned fixes and the conditions of their execution are:</p><ul>
<li>fixing a disoriented 2D curve by call to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#a6135512badb514e8d66c60c8e5776a1f">ShapeFix_Edge::FixReversed2d</a></em> &ndash; if not forbidden by flag <em>FixReversed2dMode</em>;</li>
<li>removing a wrong 2D curve by call to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#a533aba2e287e297cfbddf7c6d310a041">ShapeFix_Edge::FixRemovePCurve</a></em> &ndash; only if forced by flag <em>FixRemovePCurveMode</em>;</li>
<li>fixing a missing 2D curve by call to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#aec468070ba675fec07b605ccf1d85098">ShapeFix_Edge::FixAddPCurve</a></em> &ndash; if not forbidden by flag <em>FixAddPCurveMode</em>;</li>
<li>removing a wrong 3D curve by call to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#a2531a5f3a9ad11ef69abb33f8e6553a0">ShapeFix_Edge::FixRemoveCurve3d</a></em> &ndash; only if forced by flag <em>FixRemoveCurve3dMode</em>;</li>
<li>fixing a missing 3D curve by call to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#a81128b9b73c1123e44184c02d3cafd77">ShapeFix_Edge::FixAddCurve3d</a></em> &ndash; if not forbidden by flag <em>FixAddCurve3dMode</em>;</li>
<li>fixing 2D curves of seam edges &ndash; if not forbidden by flag <em>FixSeamMode</em>;</li>
<li>fixing 2D curves which can be shifted at an integer number of periods on the closed surface by call to <em>ShapeFix_Edge::FixShifted</em> &ndash; if not forbidden by flag <em>FixShiftedMode</em>.</li>
</ul>
<p>This fix is required if 2D curves of some edges in a wire lying on a closed surface were recomputed from 3D curves. In that case, the 2D curve for the edge, which goes along the seam of the surface, can be incorrectly shifted at an integer number of periods. The method <em>FixShifted</em> detects such cases and shifts wrong 2D curves back, ensuring that the 2D curves of the edges in the wire are connected.</p>
<ul>
<li>fixing the SameParameter problem by call to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html#a58a78d3cfd29423423e33d8e95919b8c">ShapeFix_Edge::FixSameParameter</a></em> &ndash; if not forbidden by flag <em>FixSameParameterMode</em>.</li>
</ul>
<h4>Fixing degenerated edges</h4>
<p><em>FixDegenerated</em> method checks whether an edge in a wire lies on a degenerated point of the supporting surface, or whether there is a degenerated point between the edges. If one of these cases is detected for any edge, a new degenerated edge is created and it replaces the current edge in the first case or is added to the wire in the second case. The newly created degenerated edge has a straight 2D curve, which goes from the end of the 2D curve of the preceding edge to the start of the following one.</p>
<h4>Fixing intersections of 2D curves of the edges</h4>
<p><em>FixSelfIntersection</em> method detects and fixes the following problems:</p><ul>
<li>self-intersection of 2D curves of individual edges. If the flag <em>ModifyGeometryMode()</em> is False this fix will be performed by increasing the tolerance of one of end vertices to a value less then <em>MaxTolerance()</em>.</li>
<li>intersection of 2D curves of each of the two adjacent edges (except the first and the last edges if the flag ClosedWireMode is False). If such intersection is found, the common vertex is modified in order to comprise the intersection point. If the flag <em>ModifyTopologyMode</em> is False this fix will be performed by increasing the tolerance of the vertex to a value less then <em>MaxTolerance()</em>.</li>
<li>intersection of 2D curves of non-adjacent edges. If such intersection is found the tolerance of the nearest vertex is increased to comprise the intersection point. If such increase cannot be done with a tolerance less than <em>MaxTolerance</em> this fix will not be performed.</li>
</ul>
<h4>Fixing a lacking edge</h4>
<p><em>FixLacking</em> method checks whether a wire is not closed in the parametric space of the surface (while it can be closed in 3D). This is done by checking whether the gap between 2D curves of each of the two adjacent edges in the wire is smaller than the tolerance of the corresponding vertex. The algorithm computes the gap between the edges, analyses positional relationship of the ends of these edges and (if possible) tries to insert a new edge into the gap or increases the tolerance.</p>
<h4>Fixing gaps in 2D and 3D wire by geometrical filling</h4>
<p>The following methods check gaps between the ends of 2D or 3D curves of adjacent edges:</p><ul>
<li>Method <em>FixGap2d</em> moves the ends of 2D curves to the middle point.</li>
<li>Method <em>FixGaps3d</em> moves the ends of 3D curves to a common vertex.</li>
</ul>
<p>Boolean flag <em>FixGapsByRanges</em> is used to activate an additional mode applied before converting to B-Splines. When this mode is on, methods try to find the most precise intersection of curves, or the most precise projection of a target point, or an extremity point between two curves (to modify their parametric range accordingly). This mode is off by default. Independently of the additional mode described above, if gaps remain, these methods convert curves to B-Spline form and shift their ends if a gap is detected.</p>
<h4>Example: A custom set of fixes</h4>
<p>Let us create a custom set of fixes as an example. </p><div class="fragment"><div class="line">TopoDS_Face face = ...; </div><div class="line">TopoDS_Wire wire = ...; </div><div class="line">Standard_Real precision = 1e-04; </div><div class="line">ShapeFix_Wire sfw (wire, face, precision); </div><div class="line">//Creates a tool and loads objects into it </div><div class="line">sfw.FixReorder(); </div><div class="line">//Orders edges in the wire so that each edge starts at the end of the one before it. </div><div class="line">sfw.FixConnected(); </div><div class="line">//Forces all adjacent edges to share </div><div class="line">//the same vertex </div><div class="line">Standard_Boolean LockVertex = Standard_True; </div><div class="line">    if (sfw.FixSmall (LockVertex, precision)) { </div><div class="line">    //Removes all edges which are shorter than the given precision and have the same vertex at both ends. </div><div class="line">} </div><div class="line">    if (sfw.FixSelfIntersection()) { </div><div class="line">    //Fixes self-intersecting edges and intersecting adjacent edges. </div><div class="line">    cout &lt;&lt;&quot;Wire was slightly self-intersecting. Repaired&quot;&lt;&lt;endl; </div><div class="line">} </div><div class="line">    if ( sfw.FixLacking ( Standard_False ) ) { </div><div class="line">    //Inserts edges to connect adjacent non-continuous edges. </div><div class="line">} </div><div class="line">TopoDS_Wire newwire = sfw.Wire(); </div><div class="line">//Returns the corrected wire </div></div><!-- fragment --><h4>Example: Correction of a wire</h4>
<p>Let us correct the following wire:</p>
<div class="image">
<img src="shape_healing_image013.png" alt="shape_healing_image013.png"/>
<div class="caption">
Initial shape</div></div>
<p>It is necessary to apply the <a class="el" href="occt_user_guides__shape_healing.html#occt_shg_3_1_2">tools for the analysis of wire validity</a> to check that:</p><ul>
<li>the edges are correctly oriented;</li>
<li>there are no edges that are too short;</li>
<li>there are no intersecting adjacent edges; and then immediately apply fixing tools.</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Face face = ...;</div><div class="line">TopoDS_Wire wire = ...;</div><div class="line">Standard_Real precision = 1e-04;</div><div class="line">ShapeAnalysis_Wire saw (wire, face, precision);</div><div class="line">ShapeFix_Wire sfw (wire, face, precision);</div><div class="line">if (saw.CheckOrder()) {</div><div class="line">  cout&lt;&lt;â€œSome edges in the wire need to be reorderedâ€&lt;&lt;endl;</div><div class="line">  // Two edges are incorrectly oriented</div><div class="line">  sfw.FixReorder();</div><div class="line">  cout&lt;&lt;â€œReordering is doneâ€&lt;&lt;endl;</div><div class="line">}</div><div class="line">// their orientation is corrected</div><div class="line">if (saw.CheckSmall (precision)) {</div><div class="line">  cout&lt;&lt;â€œWire contains edge(s) shorter than â€œ&lt;&lt;precision&lt;&lt;endl;</div><div class="line">  // An edge that is shorter than the given tolerance is found.</div><div class="line">  Standard_Boolean LockVertex = Standard_True;</div><div class="line">  if (sfw.FixSmall (LockVertex, precision)) {</div><div class="line">    cout&lt;&lt;â€œEdges shorter than â€œ&lt;&lt;precision&lt;&lt;â€œ have been removedâ€</div><div class="line">&lt;&lt;endl;</div><div class="line">    //The edge is removed</div><div class="line">  }</div><div class="line">}</div><div class="line">if (saw.CheckSelfIntersection()) {</div><div class="line">  cout&lt;&lt;â€œWire has self-intersecting or intersecting</div><div class="line">adjacent edgesâ€&lt;&lt;endl;</div><div class="line">  // Two intersecting adjacent edges are found.</div><div class="line">  if (sfw.FixSelfIntersection()) {</div><div class="line">    cout&lt;&lt;â€œWire was slightly self-intersecting. Repairedâ€&lt;&lt;endl;</div><div class="line">    // The edges are cut at the intersection point so that they no longer intersect.</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>As the result all failures have been fixed.</p>
<div class="image">
<img src="shape_healing_image014.png" alt="shape_healing_image014.png"/>
<div class="caption">
Resulting shape</div></div>
<h3><a class="anchor" id="occt_shg_2_3_8"></a>
Repairing tool for edges</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___edge.html">ShapeFix_Edge</a></em> provides tools for fixing invalid edges. The following geometrical and/or topological inconsistencies are detected and fixed:</p><ul>
<li>missing 3D curve or 2D curve,</li>
<li>mismatching orientation of a 3D curve and a 2D curve,</li>
<li>incorrect SameParameter flag (curve deviation is greater than the edge tolerance). Each fixing method first checks whether the problem exists using methods of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___edge.html">ShapeAnalysis_Edge</a></em> class. If the problem is not detected, nothing is done. This tool does not have the method <em>Perform()</em>.</li>
</ul>
<p>To see how this tool works, it is possible to take an edge, where the maximum deviation between the 3D curve and 2D curve P1 is greater than the edge tolerance.</p>
<div class="image">
<img src="shape_healing_image011.png" alt="shape_healing_image011.png"/>
<div class="caption">
Initial shape</div></div>
<p>First it is necessary to apply the <a class="el" href="occt_user_guides__shape_healing.html#occt_shg_3_1_3">tool for checking the edge validity</a> to find that the maximum deviation between pcurve and 3D curve is greater than tolerance. Then we can use the repairing tool to increase the tolerance and make the deviation acceptable.</p>
<div class="fragment"><div class="line">ShapeAnalysis_Edge sae;</div><div class="line">TopoDS_Face face = ...; </div><div class="line">TopoDS_Wire wire = ...; </div><div class="line">Standard_Real precision = 1e-04; </div><div class="line">ShapeFix_Edge sfe;</div><div class="line">Standard_Real maxdev;</div><div class="line">if (sae.CheckSameParameter (edge, maxdev)) {</div><div class="line">  cout&lt;&lt;â€œIncorrect SameParameter flagâ€&lt;&lt;endl;</div><div class="line">  cout&lt;&lt;â€œMaximum deviation â€œ&lt;&lt;maxdev&lt;&lt; â€œ, tolerance â€œ</div><div class="line">&lt;&lt;BRep_Tool::Tolerance(edge)&lt;&lt;endl;</div><div class="line">  sfe.FixSameParameter();</div><div class="line">  cout&lt;&lt;â€œNew tolerance â€œ&lt;&lt;BRep_Tool::Tolerance(edge)&lt;&lt;endl;</div><div class="line">}</div></div><!-- fragment --><div class="image">
<img src="shape_healing_image012.png" alt="shape_healing_image012.png"/>
<div class="caption">
Resulting shape</div></div>
<p>As the result, the edge tolerance has been increased.</p>
<h3><a class="anchor" id="occt_shg_2_3_9"></a>
Repairing tool for the wireframe of a shape</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix___wireframe.html">ShapeFix_Wireframe</a></em> provides methods for geometrical fixing of gaps and merging small edges in a shape. This class performs the following operations:</p><ul>
<li>fills gaps in the 2D and 3D wireframe of a shape.</li>
<li>merges and removes small edges.</li>
</ul>
<p>Fixing of small edges can be managed with the help of two flags:</p><ul>
<li><em>ModeDropSmallEdges()</em> &ndash; mode for removing small edges that can not be merged, by default it is equal to Standard_False.</li>
<li><em>LimitAngle</em> &ndash; maximum possible angle for merging two adjacent edges, by default no limit angle is applied (-1). To perform fixes it is necessary to:</li>
<li>create a tool and initialize it by shape,</li>
<li>set the working precision problems will be detected with and the maximum allowed tolerance</li>
<li>perform fixes</li>
</ul>
<div class="fragment"><div class="line">//creation of a tool </div><div class="line">Handle(ShapeFix_Wireframe) sfwf = new ShapeFix_Wireframe(shape); </div><div class="line">//sets the working precision problems will be detected with and the maximum allowed tolerance </div><div class="line">sfwf-&gt;SetPrecision(prec); </div><div class="line">sfwf-&gt;SetMaxTolerance(maxTol); </div><div class="line">//fixing of gaps </div><div class="line">sfwf-&gt;FixWireGaps(); </div><div class="line">//fixing of small edges </div><div class="line">//setting of the drop mode for the fixing of small edges and max possible angle between merged edges. </div><div class="line">sfwf-&gt;ModeDropSmallEdges = Standard_True; </div><div class="line">sfwf-&gt;SetLimliteAngle(angle); </div><div class="line">//performing the fix </div><div class="line">sfwf-&gt;FixSmallEdges(); </div><div class="line">//getting the result </div><div class="line">TopoDS_Shape resShape = sfwf-&gt;Shape(); </div></div><!-- fragment --><p>It is desirable that a shape is topologically correct before applying the methods of this class.</p>
<h3><a class="anchor" id="occt_shg_2_3_10"></a>
Tool for removing small faces from a shape</h3>
<p>Class ShapeFix_FixSmallFaceThis tool is intended for dropping small faces from the shape. The following cases are processed:</p><ul>
<li>Spot face: if the size of the face is less than the given precision;</li>
<li>Strip face: if the size of the face in one dimension is less then the given precision.</li>
</ul>
<p>The sequence of actions for performing the fix is the same as for the fixes described above:</p>
<div class="fragment"><div class="line">//creation of a tool </div><div class="line">Handle(ShapeFix_FixSmallFace) sff = new ShapeFix_FixSmallFace(shape); </div><div class="line">//setting of tolerances </div><div class="line">sff-&gt;SetPrecision(prec); </div><div class="line">sff-&gt;SetMaxTolerance(maxTol); </div><div class="line">//performing fixes </div><div class="line">sff.Perform(); </div><div class="line">//getting the result </div><div class="line">TopoDS_Shape resShape = sff.FixShape(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_2_3_11"></a>
Tool to modify  tolerances of shapes (Class ShapeFix_ShapeTolerance).</h3>
<p>This tool provides a functionality to set tolerances of a shape and its sub-shapes. In Open CASCADE Technology only vertices, edges and faces have tolerances.</p>
<p>This tool allows processing each concrete type of sub-shapes or all types at a time. You set the tolerance functionality as follows:</p><ul>
<li>set a tolerance for sub-shapes, by method SetTolerance,</li>
<li>limit tolerances with given ranges, by method LimitTolerance.</li>
</ul>
<div class="fragment"><div class="line">//creation of a tool </div><div class="line">ShapeFix_ShapeTolerance Sft; </div><div class="line">//setting a specified tolerance on shape and all of its sub-shapes. </div><div class="line">Sft.SetTolerance(shape,toler); </div><div class="line">//setting a specified tolerance for vertices only </div><div class="line">Sft.SetTolerance(shape,toler,TopAbs_VERTEX); </div><div class="line">//limiting the tolerance on the shape and its sub-shapes between minimum and maximum tolerances </div><div class="line">Sft.LimitTolerance(shape,tolermin,tolermax); </div></div><!-- fragment --><h1><a class="anchor" id="occt_shg_3"></a>
Analysis</h1>
<h2><a class="anchor" id="occt_shg_3_1"></a>
Analysis of shape validity</h2>
<p>The <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis.html">ShapeAnalysis</a></em> package provides tools for the analysis of topological shapes. It is not necessary to check a shape by these tools before the execution of repairing tools because these tools are used for the analysis before performing fixes inside the repairing tools. However, if you want, these tools can be used for detecting some of shape problems independently from the repairing tools.</p>
<p>It can be done in the following way:</p><ul>
<li>create an analysis tool.</li>
<li>initialize it by shape and set a tolerance problems will be detected with if it is necessary.</li>
<li>check the problem that interests you.</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Face face = ...; </div><div class="line">ShapeAnalysis_Edge sae; </div><div class="line">//Creates a tool for analyzing an edge </div><div class="line">for(TopExp_Explorer Exp(face,TopAbs_EDGE);Exp.More();Exp.Next()) { </div><div class="line">  TopoDS_Edge edge = TopoDS::Edge (Exp.Current()); </div><div class="line">  if (!sae.HasCurve3d (edge)) { </div><div class="line">    cout  &lt;&lt;&quot;Edge has no 3D curve&quot;&lt;&lt;  endl;  } </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_1_1"></a>
Analysis of orientation of wires on a face.</h3>
<p>It is possible to check whether a face has an outer boundary with the help of method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis.html#ae7e81a18ceaa7becb86fb9a2ddfff439">ShapeAnalysis::IsOuterBound</a></em>.</p>
<div class="fragment"><div class="line">TopoDS_Face face â€¦ //analyzed face </div><div class="line">if(!ShapeAnalysis::IsOuterBound(face)) { </div><div class="line">cout&lt;&lt;&quot;Face has not outer boundary&quot;&lt;&lt;endl; </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_1_2"></a>
Analysis of wire validity</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___wire.html">ShapeAnalysis_Wire</a></em> is intended to analyze a wire. It provides functionalities both to explore wire properties and to check its conformance to Open CASCADE Technology requirements. These functionalities include:</p><ul>
<li>checking the order of edges in the wire,</li>
<li>checking for the presence of small edges (with a length less than the given value),</li>
<li>checking for the presence of disconnected edges (adjacent edges having different vertices),</li>
<li>checking the consistency of edge curves,</li>
<li>checking for the presence or missing of degenerated edges,</li>
<li>checking for the presence of self-intersecting edges and intersecting edges (edges intersection is understood as intersection of their 2D curves),</li>
<li>checking for lacking edges to fill gaps in the surface parametric space,</li>
<li>analyzing the wire orientation (to define the outer or the inner bound on the face),</li>
<li>analyzing the orientation of the shape (edge or wire) being added to an already existing wire.</li>
</ul>
<p><b>Note</b> that all checking operations except for the first one are based on the assumption that edges in the wire are ordered. Thus, if the wire is detected as non-ordered it is necessary to order it before calling other checking operations. This can be done, for example, with the help of the <em>ShapeFix_Wire::FixOrder()</em> method.</p>
<p>This tool should be initialized with wire, face (or a surface with a location) or precision. Once the tool has been initialized, it is possible to perform the necessary checking operations. In order to obtain all information on a wire at a time the global method <em>Perform</em> is provided. It calls all other API checking operations to check each separate case.</p>
<p>API methods check for corresponding cases only, the value and the status they return can be analyzed to understand whether the case was detected or not.</p>
<p>Some methods in this class are:</p><ul>
<li><em>CheckOrder</em> checks whether edges in the wire are in the right order</li>
<li><em>CheckConnected</em> checks whether edges are disconnected</li>
<li><em>CheckSmall</em> checks whether there are edges that are shorter than the given value</li>
<li><em>CheckSelfIntersection</em> checks, whether there are self-intersecting or adjacent intersecting edges. If the intersection takes place due to nonadjacent edges, it is not detected.</li>
</ul>
<p>This class maintains status management. Each API method stores the status of its last execution which can be queried by the corresponding <em>Status..()</em> method. In addition, each API method returns a Boolean value, which is True when a case being analyzed is detected (with the set <em>ShapeExtend_DONE</em> status), otherwise it is False.</p>
<div class="fragment"><div class="line">TopoDS_Face face = ...; </div><div class="line">TopoDS_Wire wire = ...; </div><div class="line">Standard_Real precision = 1e-04; </div><div class="line">ShapeAnalysis_Wire saw (wire, face, precision); </div><div class="line">//Creates a tool and loads objects into it </div><div class="line">if (saw.CheckOrder()) { </div><div class="line">  cout&lt;&lt;&quot;Some edges in the wire need to be reordered&quot;&lt;&lt;endl; </div><div class="line">  cout&lt;&lt;&quot;Please ensure that all the edges are correctly ordered before further analysis&quot;&lt;&lt;endl; </div><div class="line">  return; </div><div class="line">} </div><div class="line">if (saw.CheckSmall (precision)) { </div><div class="line">  cout&lt;&lt;&quot;Wire contains edge(s) shorter than &quot;&lt;&lt;precisionendl; </div><div class="line">} </div><div class="line">if (saw.CheckConnected()) { </div><div class="line">  cout&lt;&lt;&quot;Wire is disconnected&quot;&lt;&lt;endl; </div><div class="line">} </div><div class="line">if (saw.CheckSelfIntersection()) { </div><div class="line">  cout&lt;&lt;&quot;Wire has self-intersecting or intersecting adjacent edges&quot;&lt;&lt;  endl; </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_1_3"></a>
Analysis of edge validity</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___edge.html">ShapeAnalysis_Edge</a></em> is intended to analyze edges. It provides the following functionalities to work with an edge:</p><ul>
<li>querying geometrical representations (3D curve and pcurve(s) on a given face or surface),</li>
<li>querying topological sub-shapes (bounding vertices),</li>
<li>checking overlapping edges,</li>
<li>analyzing the curves consistency:<ul>
<li>mutual orientation of the 3D curve and 2D curve (co-directions or opposite directions),</li>
<li>correspondence of 3D and 2D curves to vertices.</li>
</ul>
</li>
</ul>
<p>This class supports status management described above.</p>
<div class="fragment"><div class="line">TopoDS_Face face = ...; </div><div class="line">ShapeAnalysis_Edge sae; </div><div class="line">//Creates a tool for analyzing an edge </div><div class="line">for(TopExp_Explorer Exp(face,TopAbs_EDGE);Exp.More();Exp.Next()) { </div><div class="line">  TopoDS_Edge edge = TopoDS::Edge (Exp.Current()); </div><div class="line">  if (!sae.HasCurve3d (edge)) { </div><div class="line">    cout &lt;&lt; &quot;Edge has no 3D curve&quot; &lt;&lt;  endl; </div><div class="line">  } </div><div class="line">  Handle(Geom2d_Curve) pcurve; </div><div class="line">  Standard_Real cf, cl; </div><div class="line">  if (sae.PCurve (edge, face, pcurve, cf, cl, Standard_False)) { </div><div class="line">    //Returns the pcurve and its range on the given face </div><div class="line">    cout&lt;&lt;&quot;Pcurve range [&quot;&lt;&lt;cf&lt;&lt;&quot;, &quot;&lt;&lt;cl&lt;&lt;&quot;]&quot;&lt;&lt; endl; </div><div class="line">  } </div><div class="line">  Standard_Real maxdev; </div><div class="line">  if (sae.CheckSameParameter (edge, maxdev)) { </div><div class="line">    //Checks the consistency of all the curves in the edge </div><div class="line">    cout&lt;&lt;&quot;Incorrect SameParameter flag&quot;&lt;&lt;endl; </div><div class="line">  } </div><div class="line">  cout&lt;&lt;&quot;Maximum deviation &quot;&lt;&lt;maxdev&lt;&lt;&quot;, tolerance&quot; </div><div class="line">             &lt;&lt;BRep_Tool::Tolerance(edge)&lt;&lt;endl; </div><div class="line">} </div><div class="line">//checks the overlapping of two edges </div><div class="line">if(sae.CheckOverlapping(edge1,edge2,prec,dist)) { </div><div class="line">     cout&lt;&lt;&quot;Edges are overlapped with tolerance = &quot;&lt;&lt;prec&lt;&lt;endl; </div><div class="line">     cout&lt;&lt;&quot;Domain of overlapping =&quot;&lt;&lt;dist&lt;&lt;endl; </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_1_4"></a>
Analysis of presence of small faces</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___check_small_face.html">ShapeAnalysis_CheckSmallFace</a></em> class is intended for analyzing small faces from the shape using the following methods:</p><ul>
<li><em>CheckSpotFace()</em> checks if the size of the face is less than the given precision;</li>
<li><em>CheckStripFace</em> checks if the size of the face in one dimension is less than the given precision.</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Shape shape â€¦ // checked shape </div><div class="line">//Creation of a tool </div><div class="line">ShapeAnalysis_CheckSmallFace saf; </div><div class="line">//exploring the shape on faces and checking each face </div><div class="line">Standard_Integer numSmallfaces =0; </div><div class="line">for(TopExp_Explorer aExp(shape,TopAbs_FACE); aExp.More(); aExp.Next()) { </div><div class="line"> TopoDS_Face face = TopoDS::Face(aexp.Current()); </div><div class="line"> TopoDS_Edge E1,E2; </div><div class="line">if(saf.CheckSpotFace(face,prec) || </div><div class="line">saf.CheckStripFace(face,E1,E2,prec)) </div><div class="line">NumSmallfaces++; </div><div class="line">} </div><div class="line">if(numSmallfaces) </div><div class="line"> cout&lt;&lt;&quot;Number of small faces in the shape =&quot;&lt;&lt; numSmallfaces &lt;&lt;endl; </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_1_5"></a>
Analysis of shell validity and closure</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___shell.html">ShapeAnalysis_Shell</a></em> allows checking the orientation of edges in a manifold shell. With the help of this tool, free edges (edges entered into one face) and bad edges (edges entered into the shell twice with the same orientation) can be found. By occurrence of bad and free edges a conclusion about the shell validity and the closure of the shell can be made.</p>
<div class="fragment"><div class="line">TopoDS_Shell shell // checked shape </div><div class="line">ShapeAnalysis_Shell sas(shell); </div><div class="line">//analysis of the shell , second parameter is set to True for //getting free edges,(default False) </div><div class="line">sas.CheckOrientedShells(shell,Standard_True); </div><div class="line">//getting the result of analysis </div><div class="line">if(sas.HasBadEdges()) { </div><div class="line">cout&lt;&lt;&quot;Shell is invalid&quot;&lt;&lt;endl; </div><div class="line">TopoDS_Compound badEdges = sas.BadEdges(); </div><div class="line">} </div><div class="line">if(sas.HasFreeEdges()) { </div><div class="line"> cout&lt;&lt;&quot;Shell is open&quot;&lt;&lt;endl; </div><div class="line"> TopoDS_Compound freeEdges = sas.FreeEdges(); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_3_2"></a>
Analysis of shape properties.</h2>
<h3><a class="anchor" id="occt_shg_3_2_1"></a>
Analysis of tolerance on shape</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___shape_tolerance.html">ShapeAnalysis_ShapeTolerance</a></em> allows computing tolerances of the shape and its sub-shapes. In Open CASCADE Technology only vertices, edges and faces have tolerances:</p>
<p>This tool allows analyzing each concrete type of sub-shapes or all types at a time. The analysis of tolerance functionality is the following:</p><ul>
<li>computing the minimum, maximum and average tolerances of sub-shapes,</li>
<li>finding sub-shapes with tolerances exceeding the given value,</li>
<li>finding sub-shapes with tolerances in the given range.</li>
</ul>
<div class="fragment"><div class="line">TopoDS_Shape shape = ...; </div><div class="line">ShapeAnalysis_ShapeTolerance sast; </div><div class="line">Standard_Real AverageOnShape = sast.Tolerance (shape, 0); </div><div class="line">cout&lt;&lt;&quot;Average tolerance of the shape is &quot;&lt;&lt;AverageOnShape&lt;&lt;endl; </div><div class="line">Standard_Real MinOnEdge = sast.Tolerance (shape,-1,TopAbs_EDGE); </div><div class="line">cout&lt;&lt;&quot;Minimum tolerance of the edges is &quot;&lt;&lt;MinOnEdge&lt;&lt;endl; </div><div class="line">Standard_Real MaxOnVertex = sast.Tolerance (shape,1,TopAbs_VERTEX); </div><div class="line">cout&lt;&lt;&quot;Maximum tolerance of the vertices is &quot;&lt;&lt;MaxOnVertex&lt;&lt;endl; </div><div class="line">Standard_Real MaxAllowed = 0.1; </div><div class="line">if (MaxOnVertex &gt; MaxAllowed) { </div><div class="line">  cout&lt;&lt;&quot;Maximum tolerance of the vertices exceeds maximum allowed&quot;&lt;&lt;endl; </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_2_2"></a>
Analysis of free boundaries.</h3>
<p>Class <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___free_bounds.html">ShapeAnalysis_FreeBounds</a> is intended to analyze and output the free bounds of a shape. Free bounds are wires consisting of edges referenced only once by only one face in the shape. This class works on two distinct types of shapes when analyzing their free bounds:</p><ul>
<li>Analysis of possible free bounds taking the specified tolerance into account. This analysis can be applied to a compound of faces. The analyzer of the sewing algorithm (<em>BRepAlgo_Sewing</em>) is used to forecast what free bounds would be obtained after the sewing of these faces is performed. The following method should be used for this analysis: <div class="fragment"><div class="line">ShapeAnalysis_FreeBounds safb(shape,toler); </div></div><!-- fragment --></li>
<li>Analysis of already existing free bounds. Actual free bounds (edges shared by the only face in the shell) are output in this case. <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___shell.html">ShapeAnalysis_Shell</a></em> is used for that. <div class="fragment"><div class="line">ShapeAnalysis_FreeBounds safb(shape); </div></div><!-- fragment --></li>
</ul>
<p>When connecting edges into wires this algorithm tries to build wires of maximum length. Two options are provided for the user to extract closed sub-contours out of closed and/or open contours. Free bounds are returned as two compounds, one for closed and one for open wires. To obtain a result it is necessary to use methods: </p><div class="fragment"><div class="line">TopoDS_Compound ClosedWires  = safb.GetClosedWires(); </div><div class="line">TopoDS_Compound OpenWires = safb.GetOpenWires(); </div></div><!-- fragment --><p> This class also provides some static methods for advanced use: connecting edges/wires to wires, extracting closed sub-wires from wires, distributing wires into compounds for closed and open wires.</p>
<div class="fragment"><div class="line">TopoDS_Shape shape = ...; </div><div class="line">Standard_Real SewTolerance = 1.e-03; </div><div class="line">//Tolerance for sewing </div><div class="line">Standard_Boolean SplitClosed = Standard_False; </div><div class="line">Standard_Boolean SplitOpen = Standard_True; </div><div class="line">//in case of analysis of possible free boundaries </div><div class="line">ShapeAnalysis_FreeBounds safb (shape, SewTolerance, </div><div class="line">SplitClosed, SplitOpen); </div><div class="line">//in case of analysis of existing free bounds </div><div class="line">ShapeAnalysis_FreeBounds safb (shape, SplitClosed, SplitOpen); </div><div class="line">//getting the results </div><div class="line">TopoDS_Compound ClosedWires = safb.GetClosedWires(); </div><div class="line">//Returns a compound of closed free bounds </div><div class="line">TopoDS_Compound OpenWires = safb.GetClosedWires(); </div><div class="line">//Returns a compound of open free bounds </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_3_2_3"></a>
Analysis of shape contents</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis___shape_contents.html">ShapeAnalysis_ShapeContents</a></em> provides tools counting the number of sub-shapes and selecting a sub-shape by the following criteria:</p>
<p>Methods for getting the number of sub-shapes:</p><ul>
<li>number of solids,</li>
<li>number of shells,</li>
<li>number of faces,</li>
<li>number of edges,</li>
<li>number of vertices.</li>
</ul>
<p>Methods for calculating the number of geometrical objects or sub-shapes with a specified type:</p><ul>
<li>number of free faces,</li>
<li>number of free wires,</li>
<li>number of free edges,</li>
<li>number of C0 surfaces,</li>
<li>number of C0 curves,</li>
<li>number of BSpline surfaces,â€¦ etc</li>
</ul>
<p>and selecting sub-shapes by various criteria.</p>
<p>The corresponding flags should be set to True for storing a shape by a specified criteria:</p><ul>
<li>faces based on indirect surfaces &ndash; <em>safc.MofifyIndirectMode() = Standard_True</em>;</li>
<li>faces based on offset surfaces &ndash; <em>safc.ModifyOffsetSurfaceMode() = Standard_True</em>;</li>
<li>edges if their 3D curves are trimmed &ndash; <em>safc.ModifyTrimmed3dMode() = Standard_True</em>;</li>
<li>edges if their 3D curves and 2D curves are offset curves &ndash; <em>safc.ModifyOffsetCurveMode() = Standard_True</em>;</li>
<li>edges if their 2D curves are trimmed &ndash; <em>safc.ModifyTrimmed2dMode() = Standard_True</em>;</li>
</ul>
<p>Let us, for example, select faces based on offset surfaces.</p>
<div class="fragment"><div class="line">ShapeAnalysis_ShapeContents safc; </div><div class="line">//set a corresponding flag for storing faces based on the offset surfaces </div><div class="line">safc.ModifyOffsetSurfaceMode() = Standard_True; </div><div class="line">safc.Perform(shape); </div><div class="line">//getting the number of offset surfaces in the shape </div><div class="line">Standard_Integer NbOffsetSurfaces = safc.NbOffsetSurf(); </div><div class="line">//getting the sequence of faces based on offset surfaces. </div><div class="line">Handle(TopTools_HSequenceOfShape) seqFaces = safc.OffsetSurfaceSec(); </div></div><!-- fragment --><h1><a class="anchor" id="occt_shg_4"></a>
Upgrading</h1>
<p>Upgrading tools are intended for adaptation of shapes for better use by Open CASCADE Technology or for customization to particular needs, i.e. for export to another system. This means that not only it corrects and upgrades but also changes the definition of a shape with regard to its geometry, size and other aspects. Convenient API allows you to create your own tools to perform specific upgrading. Additional tools for particular cases provide an ability to divide shapes and surfaces according to certain criteria.</p>
<h2><a class="anchor" id="occt_shg_4_1"></a>
Tools for splitting a shape according to a specified criterion</h2>
<h3><a class="anchor" id="occt_shg_4_1_1"></a>
Overview</h3>
<p>These tools provide such modifications when one topological object can be divided or converted to several ones according to specified criteria. Besides, there are high level API tools for particular cases which:</p><ul>
<li>Convert the geometry of shapes up to a given continuity,</li>
<li>split revolutions by U to segments less than the given value,</li>
<li>convert to Bezier surfaces and Bezier curves,</li>
<li>split closed faces,</li>
<li>convert C0 BSpline curve to a sequence of C1 BSpline curves.</li>
</ul>
<p>All tools for particular cases are based on general tools for shape splitting but each of them has its own tools for splitting or converting geometry in accordance with the specified criteria.</p>
<p>General tools for shape splitting are:</p><ul>
<li>tool for splitting the whole shape,</li>
<li>tool for splitting a face,</li>
<li>tool for splitting wires.</li>
</ul>
<p>Tools for shape splitting use tools for geometry splitting:</p><ul>
<li>tool for splitting surfaces,</li>
<li>tool for splitting 3D curves,</li>
<li>tool for splitting 2D curves.</li>
</ul>
<h3><a class="anchor" id="occt_shg_4_1_2"></a>
Using tools available for shape splitting.</h3>
<p>If it is necessary to split a shape by a specified continuity, split closed faces in the shape, split surfaces of revolution in the shape by angle or to convert all surfaces, all 3D curves, all 2D curves in the shape to Bezier, it is possible to use the existing/available tools.</p>
<p>The usual way to use these tools exception for the tool of converting a C0 BSpline curve is the following:</p><ul>
<li>a tool is created and initialized by shape.</li>
<li>work precision for splitting and the maximum allowed tolerance are set</li>
<li>the value of splitting criterion Is set (if necessary)</li>
<li>splitting is performed.</li>
<li>splitting statuses are obtained.</li>
<li>result is obtained</li>
<li>the history of modification of the initial shape and its sub-shapes is output (this step is optional).</li>
</ul>
<p>Let us, for example, split all surfaces and all 3D and 2D curves having a continuity of less the C2.</p>
<div class="fragment"><div class="line">//create a tool and initializes it by shape. </div><div class="line">ShapeUpgrade_ShapeDivideContinuity ShapeDivedeCont(initShape); </div><div class="line"></div><div class="line">//set the working 3D and 2D precision and the maximum allowed //tolerance </div><div class="line">ShapeDivideCont.SetTolerance(prec); </div><div class="line">ShapeDivideCont.SetTolerance2D(prec2d); </div><div class="line">ShapeDivideCont.SetMaxTolerance(maxTol); </div><div class="line"></div><div class="line">//set the values of criteria for surfaces, 3D curves and 2D curves. </div><div class="line">ShapeDivideCont.SetBoundaryCriterion(GeomAbs_C2); </div><div class="line">ShapeDivideCont.SetPCurveCriterion(GeomAbs_C2); </div><div class="line">ShapeDivideCont.SetSurfaceCriterion(GeomAbs_C2); </div><div class="line"></div><div class="line">//perform the splitting. </div><div class="line">ShapeDivideCont.Perform(); </div><div class="line"></div><div class="line">//check the status and gets the result </div><div class="line">if(ShapeDivideCont.Status(ShapeExtend_DONE) </div><div class="line"> TopoDS_Shape result = ShapeDivideCont.GetResult(); </div><div class="line">//get the history of modifications made to faces </div><div class="line">for(TopExp_Explorer aExp(initShape,TopAbs_FACE); aExp.More(0; aExp.Next()) { </div><div class="line">  TopoDS_Shape modifShape = ShapeDivideCont.GetContext()-&gt; Apply(aExp.Current()); </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_1_3"></a>
Creation of a new tool for splitting a shape.</h3>
<p>To create a new splitting tool it is necessary to create tools for geometry splitting according to a desirable criterion. The new tools should be inherited from basic tools for geometry splitting. Then the new tools should be set into corresponding tools for shape splitting.</p><ul>
<li>a new tool for surface splitting should be set into the tool for face splitting</li>
<li>new tools for splitting of 3D and 2D curves should be set into the splitting tool for wires.</li>
</ul>
<p>To change the value of criterion of shape splitting it is necessary to create a new tool for shape splitting that should be inherited from the general splitting tool for shapes.</p>
<p>Let us split a shape according to a specified criterion.</p>
<div class="fragment"><div class="line">//creation of new tools for geometry splitting by a specified criterion. </div><div class="line">Handle(MyTools_SplitSurfaceTool) MySplitSurfaceTool = new MyTools_SplitSurfaceTool; </div><div class="line">Handle(MyTools_SplitCurve3DTool) MySplitCurve3Dtool = new MyTools_SplitCurve3DTool; </div><div class="line">Handle(MyTools_SplitCurve2DTool) MySplitCurve2Dtool = new MyTools_SplitCurve2DTool; </div><div class="line"></div><div class="line">//creation of a tool for splitting the shape and initialization of that tool by shape. </div><div class="line">TopoDS_Shape initShape </div><div class="line">MyTools_ShapeDivideTool ShapeDivide (initShape); </div><div class="line"></div><div class="line">//setting of work precision for splitting and maximum allowed tolerance. </div><div class="line">ShapeDivide.SetPrecision(prec); </div><div class="line">ShapeDivide.SetMaxTolerance(MaxTol); </div><div class="line"></div><div class="line">//setting of new splitting geometry tools in the shape splitting tools </div><div class="line">Handle(ShapeUpgrade_FaceDivide) FaceDivide = ShapeDivide-&gt;GetSplitFaceTool(); </div><div class="line">Handle(ShapeUpgrade_WireDivide) WireDivide = FaceDivide-&gt;GetWireDivideTool(); </div><div class="line">FaceDivide-&gt;SetSplitSurfaceTool(MySplitSurfaceTool); </div><div class="line">WireDivide-&gt;SetSplitCurve3dTool(MySplitCurve3DTool); </div><div class="line">WireDivide-&gt;SetSplitCurve2dTool(MySplitCurve2DTool); </div><div class="line"></div><div class="line">//setting of the value criterion. </div><div class="line"> ShapeDivide.SetValCriterion(val); </div><div class="line"></div><div class="line">//shape splitting </div><div class="line">ShapeDivide.Perform(); </div><div class="line"></div><div class="line">//getting the result </div><div class="line">TopoDS_Shape splitShape = ShapeDivide.GetResult(); </div><div class="line"></div><div class="line">//getting the history of modifications of faces </div><div class="line">for(TopExp_Explorer aExp(initShape,TopAbs_FACE); aExp.More(0; aExp.Next()) { </div><div class="line">TopoDS_Shape modifShape = ShapeDivide.GetContext()-&gt; Apply(aExp.Current()); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_4_2"></a>
General splitting tools.</h2>
<h3><a class="anchor" id="occt_shg_4_2_1"></a>
General tool for shape splitting</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide.html">ShapeUpgrade_ShapeDivide</a></em> provides shape splitting and converting according to the given criteria. It performs these operations for each face with the given tool for face splitting (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___face_divide.html">ShapeUpgrade_FaceDivide</a></em> by default).</p>
<p>This tool provides access to the tool for dividing faces with the help of the methods <em>SetSplitFaceTool</em> and <em>GetSpliFaceTool.</em></p>
<h3><a class="anchor" id="occt_shg_4_2_2"></a>
General tool for face splitting</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___face_divide.html">ShapeUpgrade_FaceDivide</a></em> divides a Face (edges in the wires, by splitting 3D and 2D curves, as well as the face itself, by splitting the supporting surface) according to the given criteria.</p>
<p>The area of the face intended for division is defined by 2D curves of the wires on the Face. All 2D curves are supposed to be defined (in the parametric space of the supporting surface). The result is available after the call to the <em>Perform</em> method. It is a Shell containing all resulting Faces. All modifications made during the splitting operation are recorded in the external context (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em>).</p>
<p>This tool provides access to the tool for wire division and surface splitting by means of the following methods:</p><ul>
<li><em>SetWireDivideTool,</em></li>
<li><em>GetWireDivideTool,</em></li>
<li><em>SetSurfaceSplitTool,</em></li>
<li><em>GetSurfaceSplitTool</em>.</li>
</ul>
<h3><a class="anchor" id="occt_shg_4_2_3"></a>
General tool for wire splitting</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___wire_divide.html">ShapeUpgrade_WireDivide</a></em> divides edges in the wire lying on the face or free wires or free edges with a given criterion. It splits the 3D curve and 2D curve(s) of the edge on the face. Other 2D curves, which may be associated with the edge, are simply copied. If the 3D curve is split then the 2D curve on the face is split as well, and vice-versa. The original shape is not modified. Modifications made are recorded in the context (<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em>).</p>
<p>This tool provides access to the tool for dividing and splitting 3D and 2D curves by means of the following methods:</p><ul>
<li><em>SetEdgeDivdeTool,</em></li>
<li><em>GetEdgeDivideTool,</em></li>
<li><em>SetSplitCurve3dTool,</em></li>
<li><em>GetSplitCurve3dTool,</em></li>
<li><em>SetSplitCurve2dTool,</em></li>
<li><em>GetSplitCurve2dTool</em></li>
</ul>
<p>and it also provides access to the mode for splitting edges by methods <em>SetEdgeMode</em> and <em>GetEdgeMode</em>.</p>
<p>This mode sets whether only free edges, only shared edges or all edges are split.</p>
<h3><a class="anchor" id="occt_shg_4_2_4"></a>
General tool for edge splitting</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___edge_divide.html">ShapeUpgrade_EdgeDivide</a></em> divides edges and their geometry according to the specified criteria. It is used in the wire-dividing tool.</p>
<p>This tool provides access to the tool for dividing and splitting 3D and 2D curves by the following methods:</p><ul>
<li><em>SetSplitCurve3dTool,</em></li>
<li><em>GetSplitCurve3dTool,</em></li>
<li><em>SetSplitCurve2dTool,</em></li>
<li><em>GetSplitCurve2dTool</em>.</li>
</ul>
<h3><a class="anchor" id="occt_shg_4_2_5"></a>
General tools for geometry splitting</h3>
<p>There are three general tools for geometry splitting.</p><ul>
<li>General tool for surface splitting.(<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___split_surface.html">ShapeUpgrade_SplitSurface</a></em>)</li>
<li>General tool for splitting 3D curves.(<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___split_curve3d.html">ShapeUpgrade_SplitCurve3d</a></em>)</li>
<li>General tool for splitting 2D curves.(<em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___split_curve2d.html">ShapeUpgrade_SplitCurve2d</a></em>)</li>
</ul>
<p>All these tools are constructed the same way: They have methods:</p><ul>
<li>for initializing by geometry (method <em>Init</em>)</li>
<li>for splitting (method <em>Perform</em>)</li>
<li>for getting the status after splitting and the results:<ul>
<li><em>Status</em> &ndash; for getting the result status;</li>
<li><em>ResSurface</em> &ndash; for splitting surfaces;</li>
<li><em>GetCurves</em> &ndash; for splitting 3D and 2D curves. During the process of splitting in the method <em>Perform</em> :</li>
</ul>
</li>
<li>splitting values in the parametric space are computed according to a specified criterion (method <em>Compute</em>)</li>
<li>splitting is made in accordance with the values computed for splitting (method <em>Build</em>).</li>
</ul>
<p>To create new tools for geometry splitting it is enough to inherit a new tool from the general tool for splitting a corresponding type of geometry and to redefine the method for computation of splitting values according to the specified criterion in them. (method <em>Compute</em>).</p>
<p>Header file for the tool for surface splitting by continuity:</p>
<div class="fragment"><div class="line">class ShapeUpgrade_SplitSurfaceContinuity : public ShapeUpgrade_SplitSurface { </div><div class="line">Standard_EXPORT ShapeUpgrade_SplitSurfaceContinuity(); </div><div class="line"></div><div class="line">//methods to set the criterion and the tolerance into the splitting tool </div><div class="line">Standard_EXPORT   void SetCriterion(const GeomAbs_Shape Criterion) ; </div><div class="line">Standard_EXPORT   void SetTolerance(const Standard_Real Tol) ; </div><div class="line"></div><div class="line">//redefinition of method Compute </div><div class="line">Standard_EXPORT virtual void Compute(const Standard_Boolean Segment) ; </div><div class="line">Standard_EXPORT ~ShapeUpgrade_SplitSurfaceContinuity(); </div><div class="line">private: </div><div class="line">GeomAbs_Shape myCriterion; </div><div class="line">Standard_Real myTolerance; </div><div class="line">Standard_Integer myCont; </div><div class="line">}; </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_4_3"></a>
Specific splitting tools.</h2>
<h3><a class="anchor" id="occt_shg_4_3_1"></a>
Conversion of shape geometry to the target continuity</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide_continuity.html">ShapeUpgrade_ShapeDivideContinuity</a></em> allows converting geometry with continuity less than the specified continuity to geometry with target continuity. If converting is not possible than geometrical object is split into several ones, which satisfy the given criteria. A topological object based on this geometry is replaced by several objects based on the new geometry.</p>
<div class="fragment"><div class="line">ShapeUpgrade_ShapeDivideContinuity sdc (shape); </div><div class="line">sdc.SetTolerance (tol3d); </div><div class="line">sdc.SetTolerance3d (tol2d); // if known, else 1.e-09 is taken </div><div class="line">sdc.SetBoundaryCriterion (GeomAbs_C2); // for Curves 3D </div><div class="line">sdc.SetPCurveCriterion (GeomAbs_C2); // for Curves 2D </div><div class="line">sdc.SetSurfaceCriterion (GeomAbs_C2); // for Surfaces </div><div class="line">sdc.Perform (); </div><div class="line">TopoDS_Shape bshape = sdc.Result(); </div><div class="line">//.. to also get the correspondances before/after </div><div class="line">Handle(ShapeBuild_ReShape) ctx = sdc.Context(); </div><div class="line">//.. on a given shape </div><div class="line">if (ctx.IsRecorded (sh)) { </div><div class="line">  TopoDS_Shape newsh = ctx-&gt;Value (sh); </div><div class="line">// if there are several results, they are recorded inside a Compound.</div><div class="line">// .. process as needed </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_3_2"></a>
Splitting by angle</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide_angle.html">ShapeUpgrade_ShapeDivideAngle</a></em> allows splitting all surfaces of revolution, cylindrical, toroidal, conical, spherical surfaces in the given shape so that each resulting segment covers not more than the defined angle (in radians).</p>
<h3><a class="anchor" id="occt_shg_4_3_3"></a>
Conversion of 2D, 3D curves and surfaces to Bezier</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_convert_to_bezier.html">ShapeUpgrade_ShapeConvertToBezier</a></em> is an API tool for performing a conversion of 3D, 2D curves to Bezier curves and surfaces to Bezier based surfaces (Bezier surface, surface of revolution based on Bezier curve, offset surface based on any of previous types).</p>
<p>This tool provides access to various flags for conversion of different types of curves and surfaces to Bezier by methods:</p><ul>
<li>For 3D curves:<ul>
<li><em>Set3dConversion,</em></li>
<li><em>Get3dConversion,</em></li>
<li><em>Set3dLineConversion,</em></li>
<li><em>Get3dLineConversion,</em></li>
<li><em>Set3dCircleConversion,</em></li>
<li><em>Get3dCircleConversion,</em></li>
<li><em>Set3dConicConversion,</em></li>
<li><em>Get3dConicConversion</em></li>
</ul>
</li>
<li>For 2D curves:<ul>
<li><em>Set2dConversion,</em></li>
<li><em>Get2dConversion</em></li>
</ul>
</li>
<li>For surfaces :<ul>
<li><em>GetSurfaceConversion,</em></li>
<li><em>SetPlaneMode,</em></li>
<li><em>GetPlaneMode,</em></li>
<li><em>SetRevolutionMode,</em></li>
<li><em>GetRevolutionMode,</em></li>
<li><em>SetExtrusionMode,</em></li>
<li><em>GetExtrusionMode,</em></li>
<li><em>SetBSplineMode,</em></li>
<li><em>GetBSplineMode,</em></li>
</ul>
</li>
</ul>
<p>Let us attempt to produce a conversion of planes to Bezier surfaces. </p><div class="fragment"><div class="line">//Creation and initialization of a tool. </div><div class="line">ShapeUpgrade_ShapeConvertToBezier SCB (Shape); </div><div class="line">//setting tolerances </div><div class="line">...</div><div class="line">//setting mode for conversion of planes </div><div class="line">SCB.SetSurfaceConversion (Standard_True); </div><div class="line">SCB.SetPlaneMode(Standard_True); </div><div class="line">SCB.Perform(); </div><div class="line">If(SCB.Status(ShapeExtend_DONE) </div><div class="line">    TopoDS_Shape result = SCB.GetResult(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_3_4"></a>
Tool for splitting closed faces</h3>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide_closed.html">ShapeUpgrade_ShapeDivideClosed</a></em> provides splitting of closed faces in the shape to a defined number of components by the U and V parameters. It topologically and (partially) geometrically processes closed faces and performs splitting with the help of class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___closed_face_divide.html">ShapeUpgrade_ClosedFaceDivide</a></em>.</p>
<div class="fragment"><div class="line">TopoDS_Shape aShape = â€¦; </div><div class="line">ShapeUpgrade_ShapeDivideClosed tool (aShape ); </div><div class="line">Standard_Real closeTol = â€¦; </div><div class="line">tool.SetPrecision(closeTol); </div><div class="line">Standard_Real maxTol = â€¦; </div><div class="line">tool.SetMaxTolerance(maxTol); </div><div class="line">Standard_Integer NbSplitPoints = â€¦; </div><div class="line">tool.SetNbSplitPoints(num); </div><div class="line">if ( ! tool.Perform() &amp;&amp; tool.Status (ShapeExtend_FAIL) ) { </div><div class="line">  cout&lt;&lt;&quot;Splitting of closed faces failed&quot;&lt;&lt;endl; </div><div class="line">  . . . </div><div class="line">} </div><div class="line">TopoDS_Shape aResult = tool.Result(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_3_5"></a>
Tool for splitting a C0 BSpline 2D or 3D curve to a sequence C1 BSpline curves</h3>
<p>The API methods for this tool is a package of methods <em>ShapeUpgrade::C0BSplineToSequenceOfC1BsplineCurve</em>, which converts a C0 B-Spline curve into a sequence of C1 B-Spline curves. This method splits a B-Spline at the knots with multiplicities equal to degree, it does not use any tolerance and therefore does not change the geometry of the B-Spline. The method returns True if C0 B-Spline was successfully split, otherwise returns False (if BS is C1 B-Spline).</p>
<h3><a class="anchor" id="occt_shg_4_3_6"></a>
Tool for splitting faces</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide_area.html">ShapeUpgrade_ShapeDivideArea</a></em> can work with compounds, solids, shells and faces. During the work this tool examines each face of a specified shape and if the face area exceeds the specified maximal area, this face is divided. Face splitting is performed in the parametric space of this face. The values of splitting in U and V directions are calculated with the account of translation of the bounding box form parametric space to 3D space.</p>
<p>Such calculations are necessary to avoid creation of strip faces. In the process of splitting the holes on the initial face are taken into account. After the splitting all new faces are checked by area again and the splitting procedure is repeated for the faces whose area still exceeds the max allowed area. Sharing between faces in the shape is preserved and the resulting shape is of the same type as the source shape.</p>
<p>An example of using this tool is presented in the figures below:</p>
<div class="image">
<img src="shape_healing_image003.png" alt="shape_healing_image003.png"/>
<div class="caption">
Source Face</div></div>
<div class="image">
<img src="shape_healing_image004.png" alt="shape_healing_image004.png"/>
<div class="caption">
Resulting shape</div></div>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide_area.html">ShapeUpgrade_ShapeDivideArea</a></em> is inherited from the base class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___shape_divide.html">ShapeUpgrade_ShapeDivide</a></em> and should be used in the following way:</p><ul>
<li>This class should be initialized on a shape with the help of the constructor or method <em>Init()</em> from the base class.</li>
<li>The maximal allowed area should be specified by the method <em>MaxArea()</em>.</li>
<li>To produce a splitting use method Perform from the base class.</li>
<li>The result shape can be obtained with the help the method <em>Result()</em>.</li>
</ul>
<div class="fragment"><div class="line">ShapeUpgrade_ShapeDivideArea tool (inputShape); </div><div class="line">tool.MaxArea() = aMaxArea; </div><div class="line">tool.Perform(); </div><div class="line">if(tool.Status(ShapeExtend_DONE)) { </div><div class="line">  TopoDS_Shape ResultShape = tool.Result(); </div><div class="line">  ShapeFix::SameParameter ( ResultShape, Standard_False ); </div><div class="line">} </div></div><!-- fragment --><p><b>Note</b> that the use of method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html#ad15adb4c626e94474433bfe831b223a6">ShapeFix::SameParameter</a></em> is necessary, otherwise the parameter edges obtained as a result of splitting can be different.</p>
<h4>Additional methods</h4>
<ul>
<li>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___face_divide_area.html">ShapeUpgrade_FaceDivideArea</a></em> inherited from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___face_divide.html">ShapeUpgrade_FaceDivide</a></em> is intended for splitting a face by the maximal area criterion.</li>
<li>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___split_surface_area.html">ShapeUpgrade_SplitSurfaceArea</a></em> inherited from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___split_surface.html">ShapeUpgrade_SplitSurface</a></em> calculates the parameters of face splitting in the parametric space.</li>
</ul>
<h2><a class="anchor" id="occt_shg_4_4"></a>
Customization of shapes</h2>
<p>Customization tools are intended for adaptation of shape geometry in compliance with the customer needs. They modify a geometrical object to another one in the shape.</p>
<p>To implement the necessary shape modification it is enough to initialize the appropriate tool by the shape and desirable parameters and to get the resulting shape. For example for conversion of indirect surfaces in the shape do the following:</p>
<div class="fragment"><div class="line">TopoDS_Shape initialShape .. </div><div class="line">TopoDS_Shape resultShape = ShapeCustom::DirectFaces(initialShape); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_4_1"></a>
Conversion of indirect surfaces.</h3>
<div class="fragment"><div class="line">ShapeCustom::DirectFaces </div><div class="line">    static TopoDS_Shape DirectFaces(const TopoDS_Shape&amp; S); </div></div><!-- fragment --><p>This method provides conversion of indirect elementary surfaces (elementary surfaces with left-handed coordinate systems) in the shape into direct ones. New 2d curves (recomputed for converted surfaces) are added to the same edges being shared by both the resulting shape and the original shape <em>S</em>.</p>
<h3><a class="anchor" id="occt_shg_4_4_2"></a>
Shape Scaling</h3>
<div class="fragment"><div class="line">ShapeCustom::ScaleShape </div><div class="line">    TopoDS_Shape ShapeCustom::ScaleShape(const TopoDS_Shape&amp; S,</div><div class="line">        const Standard_Real scale); </div></div><!-- fragment --><p>This method returns a new shape, which is a scaled original shape with a coefficient equal to the specified value of scale. It uses the tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom___trsf_modification.html">ShapeCustom_TrsfModification</a></em>.</p>
<h3><a class="anchor" id="occt_shg_4_4_3"></a>
Conversion of curves and surfaces to BSpline</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom___b_spline_restriction.html">ShapeCustom_BSplineRestriction</a></em> allows approximation of surfaces, curves and 2D curves with a specified degree, maximum number of segments, 2d tolerance and 3d tolerance. If the approximation result cannot be achieved with the specified continuity, the latter can be reduced.</p>
<p>The method with all parameters looks as follows: </p><div class="fragment"><div class="line">ShapeCustom::BsplineRestriction </div><div class="line">    TopoDS_Shape ShapeCustom::BSplineRestriction (const TopoDS_Shape&amp; S, </div><div class="line">        const Standard_Real Tol3d, const Standard_Real Tol2d, </div><div class="line">        const Standard_Integer MaxDegree, </div><div class="line">        const Standard_Integer MaxNbSegment, </div><div class="line">        const GeomAbs_Shape Continuity3d, </div><div class="line">        const GeomAbs_Shape Continuity2d, </div><div class="line">        const Standard_Boolean Degree, </div><div class="line">        const Standard_Boolean Rational, </div><div class="line">        const Handle(ShapeCustom_RestrictionParameters)&amp; aParameters) </div></div><!-- fragment --><p>It returns a new shape with all surfaces, curves and 2D curves of BSpline/Bezier type or based on them, converted with a degree less than <em>MaxDegree</em> or with a number of spans less then <em>NbMaxSegment</em> depending on the priority parameter <em>Degree</em>. If this parameter is equal to True then <em>Degree</em> will be increased to the value <em>GmaxDegree</em>, otherwise <em>NbMaxSegments</em> will be increased to the value <em>GmaxSegments</em>. <em>GmaxDegree</em> and <em>GMaxSegments</em> are the maximum possible degree and the number of spans correspondingly. These values will be used in cases when an approximation with specified parameters is impossible and either <em>GmaxDegree</em> or <em>GMaxSegments</em> is selected depending on the priority.</p>
<p>Note that if approximation is impossible with <em>GMaxDegree</em>, even then the number of spans can exceed the specified <em>GMaxSegment</em>. <em>Rational</em> specifies whether Rational BSpline/Bezier should be converted into polynomial B-Spline.</p>
<p>Also note that the continuity of surfaces in the resulting shape can be less than the given value.</p>
<h4>Flags</h4>
<p>To convert other types of curves and surfaces to BSpline with required parameters it is necessary to use flags from class <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom___restriction_parameters.html">ShapeCustom_RestrictionParameters</a>, which is just a container of flags. The following flags define whether a specified-type geometry has been converted to BSpline with the required parameters:</p><ul>
<li><em>ConvertPlane,</em></li>
<li><em>ConvertBezierSurf,</em></li>
<li><em>ConvertRevolutionSurf,</em></li>
<li><em>ConvertExtrusionSurf,</em></li>
<li><em>ConvertOffsetSurf,</em></li>
<li><em>ConvertCurve3d,</em> &ndash; for conversion of all types of 3D curves.</li>
<li><em>ConvertOffsetCurv3d,</em> &ndash; for conversion of offset 3D curves.</li>
<li><em>ConvertCurve2d,</em> &ndash; for conversion of all types of 2D curves.</li>
<li><em>ConvertOffsetCurv2d,</em> &ndash; for conversion of offset 2D curves.</li>
<li><em>SegmentSurfaceMode</em> &ndash; defines whether the surface would be approximated within the boundaries of the face lying on this surface.</li>
</ul>
<h3><a class="anchor" id="occt_shg_4_4_4"></a>
Conversion of elementary surfaces into surfaces of revolution</h3>
<div class="fragment"><div class="line">ShapeCustom::ConvertToRevolution()</div><div class="line">    TopoDS_Shape ShapeCustom::ConvertToRevolution(const TopoDS_Shape&amp; S) ; </div></div><!-- fragment --><p>This method returns a new shape with all elementary periodic surfaces converted to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___surface_of_revolution.html">Geom_SurfaceOfRevolution</a></em>. It uses the tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom___convert_to_revolution.html">ShapeCustom_ConvertToRevolution</a></em>.</p>
<h3><a class="anchor" id="occt_shg_4_4_5"></a>
Conversion of elementary surfaces into Bspline surfaces</h3>
<div class="fragment"><div class="line">ShapeCustom::ConvertToBSpline() </div><div class="line">    TopoDS_Shape ShapeCustom::ConvertToBSpline( const TopoDS_Shape&amp; S, </div><div class="line">        const Standard_Boolean extrMode, </div><div class="line">        const Standard_Boolean revolMode, </div><div class="line">        const Standard_Boolean offsetMode); </div></div><!-- fragment --><p>This method returns a new shape with all surfaces of linear extrusion, revolution and offset surfaces converted according to flags to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___b_spline_surface.html">Geom_BSplineSurface</a></em> (with the same parameterization). It uses the tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom___convert_to_b_spline.html">ShapeCustom_ConvertToBSpline</a></em>.</p>
<h3><a class="anchor" id="occt_shg_4_4_6"></a>
Getting the history of modification of sub-shapes.</h3>
<p>If, in addition to the resulting shape, you want to get the history of modification of sub-shapes you should not use the package methods described above and should use your own code instead:</p><ol type="1">
<li>Create a tool that is responsible for the necessary modification.</li>
<li>Create the tool <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___modifier.html">BRepTools_Modifier</a></em> that performs a specified modification in the shape.</li>
<li>To get the history and to keep the assembly structure use the method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom.html#ae57070406e61e138c8f3d03dc570ada6">ShapeCustom::ApplyModifier</a></em>.</li>
</ol>
<p>The general calling syntax for scaling is </p><div class="fragment"><div class="line">TopoDS_Shape scaled_shape = ShapeCustom::ScaleShape(shape, scale); </div></div><!-- fragment --><p>Note that scale is a real value. You can refine your mapping process by using additional calls to follow shape mapping sub-shape by sub-shape. The following code along with pertinent includes can be used:</p>
<div class="fragment"><div class="line">p_Trsf T; </div><div class="line">Standard_Real scale = 100; // for example! </div><div class="line">T.SetScale (gp_Pnt (0, 0, 0), scale); </div><div class="line">Handle(ShapeCustom_TrsfModification) TM = new </div><div class="line">ShapeCustom_TrsfModification(T); </div><div class="line">TopTools_DataMapOfShapeShape context; </div><div class="line">BRepTools_Modifier MD; </div><div class="line">TopoDS_Shape res = ShapeCustom::ApplyModifier ( </div><div class="line">Shape, TM, context,MD ); </div></div><!-- fragment --><p>The map, called context in our example, contains the history. Substitutions are made one by one and all shapes are transformed. To determine what happens to a particular sub-shape, it is possible to use:</p>
<div class="fragment"><div class="line">TopoDS_Shape oneres = context.Find (oneshape); </div><div class="line">//In case there is a doubt, you can also add: </div><div class="line">if (context.IsBound(oneshape)) oneres = context.Find(oneshape); </div><div class="line">//You can also sweep the entire data map by using: </div><div class="line">TopTools_DataMapIteratorOfDataMapOfShapeShape </div><div class="line">//To do this, enter: </div><div class="line">for(TopTools_DataMapIteratorOfDataMapOfShapeShape </div><div class="line">iter(context);iter(more ();iter.next ()) { </div><div class="line">  TopoDs_Shape oneshape = iter.key (); </div><div class="line">  TopoDs_Shape oneres = iter.value (); </div><div class="line">} </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_4_7"></a>
Remove internal wires</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___remove_internal_wires.html">ShapeUpgrade_RemoveInternalWires</a></em> tool removes internal wires with contour area less than the specified minimal area. It can work with compounds, solids, shells and faces.</p>
<p>If the flag <em>RemoveFaceMode</em> is set to TRUE, separate faces or a group of faces with outer wires, which consist only of edges that belong to the removed internal wires, are removed (seam edges are not taken into account). Such faces can be removed only for a sewed shape.</p>
<p>Internal wires can be removed by the methods <em>Perform</em>. Both methods <em>Perform</em> can not be carried out if the class has not been initialized by the shape. In such case the status of <em>Perform</em> is set to FAIL .</p>
<p>The method <em>Perform</em> without arguments removes from all faces in the specified shape internal wires whose area is less than the minimal area.</p>
<p>The other method <em>Perform</em> has a sequence of shapes as an argument. This sequence can contain faces or wires. If the sequence of shapes contains wires, only the internal wires are removed.</p>
<p>If the sequence of shapes contains faces, only the internal wires from these faces are removed.</p>
<ul>
<li>The status of the performed operation can be obtained using method <em>Status()</em>;</li>
<li>The resulting shape can be obtained using method <em>GetResult()</em>.</li>
</ul>
<p>An example of using this tool is presented in the figures below:</p>
<div class="image">
<img src="shape_healing_image005.png" alt="shape_healing_image005.png"/>
<div class="caption">
Source Face</div></div>
 <div class="image">
<img src="shape_healing_image006.png" alt="shape_healing_image006.png"/>
<div class="caption">
Resulting shape</div></div>
<p>After the processing three internal wires with contour area less than the specified minimal area have been removed. One internal face has been removed. The outer wire of this face consists of the edges belonging to the removed internal wires and a seam edge. Two other internal faces have not been removed because their outer wires consist not only of edges belonging to the removed wires.</p>
<div class="image">
<img src="shape_healing_image007.png" alt="shape_healing_image007.png"/>
<div class="caption">
Source Face</div></div>
<div class="image">
<img src="shape_healing_image008.png" alt="shape_healing_image008.png"/>
<div class="caption">
Resulting shape</div></div>
<p>After the processing six internal wires with contour area less than the specified minimal area have been removed. Six internal faces have been removed. These faces can be united into groups of faces. Each group of faces has an outer wire consisting only of edges belonging to the removed internal wires. Such groups of faces are also removed.</p>
<p>The example of method application is also given below:</p>
<div class="fragment"><div class="line">//Initialization of the class by shape. </div><div class="line">Handle(ShapeUpgrade_RemoveInternalWires) aTool = new ShapeUpgrade_RemoveInternalWires(inputShape); </div><div class="line">//setting parameters </div><div class="line">aTool-&gt;MinArea() = aMinArea; </div><div class="line">aTool-&gt;RemoveFaceMode() = aModeRemoveFaces; </div><div class="line"></div><div class="line">//when method Perform is carried out on separate shapes. </div><div class="line">aTool-&gt;Perform(aSeqShapes); </div><div class="line"></div><div class="line">//when method Perform is carried out on whole shape. </div><div class="line">aTool-&gt;Perform(); </div><div class="line">//check status set after method Perform </div><div class="line">if(aTool-&gt;Status(ShapeExtend_FAIL) { </div><div class="line">  cout&lt;&lt;&quot;Operation failed&quot;&lt;&lt; &lt;&lt;&quot;\n&quot;; </div><div class="line">   return; </div><div class="line">} </div><div class="line"></div><div class="line">if(aTool-&gt;Status(ShapeExtend_DONE1)) { </div><div class="line">    const TopTools_SequenceOfShape&amp; aRemovedWires =aTool-&gt;RemovedWires(); </div><div class="line">     cout&lt;&lt;aRemovedWires.Length()&lt;&lt;&quot; internal wires were removed&quot;&lt;&lt;&quot;\n&quot;; </div><div class="line"></div><div class="line">  } </div><div class="line"></div><div class="line">  if(aTool-&gt;Status(ShapeExtend_DONE2)) { </div><div class="line">    const TopTools_SequenceOfShape&amp; aRemovedFaces =aTool-&gt;RemovedFaces(); </div><div class="line">     cout&lt;&lt;aRemovedFaces.Length()&lt;&lt;&quot; small faces were removed&quot;&lt;&lt;&quot;\n&quot;; </div><div class="line"></div><div class="line">  }   </div><div class="line">    //getting result shape </div><div class="line">  TopoDS_Shape res = aTool-&gt;GetResult(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_4_8"></a>
Conversion of surfaces</h3>
<p>Class <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_custom___surface.html">ShapeCustom_Surface</a> allows:</p><ul>
<li>converting BSpline and Bezier surfaces to the analytical form (using method <em>ConvertToAnalytical())</em></li>
<li>converting closed B-Spline surfaces to periodic ones.(using method <em>ConvertToPeriodic</em>)</li>
</ul>
<p>To convert surfaces to analytical form this class analyzes the form and the closure of the source surface and defines whether it can be approximated by analytical surface of one of the following types:</p><ul>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___plane.html">Geom_Plane</a>,</em></li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___spherical_surface.html">Geom_SphericalSurface</a>,</em></li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___cylindrical_surface.html">Geom_CylindricalSurface</a>,</em></li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___conical_surface.html">Geom_ConicalSurface</a>,</em></li>
<li><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_geom___toroidal_surface.html">Geom_ToroidalSurface</a></em>.</li>
</ul>
<p>The conversion is done only if the new (analytical) surface does not deviate from the source one more than by the given precision.</p>
<div class="fragment"><div class="line">Handle(Geom_Surface) initSurf; </div><div class="line">ShapeCustom_Surface ConvSurf(initSurf); </div><div class="line">//conversion to analytical form </div><div class="line">Handle(Geom_Surface) newSurf  = ConvSurf.ConvertToAnalytical(allowedtol,Standard_False); </div><div class="line">//or conversion to a periodic surface </div><div class="line">Handle(Geom_Surface) newSurf  = ConvSurf.ConvertToPeriodic(Standard_False); </div><div class="line">//getting the maximum deviation of the new surface from the initial surface </div><div class="line">Standard_Real maxdist = ConvSurf.Gap(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_shg_4_4_9"></a>
Unify Same Domain</h3>
<p><em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade___unify_same_domain.html">ShapeUpgrade_UnifySameDomain</a></em> tool allows unifying all possible faces and edges of a shape, which lies on the same geometry. Faces/edges are considered as 'same-domain' if the neighboring faces/edges lie on coincident surfaces/curves. Such faces/edges can be unified into one face/edge. This tool takes an input shape and returns a new one. All modifications of the initial shape are recorded during the operation.</p>
<p>The following options are available:</p>
<ul>
<li>If the flag <em>UnifyFaces</em> is set to TRUE, <em>UnifySameDomain</em> tries to unify all possible faces;</li>
<li>If the flag <em>UnifyEdges</em> is set to TRUE, <em>UnifySameDomain</em> tries to unify all possible edges;</li>
<li>if the flag <em>ConcatBSplines</em> is set to TRUE, all neighboring edges, which lie on the BSpline or Bezier curves with C1 continuity on their common vertices will be merged into one common edge.</li>
</ul>
<p>By default, <em>UnifyFaces</em> and <em>UnifyEdges</em> are set to TRUE; <em>ConcatBSplines</em> is set to FALSE.</p>
<p>The common methods of this tool are as follows:</p>
<ul>
<li>Method <em>Build()</em> is used to unify.</li>
<li>Method <em>Shape()</em> is used to get the resulting shape.</li>
<li>Method <em>Generated()</em> is used to get a new common shape from the old shape. If a group of edges has been unified into one common edge then method <em>Generated()</em> called on any edge from this group will return the common edge. The same goes for the faces.</li>
</ul>
<p>The example of the usage is given below: </p><div class="fragment"><div class="line">// &#39;Sh&#39; is the initial shape</div><div class="line">ShapeUpgrade_UnifySameDomain USD(Sh, true, true, true); // UnifyFaces mode on, UnifyEdges mode on, ConcatBSplines mode on.</div><div class="line">USD.Build();</div><div class="line">//get the result</div><div class="line">TopoDS_Shape Result = USD.Shape(); </div><div class="line">//Let Sh1 as a part of Sh</div><div class="line">//get the new (probably unified) shape form the Sh1</div><div class="line">TopoDS_Shape ResSh1 = USD.Generated(Sh1);</div></div><!-- fragment --><h1><a class="anchor" id="occt_shg_5_"></a>
Auxiliary tools for repairing, analysis and upgrading</h1>
<h2><a class="anchor" id="occt_shg_5_1"></a>
Tool for rebuilding shapes</h2>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em> rebuilds a shape by making predefined substitutions on some of its components. During the first phase, it records requests to replace or remove some individual shapes. For each shape, the last given request is recorded. Requests may be applied as <em>Oriented</em> (i.e. only to an item with the same orientation) or not (the orientation of the replacing shape corresponds to that of the original one). Then these requests may be applied to any shape, which may contain one or more of these individual shapes.</p>
<p>This tool has a flag for taking the location of shapes into account (for keeping the structure of assemblies) (<em>ModeConsiderLocation</em>). If this mode is equal to Standard_True, the shared shapes with locations will be kept. If this mode is equal to Standard_False, some different shapes will be produced from one shape with different locations after rebuilding. By default, this mode is equal to Standard_False.</p>
<p>To use this tool for the reconstruction of shapes it is necessary to take the following steps:</p><ol type="1">
<li>Create this tool and use method <em>Apply()</em> for its initialization by the initial shape. Parameter <em>until</em> sets the level of shape type and requests are taken into account up to this level only. Sub-shapes of the type standing beyond the <em>line</em> set by parameter until will not be rebuilt and no further exploration will be done</li>
<li>Replace or remove sub-shapes of the initial shape. Each sub-shape can be replaced by a shape of the same type or by shape containing shapes of that type only (for example, <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> can be replaced by <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a>, <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___wire.html">TopoDS_Wire</a></em> or <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___compound.html">TopoDS_Compound</a></em> containing <em>TopoDS_Edges</em>). If an incompatible shape type is encountered, it is ignored and flag FAIL1 is set in Status. For a sub-shape it is recommended to use method <em>Apply</em> before methods <em>Replace</em> and <em>Remove</em>, because the sub-shape has already been changed for the moment by its previous modifications or modification of its sub-shape (for example <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___edge.html">TopoDS_Edge</a></em> can be changed by a modification of its <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___vertex.html">TopoDS_Vertex</a></em>, etc.).</li>
<li>Use method <em>Apply</em> for the initial shape again to get the resulting shape after all modifications have been made.</li>
<li>Use method <em>Apply</em> to obtain the history of sub-shape modification.</li>
</ol>
<p>Additional method <em>IsNewShape</em> can be used to check if the shape has been recorded by <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___re_shape.html">BRepTools_ReShape</a></em> tool as a value.</p>
<p><b>Note</b> that in fact class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em> is an alias for class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_tools___re_shape.html">BRepTools_ReShape</a></em>. They differ only in queries of statuses in the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_build___re_shape.html">ShapeBuild_ReShape</a></em> class.</p>
<p>Let us use the tool to get the result shape after modification of sub-shapes of the initial shape:</p>
<div class="fragment"><div class="line">TopoDS_Shape initialShapeâ€¦ </div><div class="line">//creation of a rebuilding tool </div><div class="line">Handle(ShapeBuild_ReShape) Context = new ShapeBuild_ReShape. </div><div class="line"></div><div class="line">//next step is optional. It can be used for keeping the assembly structure. </div><div class="line">Context-&gt; ModeConsiderLocation = Standard_True; </div><div class="line"></div><div class="line">//initialization of this tool by the initial shape </div><div class="line">Context-&gt;Apply(initialShape); </div><div class="line">â€¦ </div><div class="line">//getting the intermediate result for replacing subshape1 with the modified subshape1. </div><div class="line">TopoDS_Shape tempshape1 = Context-&gt;Apply(subshape1); </div><div class="line"></div><div class="line">//replacing the intermediate shape obtained from subshape1 with the newsubshape1. </div><div class="line">Context-&gt;Replace(tempsubshape1,newsubshape1); </div><div class="line">â€¦ </div><div class="line">//for removing the sub-shape </div><div class="line">TopoDS_Shape tempshape2 = Context-&gt;Apply(subshape2); </div><div class="line">Context-&gt;Remove(tempsubshape2); </div><div class="line"></div><div class="line">//getting the result and the history of modification </div><div class="line">TopoDS_Shape resultShape = Context-&gt;Apply(initialShape); </div><div class="line"></div><div class="line">//getting the resulting sub-shape from the subshape1 of the initial shape. </div><div class="line">TopoDS_Shape result_subshape1 = Context-&gt;Apply(subshape1); </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_5_2"></a>
Status definition</h2>
<p><em>ShapExtend_Status</em> is used to report the status after executing some methods that can either fail, do something, or do nothing. The status is a set of flags <em>DONEi</em> and <em>FAILi</em>. Any combination of them can be set at the same time. For exploring the status, enumeration is used.</p>
<p>The values have the following meaning:</p>
<table class="doxtable">
<tr>
<th align="left">Value </th><th align="left">Meaning  </th></tr>
<tr>
<td align="left"><em>OK,</em> </td><td align="left">Nothing is done, everything OK </td></tr>
<tr>
<td align="left"><em>DONE1,</em> </td><td align="left">Something was done, case 1 </td></tr>
<tr>
<td align="left"><em>DONE8</em>, </td><td align="left">Something was done, case 8 </td></tr>
<tr>
<td align="left"><em>DONE</em>, </td><td align="left">Something was done (any of DONE#) </td></tr>
<tr>
<td align="left"><em>FAIL1</em>, </td><td align="left">The method failed, case 1 </td></tr>
<tr>
<td align="left"><em>FAIL8</em>, </td><td align="left">The method failed, case 8 </td></tr>
<tr>
<td align="left"><em>FAIL</em> </td><td align="left">The method failed (any of FAIL# occurred) </td></tr>
</table>
<h2><a class="anchor" id="occt_shg_5_3"></a>
Tool representing a wire</h2>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_extend___wire_data.html">ShapeExtend_WireData</a></em> provides a data structure necessary to work with the wire as with an ordered list of edges, and that is required for many algorithms. The advantage of this class is that it allows to work with incorrect wires.</p>
<p>The object of the class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_extend___wire_data.html">ShapeExtend_WireData</a></em> can be initialized by <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___wire.html">TopoDS_Wire</a></em> and converted back to <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___wire.html">TopoDS_Wire</a></em>.</p>
<p>An edge in the wire is defined by its rank number. Operations of accessing, adding and removing an edge at/to the given rank number are provided. Operations of circular permutation and reversing (both orientations of all edges and the order of edges) are provided on the whole wire as well.</p>
<p>This class also provides a method to check if the edge in the wire is a seam (if the wire lies on a face).</p>
<p>Let us remove edges from the wire and define whether it is seam edge</p>
<div class="fragment"><div class="line">TopoDS_Wire ini = .. </div><div class="line">Handle(ShapeExtend_Wire) asewd = new ShapeExtend_Wire(initwire); </div><div class="line">//Removing edge Edge1 from the wire. </div><div class="line"></div><div class="line">Standard_Integer index_edge1 = asewd-&gt;Index(Edge1); </div><div class="line">asewd.Remove(index_edge1); </div><div class="line">//Definition of whether Edge2 is a seam edge </div><div class="line">Standard_Integer index_edge2 = asewd-&gt;Index(Edge2); </div><div class="line">asewd-&gt;IsSeam(index_edge2); </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_5_4"></a>
Tool for exploring shapes</h2>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_extend___explorer.html">ShapeExtend_Explorer</a></em> is intended to explore shapes and convert different representations (list, sequence, compound) of complex shapes. It provides tools for:</p><ul>
<li>obtaining the type of the shapes in the context of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___compound.html">TopoDS_Compound</a></em>,</li>
<li>exploring shapes in the context of <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___compound.html">TopoDS_Compound</a></em>,</li>
<li>converting different representations of shapes (list, sequence, compound).</li>
</ul>
<h2><a class="anchor" id="occt_shg_5_5"></a>
Tool for attaching messages to objects</h2>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_extend___msg_registrator.html">ShapeExtend_MsgRegistrator</a></em> attaches messages to objects (generic Transient or shape). The objects of this class are transmitted to the Shape Healing algorithms so that they could collect messages occurred during shape processing. Messages are added to the Maps (stored as a field) that can be used, for instance, by Data Exchange processors to attach those messages to initial file entities.</p>
<p>Let us send and get a message attached to object:</p>
<div class="fragment"><div class="line">Handle(ShapeExtend_MsgRegistrator) MessageReg = new ShapeExtend_MsgRegistrator; </div><div class="line">//attaches messages to an object (shape or entity) </div><div class="line">Message_Msg msg.. </div><div class="line">TopoDS_Shape Shape1â€¦ </div><div class="line">MessageReg-&gt;Send(Shape1,msg,Message_WARNING); </div><div class="line">Handle(Standard_Transient) ent .. </div><div class="line">MessageReg-&gt;Send(ent,msg,Message_WARNING); </div><div class="line">//gets messages attached to shape </div><div class="line">const ShapeExtend_DataMapOfShapeListOfMsg&amp; msgmap = MessageReg-&gt;MapShape(); </div><div class="line">if (msgmap.IsBound (Shape1)) { </div><div class="line"> const Message_ListOfMsg &amp;msglist = msgmap.Find (Shape1); </div><div class="line"> for (Message_ListIteratorOfListOfMsg iter (msglist); </div><div class="line">iter.More(); iter.Next()) { </div><div class="line">       Message_Msg msg = iter.Value(); </div><div class="line"> } </div><div class="line">    } </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_5_6"></a>
Tools for performance measurement</h2>
<p>Classes <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_moni_tool___timer.html">MoniTool_Timer</a></em> and <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_moni_tool___timer_sentry.html">MoniTool_TimerSentry</a></em> are used for measuring the performance of a current operation or any part of code, and provide the necessary API. Timers are used for debugging and performance optimizing purposes.</p>
<p>Let us try to use timers in <em>XSDRAWIGES.cxx</em> and <em>IGESBRep_Reader.cxx</em> to analyse the performance of command <em>igesbrep</em>:</p>
<div class="fragment"><div class="line">XSDRAWIGES.cxx</div><div class="line">  ...</div><div class="line">  #include &lt;MoniTool_Timer.hxx&gt;</div><div class="line">  #include &lt;MoniTool_TimerSentry.hxx&gt;</div><div class="line">  ...</div><div class="line">  MoniTool_Timer::ClearTimers();</div><div class="line">  ...</div><div class="line">  MoniTool_TimerSentry MTS(&quot;IGES_LoadFile&quot;);</div><div class="line">  Standard_Integer status = Reader.LoadFile(fnom.ToCString());</div><div class="line">  MTS.Stop();</div><div class="line">  ...</div><div class="line">  MoniTool_Timer::DumpTimers(cout);</div><div class="line">  return;</div><div class="line"></div><div class="line"></div><div class="line">IGESBRep_Reader.cxx</div><div class="line">  ...</div><div class="line">  #include &lt;MoniTool_TimerSentry.hxx&gt;</div><div class="line">  ...</div><div class="line">  Standard_Integer nb = theModel-&gt;NbEntities();</div><div class="line">  ...</div><div class="line">  for (Standard_Integer i=1; i&lt;=nb; i++) {</div><div class="line">    MoniTool_TimerSentry MTS(&quot;IGESToBRep_Transfer&quot;);</div><div class="line">    ...</div><div class="line">    try {</div><div class="line">      TP.Transfer(ent);</div><div class="line">      shape = TransferBRep::ShapeResult (theProc,ent);</div><div class="line">    }</div><div class="line">    ...</div><div class="line">  }</div></div><!-- fragment --><p>The result of <em>DumpTimer()</em> after file translation is as follows:</p>
<table class="doxtable">
<tr>
<th align="left">TIMER </th><th align="left">Elapsed </th><th align="left">CPU User </th><th align="left">CPU Sys </th><th align="left">Hits  </th></tr>
<tr>
<td align="left"><em>IGES_LoadFile</em> </td><td align="left">1.0 sec </td><td align="left">0.9 sec </td><td align="left">0.0 sec </td><td align="left">1 </td></tr>
<tr>
<td align="left"><em>IGESToBRep_Transfer</em> </td><td align="left">14.5 sec </td><td align="left">4.4 sec </td><td align="left">0.1 sec </td><td align="left">1311 </td></tr>
</table>
<h1><a class="anchor" id="occt_shg_6"></a>
Shape Processing</h1>
<h2><a class="anchor" id="occt_shg_6_1"></a>
Usage Workflow</h2>
<p>The Shape Processing module allows defining and applying the general Shape Processing as a customizable sequence of Shape Healing operators. The customization is implemented via the user-editable resource file, which defines the sequence of operators to be executed and their parameters.</p>
<p>The Shape Processing functionality is implemented with the help of the <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_x_s_algo.html">XSAlgo</a></em> interface. The main function <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_x_s_algo___algo_container.html#a3efffae170357c7eb67aba76ea2f6a8b">XSAlgo_AlgoContainer::ProcessShape()</a></em> does shape processing with specified tolerances and returns the resulting shape and associated information in the form of <em>Transient</em>.</p>
<p>This function is used in the following way:</p>
<div class="fragment"><div class="line">TopoDS_Shape aShape = â€¦; </div><div class="line">Standard_Real Prec = â€¦, </div><div class="line">Standard_Real MaxTol = â€¦; </div><div class="line">TopoDS_Shape aResult; </div><div class="line">Handle(Standard_Transient) info; </div><div class="line">TopoDS_Shape aResult = XSAlgo::AlgoContainer()-&gt;ProcessShape(aShape, Prec, MaxTol., &quot;Name of ResourceFile&quot;, &quot;NameSequence&quot;, info ); </div></div><!-- fragment --><p>Let us create a custom sequence of operations:</p>
<ol type="1">
<li>Create a resource file with the name <em>ResourceFile</em>, which includes the following string: <div class="fragment"><div class="line">NameSequence.exec.op:    MyOper </div></div><!-- fragment --> where <em>MyOper</em> is the name of operation.</li>
<li>Input a custom parameter for this operation in the resource file, for example: <div class="fragment"><div class="line">NameSequence.MyOper.Tolerance: 0.01 </div></div><!-- fragment --> where <em>Tolerance</em> is the name of the parameter and 0.01 is its value.</li>
<li>Add the following string into <em>void <a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_process___oper_library.html#a3be272febfe4ece639064374079631f4">ShapeProcess_OperLibrary::Init()</a></em>: <div class="fragment"><div class="line">ShapeProcess::RegisterOperator(;MyOper;, </div><div class="line">new ShapeProcess_UOperator(myfunction)); </div></div><!-- fragment --> where <em>myfunction</em> is a function which implements the operation.</li>
<li>Create this function in <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_process___oper_library.html">ShapeProcess_OperLibrary</a></em> as follows: <div class="fragment"><div class="line">static Standard_Boolean myfunction (const </div><div class="line">            Handle(ShapeProcess_Context)&amp; context) </div><div class="line">{ </div><div class="line">    Handle(ShapeProcess_ShapeContext) ctx = Handle(ShapeProcess_ShapeContext)::DownCast(context); </div><div class="line">  if(ctx.IsNull()) return Standard_False; </div><div class="line">  TopoDS_Shape aShape = ctx-&gt;Result(); </div><div class="line">  //receive our parameter: </div><div class="line">  Standard_Real toler; </div><div class="line">  ctx-&gt;GetReal(;Tolerance;, toler);</div></div><!-- fragment --></li>
<li>Make the necessary operations with <em>aShape</em> using the received value of parameter <em>Tolerance</em> from the resource file. <div class="fragment"><div class="line">  return Standard_True; </div><div class="line">} </div></div><!-- fragment --></li>
<li>Define some operations (with their parameters) <em>MyOper1, MyOper2, MyOper3</em>, etc. and describe the corresponding functions in <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_process___oper_library.html">ShapeProcess_OperLibrary</a></em>.</li>
<li>Perform the required sequence using the specified name of operations and values of parameters in the resource file.</li>
</ol>
<p>For example: input of the following string: </p><div class="fragment"><div class="line">NameSequence.exec.op:    MyOper1,MyOper3 </div></div><!-- fragment --><p> means that the corresponding functions from <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_process___oper_library.html">ShapeProcess_OperLibrary</a></em> will be performed with the original shape <em>aShape</em> using parameters defined for <em>MyOper1</em> and <em>MyOper3</em> in the resource file.</p>
<p>It is necessary to note that these operations will be performed step by step and the result obtained after performing the first operation will be used as the initial shape for the second operation.</p>
<h2><a class="anchor" id="occt_shg_6_2"></a>
Operators</h2>
<h3>DirectFaces</h3>
<p>This operator sets all faces based on indirect surfaces, defined with left-handed coordinate systems as direct faces. This concerns surfaces defined by Axis Placement (Cylinders, etc). Such Axis Placement may be indirect, which is allowed in Cascade, but not allowed in some other systems. This operator reverses indirect placements and recomputes PCurves accordingly.</p>
<h3>SameParameter</h3>
<p>This operator is required after calling some other operators, according to the computations they do. Its call is explicit, so each call can be removed according to the operators, which are either called or not afterwards. This mainly concerns splitting operators that can split edges.</p>
<p>The operator applies the computation <em>SameParameter</em> which ensures that various representations of each edge (its 3d curve, the pcurve on each of the faces on which it lies) give the same 3D point for the same parameter, within a given tolerance.</p><ul>
<li>For each edge coded as <em>same parameter</em>, deviation of curve representation is computed and if the edge tolerance is less than that deviation, the tolerance is increased so that it satisfies the deviation. No geometry modification, only an increase of tolerance is possible.</li>
<li>For each edge coded as <em>not same parameter</em> the deviation is computed as in the first case. Then an attempt is made to achieve the edge equality to <em>same parameter</em> by means of modification of 2d curves. If the deviation of this modified edge is less than the original deviation then this edge is returned, otherwise the original edge (with non-modified 2d curves) is returned with an increased (if necessary) tolerance. Computation is done by call to the standard algorithm <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_lib.html#a62efd593d5556e95679ff8d11e6a85fd">BRepLib::SameParameter</a></em>.</li>
</ul>
<p>This operator can be called with the following parameters:</p><ul>
<li><em>Boolean : Force</em> (optional) &ndash; if True, encodes all edges as <em>not same parameter</em> then runs the computation. Else, the computation is done only for those edges already coded as <em>not same parameter</em>.</li>
<li><em>Real : Tolerance3d</em> (optional) &ndash; if not defined, the local tolerance of each edge is taken for its own computation. Else, this parameter gives the global tolerance for the whole shape.</li>
</ul>
<h3>BSplineRestriction</h3>
<p>This operator is used for conversion of surfaces, curves 2d curves to BSpline surfaces with a specified degree and a specified number of spans. It performs approximations on surfaces, curves and 2d curves with a specified degree, maximum number of segments, 2d tolerance, 3d tolerance. The specified continuity can be reduced if the approximation with a specified continuity was not done successfully.</p>
<p>This operator can be called with the following parameters:</p><ul>
<li><em>Boolean : SurfaceMode</em> allows considering the surfaces;</li>
<li><em>Boolean : Curve3dMode</em> allows considering the 3d curves;</li>
<li><em>Boolean : Curve2dMode</em> allows considering the 2d curves;</li>
<li><em>Real : Tolerance3d</em> defines 3d tolerance to be used in computation;</li>
<li><em>Real : Tolerance2d</em> defines 2d tolerance to be used when computing 2d curves;</li>
<li><em>GeomAbs_Shape (C0 G1 C1 G2 C2 CN) : Continuity3d</em> is the continuity required in 2d;</li>
<li><em>GeomAbs_Shape (C0 G1 C1 G2 C2 CN) : Continuity2d</em> is the continuity required in 3d;</li>
<li><em>Integer : RequiredDegree</em> gives the required degree;</li>
<li><em>Integer : RequiredNbSegments</em> gives the required number of segments;</li>
<li><em>Boolean : PreferDegree</em> if true, <em>RequiredDegree</em> has a priority, else <em>RequiredNbSegments</em> has a priority;</li>
<li><em>Boolean : RationalToPolynomial</em> serves for conversion of BSplines to polynomial form;</li>
<li><em>Integer : MaxDegree</em> gives the maximum allowed Degree, if <em>RequiredDegree</em> cannot be reached;</li>
<li><em>Integer : MaxNbSegments</em> gives the maximum allowed NbSegments, if <em>RequiredNbSegments</em> cannot be reached.</li>
</ul>
<p>The following flags allow managing the conversion of special types of curves or surfaces, in addition to BSpline. They are controlled by <em>SurfaceMode, Curve3dMode</em> or <em>Curve2dMode</em> respectively; by default, only BSplines and Bezier Geometries are considered:</p><ul>
<li><em>Boolean : OffsetSurfaceMode</em></li>
<li><em>Boolean : LinearExtrusionMode</em></li>
<li><em>Boolean : RevolutionMode</em></li>
<li><em>Boolean : OffsetCurve3dMode</em></li>
<li><em>Boolean : OffsetCurve2dMode</em></li>
<li><em>Boolean : PlaneMode</em></li>
<li><em>Boolean : BezierMode</em></li>
<li><em>Boolean : ConvCurve3dMode</em></li>
<li><em>Boolean : ConvCurve2dMode</em></li>
</ul>
<p>For each of the Mode parameters listed above, if it is True, the specified geometry is converted to BSpline, otherwise only its basic geometry is checked and converted (if necessary) keeping the original type of geometry (revolution, offset, etc).</p>
<ul>
<li><em>Boolean :SegmentSurfaceMode</em> has effect only for Bsplines and Bezier surfaces. When False a surface will be replaced by a Trimmed Surface, else new geometry will be created by splitting the original Bspline or Bezier surface.</li>
</ul>
<h3>ElementaryToRevolution</h3>
<p>This operator converts elementary periodic surfaces to SurfaceOfRevolution.</p>
<h3>SplitAngle</h3>
<p>This operator splits surfaces of revolution, cylindrical, toroidal, conical, spherical surfaces in the given shape so that each resulting segment covers not more than the defined number of degrees.</p>
<p>It can be called with the following parameters:</p><ul>
<li><em>Real : Angle</em> &ndash; the maximum allowed angle for resulting faces;</li>
<li><em>Real : MaxTolerance</em> &ndash; the maximum tolerance used in computations.</li>
</ul>
<h3>SurfaceToBSpline</h3>
<p>This operator converts some specific types of Surfaces, to BSpline (according to parameters). It can be called with the following parameters:</p><ul>
<li><em>Boolean : LinearExtrusionMode</em> allows converting surfaces of Linear Extrusion;</li>
<li><em>Boolean : RevolutionMode</em> allows converting surfaces of Revolution;</li>
<li><em>Boolean : OffsetMode</em> allows converting Offset Surfaces</li>
</ul>
<h3>ToBezier</h3>
<p>This operator is used for data supported as Bezier only and converts various types of geometries to Bezier. It can be called with the following parameters used in computation of conversion :</p><ul>
<li><em>Boolean : SurfaceMode</em></li>
<li><em>Boolean : Curve3dMode</em></li>
<li><em>Boolean : Curve2dMode</em></li>
<li><em>Real : MaxTolerance</em></li>
<li><em>Boolean : SegmentSurfaceMode</em> (default is True) has effect only for Bsplines and Bezier surfaces. When False a surface will be replaced by a Trimmed Surface, else new geometry will be created by splitting the original Bspline or Bezier surface.</li>
</ul>
<p>The following parameters are controlled by <em>SurfaceMode, Curve3dMode</em> or <em>Curve2dMode</em> (according to the case):</p><ul>
<li><em>Boolean : Line3dMode</em></li>
<li><em>Boolean : Circle3dMode</em></li>
<li><em>Boolean : Conic3dMode</em></li>
<li><em>Boolean : PlaneMode</em></li>
<li><em>Boolean : RevolutionMode</em></li>
<li><em>Boolean : ExtrusionMode</em></li>
<li><em>Boolean : BSplineMode</em></li>
</ul>
<h3>SplitContinuity</h3>
<p>This operator splits a shape in order to have each geometry (surface, curve 3d, curve 2d) correspond the given criterion of continuity. It can be called with the following parameters:</p><ul>
<li><em>Real : Tolerance3d</em></li>
<li><em>Integer (GeomAbs_Shape ) : CurveContinuity</em></li>
<li><em>Integer (GeomAbs_Shape ) : SurfaceContinuity</em></li>
<li><em>Real : MaxTolerance</em></li>
</ul>
<p>Because of algorithmic limitations in the operator <em>BSplineRestriction</em> (in some particular cases, this operator can produce unexpected C0 geometry), if <em>SplitContinuity</em> is called, it is recommended to call it after <em>BSplineRestriction</em>. Continuity Values will be set as <em>GeomAbs_Shape</em> (i.e. C0 G1 C1 G2 C2 CN) besides direct integer values (resp. 0 1 2 3 4 5).</p>
<h3>SplitClosedFaces</h3>
<p>This operator splits faces, which are closed even if they are not revolutionary or cylindrical, conical, spherical, toroidal. This corresponds to BSpline or Bezier surfaces which can be closed (whether periodic or not), hence they have a seam edge. As a result, no more seam edges remain. The number of points allows to control the minimum count of faces to be produced per input closed face.</p>
<p>This operator can be called with the following parameters:</p><ul>
<li><em>Integer : NbSplitPoints</em> gives the number of points to use for splitting (the number of intervals produced is <em>NbSplitPoints+1</em>);</li>
<li><em>Real : CloseTolerance</em> tolerance used to determine if a face is closed;</li>
<li><em>Real : MaxTolerance</em> is used in the computation of splitting.</li>
</ul>
<h3>FixGaps</h3>
<p>This operator must be called when <em>FixFaceSize</em> and/or <em>DropSmallEdges</em> are called. Using Surface Healing may require an additional call to <em>BSplineRestriction</em> to ensure that modified geometries meet the requirements for BSpline. This operators repairs geometries which contain gaps between edges in wires (always performed) or gaps on faces, controlled by parameter <em>SurfaceMode</em>, Gaps on Faces are fixed by using algorithms of Surface Healing This operator can be called with the following parameters:</p><ul>
<li><em>Real : Tolerance3d</em> sets the tolerance to reach in 3d. If a gap is less than this value, it is not fixed.</li>
<li><em>Boolean : SurfaceMode</em> sets the mode of fixing gaps between edges and faces (yes/no) ;</li>
<li><em>Integer : SurfaceAddSpans</em> sets the number of spans to add to the surface in order to fix gaps ;</li>
<li><em>GeomAbs_Shape (C0 G1 C1 G2 C2 CN) : SurfaceContinuity</em> sets the minimal continuity of a resulting surface ;</li>
<li><em>Integer : NbIterations</em> sets the number of iterations</li>
<li><em>Real : Beta</em> sets the elasticity coefficient for modifying a surface [1-1000] ;</li>
<li><em>Reals : Coeff1 to Coeff6</em> sets energy coefficients for modifying a surface [0-10000] ;</li>
<li><em>Real : MaxDeflection</em> sets maximal deflection of surface from an old position.</li>
</ul>
<p>This operator may change the original geometry. In addition, it is CPU consuming, and it may fail in some cases. Also <b>FixGaps</b> can help only when there are gaps obtained as a result of removal of small edges that can be removed by <b>DropSmallEdges</b> or <b>FixFaceSize</b>.</p>
<h3>FixFaceSize</h3>
<p>This operator removes faces, which are small in all directions (spot face) or small in one direction (strip face). It can be called with the parameter <em>Real : Tolerance</em>, which sets the minimal dimension, which is used to consider a face, is small enough to be removed.</p>
<h3>DropSmallEdges</h3>
<p>This operator drops edges in a wire, and merges them with adjacent edges, when they are smaller than the given value (<em>Tolerance3d</em>) and when the topology allows such merging (i.e. same adjacent faces for each of the merged edges). Free (non-shared by adjacent faces) small edges can be also removed in case if they share the same vertex Parameters.</p>
<p>It can be called with the parameter <em>Real : Tolerance3d</em>, which sets the dimension used to determine if an edge is small.</p>
<h3>FixShape</h3>
<p>This operator may be added for fixing invalid shapes. It performs various checks and fixes, according to the modes listed hereafter. Management of a set of fixes can be performed by flags as follows:</p><ul>
<li>if the flag for a fixing tool is set to 0 , it is not performed;</li>
<li>if set to 1 , it is performed in any case;</li>
<li>if not set, or set to -1 , for each shape to be applied on, a check is done to evaluate whether a fix is needed. The fix is performed if the check is positive.</li>
</ul>
<p>By default, the flags are not set, the checks are carried out each individual shape.</p>
<p>This operator can be called with the following parameters:</p><ul>
<li><em>Real : Tolerance3d</em> sets basic tolerance used for fixing;</li>
<li><em>Real : MaxTolerance3d</em> sets maximum allowed value for the resulting tolerance;</li>
<li><em>Real : MinTolerance3d</em> sets minimum allowed value for the resulting tolerance.</li>
<li><em>Boolean : FixFreeShellMode</em></li>
<li><em>Boolean : FixFreeFaceMode</em></li>
<li><em>Boolean : FixFreeWireMode</em></li>
<li><em>Boolean : FixSameParameterMode</em></li>
<li><em>Boolean : FixSolidMode</em></li>
<li><em>Boolean : FixShellMode</em></li>
<li><em>Boolean : FixFaceMode</em></li>
<li><em>Boolean : FixWireMode</em></li>
<li><em>Boolean : FixOrientationMode</em></li>
<li><em>Boolean : FixMissingSeamMode</em></li>
<li><em>Boolean : FixSmallAreaWireMode</em></li>
<li><em>Boolean (not checked) : ModifyTopologyMode</em> specifies the mode for modifying topology. Should be False (default) for shapes with shells and can be True for free faces.</li>
<li><em>Boolean (not checked) : ModifyGeometryMode</em> specifies the mode for modifying geometry. Should be False if geometry is to be kept and True if it can be modified.</li>
<li><em>Boolean (not checked) : ClosedWireMode</em> specifies the mode for wires. Should be True for wires on faces and False for free wires.</li>
<li><em>Boolean (not checked) : PreferencePCurveMode (not used)</em> specifies the preference of 3d or 2d representations for an edge</li>
<li><em>Boolean : FixReorderMode</em></li>
<li><em>Boolean : FixSmallMode</em></li>
<li><em>Boolean : FixConnectedMode</em></li>
<li><em>Boolean : FixEdgeCurvesMode</em></li>
<li><em>Boolean : FixDegeneratedMode</em></li>
<li><em>Boolean : FixLackingMode</em></li>
<li><em>Boolean : FixSelfIntersectionMode</em></li>
<li><em>Boolean : FixGaps3dMode</em></li>
<li><em>Boolean : FixGaps2dMode</em></li>
<li><em>Boolean : FixReversed2dMode</em></li>
<li><em>Boolean : FixRemovePCurveMode</em></li>
<li><em>Boolean : FixRemoveCurve3dMode</em></li>
<li><em>Boolean : FixAddPCurveMode</em></li>
<li><em>Boolean : FixAddCurve3dMode</em></li>
<li><em>Boolean : FixSeamMode</em></li>
<li><em>Boolean : FixShiftedMode</em></li>
<li><em>Boolean : FixEdgeSameParameterMode</em></li>
<li><em>Boolean : FixSelfIntersectingEdgeMode</em></li>
<li><em>Boolean : FixIntersectingEdgesMode</em></li>
<li><em>Boolean : FixNonAdjacentIntersectingEdgesMode</em></li>
</ul>
<h3>SplitClosedEdges</h3>
<p>This operator handles closed edges i.e. edges with one vertex. Such edges are not supported in some receiving systems. This operator splits topologically closed edges (i.e. edges having one vertex) into two edges. Degenerated edges and edges with a size of less than Tolerance are not processed.</p>
<h1><a class="anchor" id="occt_shg_7"></a>
Messaging mechanism</h1>
<p>Various messages about modification, warnings and fails can be generated in the process of shape fixing or upgrade. The messaging mechanism allows generating messages, which will be sent to the chosen target medium a file or the screen. The messages may report failures and/or warnings or provide information on events such as analysis, fixing or upgrade of shapes.</p>
<h2><a class="anchor" id="occt_shg_7_1"></a>
Message Gravity</h2>
<p>Enumeration <em>Message_Gravity</em> is used for defining message gravity. It provides the following message statuses:</p><ul>
<li><em>Message_FAIL</em> &ndash; the message reports a fail;</li>
<li><em>Message_WARNING</em> &ndash; the message reports a warning;</li>
<li><em>Message_INFO</em> &ndash; the message supplies information.</li>
</ul>
<h2><a class="anchor" id="occt_shg_7_2"></a>
Tool for loading a message file into memory</h2>
<p>Class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message___msg_file.html">Message_MsgFile</a></em> allows defining messages by loading a custom message file into memory. It is necessary to create a custom message file before loading it into memory, as its path will be used as the argument to load it. Each message in the message file is identified by a key. The user can get the text content of the message by specifying the message key.</p>
<h3>Format of the message file</h3>
<p>The message file is an ASCII file, which defines a set of messages. Each line of the file must have a length of less than 255 characters. All lines in the file starting with the exclamation sign (perhaps preceded by spaces and/or tabs) are considered as comments and are ignored. A message file may contain several messages. Each message is identified by its key (string). Each line in the file starting with the <em>dot</em> character (perhaps preceded by spaces and/or tabs) defines the key. The key is a string starting with a symbol placed after the dot and ending with the symbol preceding the ending of the newline character <em>\n.</em> All lines in the file after the key and before the next keyword (and which are not comments) define the message for that key. If the message consists of several lines, the message string will contain newline symbols <em>\n</em> between each line (but not at the end).</p>
<p>The following example illustrates the structure of a message file:</p>
<div class="fragment"><div class="line">!This is a sample message file </div><div class="line">!------------------------------ </div><div class="line">!Messages for ShapeAnalysis package </div><div class="line">! </div><div class="line">.SampleKeyword </div><div class="line">Your message string goes here </div><div class="line">! </div><div class="line">!... </div><div class="line">! </div><div class="line">!End of the message file </div></div><!-- fragment --><h3>Loading the message file</h3>
<p>A custom file can be loaded into memory using the method <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message___msg_file.html#aed33163e1ede7c50e71585dd3794e9ea">Message_MsgFile::LoadFile</a></em>, taking as an argument the path to your file as in the example below: </p><div class="fragment"><div class="line">Standard_CString MsgFilePath = ;(path)/sample.file;; </div><div class="line">Message_MsgFile::LoadFile (MsgFilePath); </div></div><!-- fragment --><h2><a class="anchor" id="occt_shg_7_3"></a>
Tool for managing filling messages</h2>
<p>The class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message___msg.html">Message_Msg</a></em> allows using the message file loaded as a template. This class provides a tool for preparing the message, filling it with parameters, storing and outputting to the default trace file. A message is created from a key: this key identifies the message to be created in the message file. The text of the message is taken from the loaded message file (class <em><a class="elRef" doxygen="C:/builds/IR-2017-08-29_IR-2017-08-29/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_message___msg_file.html">Message_MsgFile</a></em> is used). The text of the message can contain places for parameters, which are to be filled by the proper values when the message is prepared. These parameters can be of the following types:</p><ul>
<li>string &ndash; coded in the text as %s,</li>
<li>integer &ndash; coded in the text as %d,</li>
<li>real &ndash; coded in the text as %f. The parameter fields are filled by the message text by calling the corresponding methods <em>AddInteger, AddReal</em> and <em>AddString</em>. Both the original text of the message and the input text with substituted parameters are stored in the object. The prepared and filled message can be output to the default trace file. The text of the message (either original or filled) can be also obtained. <div class="fragment"><div class="line">Message_Msg msg01 (;SampleKeyword;); </div><div class="line">//Creates the message msg01, identified in the file by the keyword SampleKeyword </div><div class="line">msg1.AddInteger (73); </div><div class="line">msg1.AddString (;SampleFile;); </div><div class="line">//fills out the code areas </div></div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="occt_shg_7_4"></a>
Tool for managing trace files</h2>
<p>Class <em>Message_TraceFile</em> is intended to manage the trace file (or stream) for outputting messages and the current trace level. Trace level is an integer number, which is used when messages are sent. Generally, 0 means minimum, &gt; 0 various levels. If the current trace level is lower than the level of the message it is not output to the trace file. The trace level is to be managed and used by the users. There are two ways of using trace files:</p><ul>
<li>define an object of <em>Message_TraceFile</em>, with its own definition (file name or cout, trace level), and use it where it is defined,</li>
<li>use the default trace file (file name or cout, trace level), usable from anywhere. Use the constructor method to define the target file and the level of the messages as in the example below: <div class="fragment"><div class="line">Message_TraceFile myTF </div><div class="line">    (tracelevel, &quot;tracefile.log&quot;, Standard_False); </div></div><!-- fragment --> The parameters are as follows:</li>
<li><em>tracelevel</em> is a Standard_Integer and modifies the level of messages. It has the following values and semantics:<ul>
<li>0: gives general information such as the start and end of process;</li>
<li>1: gives exceptions raised and fail messages;</li>
<li>2: gives the same information as 1 plus warning messages.</li>
</ul>
</li>
<li><em>filename</em> is the string containing the path to the log file. The Boolean set to False will rewrite the existing file. When set to True, new messages will be appended to the existing file.</li>
</ul>
<p>A new default log file can be added using method <em>SetDefault</em> with the same arguments as in the constructor. The default trace level can be changed by using method <em>SetDefLevel</em>. In this way, the information received in the log file is modified. It is possible to close the log file and set the default trace output to the screen display instead of the log file using the method <em>SetDefault</em> without any arguments. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 30 2017 17:08:50 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
