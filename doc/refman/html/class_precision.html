<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Precision Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Open CASCADE Technology</a></li><li class="navelem"><a class="el" href="module_foundationclasses.html">Module FoundationClasses</a></li><li class="navelem"><a class="el" href="toolkit_tkmath.html">Toolkit TKMath</a></li>    <li class="navelem"><a class="el" href="package_precision.html">Package Precision </a>      </li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Precision Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package offers a set of functions defining precision criteria for use in conventional situations when comparing two numbers. Generalities It is not advisable to use floating number equality. Instead, the difference between numbers must be compared with a given precision, i.e. : Standard_Real x1, x2 ; x1 = ... x2 = ... If ( x1 == x2 ) ... should not be used and must be written as indicated below: Standard_Real x1, x2 ; Standard_Real <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> = ... x1 = ... x2 = ... If ( Abs ( x1 - x2 ) &lt; <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> ) ... Likewise, when ordering floating numbers, you must take the following into account : Standard_Real x1, x2 ; Standard_Real <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> = ... x1 = ... ! a large number x2 = ... ! another large number If ( x1 &lt; x2 - <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> ) ... is incorrect when x1 and x2 are large numbers ; it is better to write : Standard_Real x1, x2 ; Standard_Real <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> = ... x1 = ... ! a large number x2 = ... ! another large number If ( x2 - x1 &gt; <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> ) ... <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> in Cas.Cade Generally speaking, the precision criterion is not implicit in Cas.Cade. Low-level geometric algorithms accept precision criteria as arguments. As a rule, they should not refer directly to the precision criteria provided by the <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package. On the other hand, high-level modeling algorithms have to provide the low-level geometric algorithms that they call, with a precision criteria. One way of doing this is to use the above precision criteria. Alternatively, the high-level algorithms can have their own system for precision management. For example, the Topology Data Structure stores precision criteria for each elementary shape (as a vertex, an edge or a face). When a new topological object is constructed, the precision criteria are taken from those provided by the <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package, and stored in the related data structure. Later, a topological algorithm which analyses these objects will work with the values stored in the data structure. Also, if this algorithm is to build a new topological object, from these precision criteria, it will compute a new precision criterion for the new topological object, and write it into the data structure of the new topological object. The different precision criteria offered by the <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package, cover the most common requirements of geometric algorithms, such as intersections, approximations, and so on. The choice of precision depends on the algorithm and on the geometric space. The geometric space may be :  
 <a href="class_precision.html#details">More...</a></p>

<p><code>#include &lt;Precision.hxx&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a873857668aabfc6c21da9bdc78464a3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f">Angular</a> ()</td></tr>
<tr class="memdesc:a873857668aabfc6c21da9bdc78464a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recommended precision value when checking the equality of two angles (given in radians). Standard_Real Angle1 = ... , Angle2 = ... ; If ( Abs( Angle2 - Angle1 ) &lt; <a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f" title="Returns the recommended precision value when checking the equality of two angles (given in radians)...">Precision::Angular()</a> ) ... The tolerance of angular equality may be used to check the parallelism of two vectors : <a class="el" href="classgp___vec.html" title="Defines a non-persistent vector in 3D space. ">gp_Vec</a> V1, V2 ; V1 = ... V2 = ... If ( V1.IsParallel (V2, <a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f" title="Returns the recommended precision value when checking the equality of two angles (given in radians)...">Precision::Angular()</a> ) ) ... The tolerance of angular equality is equal to 1.e-12. Note : The tolerance of angular equality can be used when working with scalar products or cross products since sines and angles are equivalent for small angles. Therefore, in order to check whether two unit vectors are perpendicular : <a class="el" href="classgp___dir.html" title="Describes a unit vector in 3D space. This unit vector is also called &quot;Direction&quot;. See Also gce_MakeDi...">gp_Dir</a> D1, D2 ; D1 = ... D2 = ... you can use : If ( Abs( D1.D2 ) &lt; <a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f" title="Returns the recommended precision value when checking the equality of two angles (given in radians)...">Precision::Angular()</a> ) ... (although the function IsNormal does exist).  <a href="#a873857668aabfc6c21da9bdc78464a3f">More...</a><br /></td></tr>
<tr class="separator:a873857668aabfc6c21da9bdc78464a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8d5777a3e8e1c61bd7bbfa8dfc0eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb">Confusion</a> ()</td></tr>
<tr class="memdesc:a94f8d5777a3e8e1c61bd7bbfa8dfc0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recommended precision value when checking coincidence of two points in real space. The tolerance of confusion is used for testing a 3D distance :  <a href="#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb">More...</a><br /></td></tr>
<tr class="separator:a94f8d5777a3e8e1c61bd7bbfa8dfc0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0986f1b7ec6c20f4c4fef597d9652967"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a0986f1b7ec6c20f4c4fef597d9652967">SquareConfusion</a> ()</td></tr>
<tr class="memdesc:a0986f1b7ec6c20f4c4fef597d9652967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns square of Confusion. Created for speed and convenience.  <a href="#a0986f1b7ec6c20f4c4fef597d9652967">More...</a><br /></td></tr>
<tr class="separator:a0986f1b7ec6c20f4c4fef597d9652967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f1ffc4997b51dbe5d3fa41e0110bd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a89f1ffc4997b51dbe5d3fa41e0110bd2">Intersection</a> ()</td></tr>
<tr class="memdesc:a89f1ffc4997b51dbe5d3fa41e0110bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the precision value in real space, frequently used by intersection algorithms to decide that a solution is reached. This function provides an acceptable level of precision for an intersection process to define the adjustment limits. The tolerance of intersection is designed to ensure that a point computed by an iterative algorithm as the intersection between two curves is indeed on the intersection. It is obvious that two tangent curves are close to each other, on a large distance. An iterative algorithm of intersection may find points on these curves within the scope of the confusion tolerance, but still far from the true intersection point. In order to force the intersection algorithm to continue the iteration process until a correct point is found on the tangent objects, the tolerance of intersection must be smaller than the tolerance of confusion. On the other hand, the tolerance of intersection must be large enough to minimize the time required by the process to converge to a solution. The tolerance of intersection is equal to : <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> / 100. (that is, 1.e-9).  <a href="#a89f1ffc4997b51dbe5d3fa41e0110bd2">More...</a><br /></td></tr>
<tr class="separator:a89f1ffc4997b51dbe5d3fa41e0110bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace65a7f280a4d6806ac286231c8c0691"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#ace65a7f280a4d6806ac286231c8c0691">Approximation</a> ()</td></tr>
<tr class="memdesc:ace65a7f280a4d6806ac286231c8c0691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the precision value in real space, frequently used by approximation algorithms. This function provides an acceptable level of precision for an approximation process to define adjustment limits. The tolerance of approximation is designed to ensure an acceptable computation time when performing an approximation process. That is why the tolerance of approximation is greater than the tolerance of confusion. The tolerance of approximation is equal to : <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> * 10. (that is, 1.e-6). You may use a smaller tolerance in an approximation algorithm, but this option might be costly.  <a href="#ace65a7f280a4d6806ac286231c8c0691">More...</a><br /></td></tr>
<tr class="separator:ace65a7f280a4d6806ac286231c8c0691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae170397aa9ab7e1046827421a07f3fca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#ae170397aa9ab7e1046827421a07f3fca">Parametric</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> T)</td></tr>
<tr class="memdesc:ae170397aa9ab7e1046827421a07f3fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a real space precision to a parametric space precision. &lt;T&gt; is the mean value of the length of the tangent of the curve or the surface.  <a href="#ae170397aa9ab7e1046827421a07f3fca">More...</a><br /></td></tr>
<tr class="separator:ae170397aa9ab7e1046827421a07f3fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358a8cdc2a1d4a8169b53f717002023d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a358a8cdc2a1d4a8169b53f717002023d">PConfusion</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> T)</td></tr>
<tr class="memdesc:a358a8cdc2a1d4a8169b53f717002023d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a precision value in parametric space, which may be used :  <a href="#a358a8cdc2a1d4a8169b53f717002023d">More...</a><br /></td></tr>
<tr class="separator:a358a8cdc2a1d4a8169b53f717002023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34145217448667a402b12f2fa974fb5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#ae34145217448667a402b12f2fa974fb5">SquarePConfusion</a> ()</td></tr>
<tr class="memdesc:ae34145217448667a402b12f2fa974fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns square of PConfusion. Created for speed and convenience.  <a href="#ae34145217448667a402b12f2fa974fb5">More...</a><br /></td></tr>
<tr class="separator:ae34145217448667a402b12f2fa974fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444d677fcd4ef847dc8552740461a32d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a444d677fcd4ef847dc8552740461a32d">PIntersection</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> T)</td></tr>
<tr class="memdesc:a444d677fcd4ef847dc8552740461a32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a precision value in parametric space, which may be used by intersection algorithms, to decide that a solution is reached. The purpose of this function is to provide an acceptable level of precision in parametric space, for an intersection process to define the adjustment limits. The parametric tolerance of intersection is designed to give a mean value in relation with the dimension of the curve or the surface. It considers that a variation of parameter equal to 1. along a curve (or an isoparametric curve of a surface) generates a segment whose length is equal to 100. (default value), or T. The parametric tolerance of intersection is equal to :  <a href="#a444d677fcd4ef847dc8552740461a32d">More...</a><br /></td></tr>
<tr class="separator:a444d677fcd4ef847dc8552740461a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c88ceb5b4084a85455df7087d8e171"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#aa7c88ceb5b4084a85455df7087d8e171">PApproximation</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> T)</td></tr>
<tr class="memdesc:aa7c88ceb5b4084a85455df7087d8e171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a precision value in parametric space, which may be used by approximation algorithms. The purpose of this function is to provide an acceptable level of precision in parametric space, for an approximation process to define the adjustment limits. The parametric tolerance of approximation is designed to give a mean value in relation with the dimension of the curve or the surface. It considers that a variation of parameter equal to 1. along a curve (or an isoparametric curve of a surface) generates a segment whose length is equal to 100. (default value), or T. The parametric tolerance of intersection is equal to :  <a href="#aa7c88ceb5b4084a85455df7087d8e171">More...</a><br /></td></tr>
<tr class="separator:aa7c88ceb5b4084a85455df7087d8e171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab721114d0166400e4f1ca4dd6bd0cdb9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#ab721114d0166400e4f1ca4dd6bd0cdb9">Parametric</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> P)</td></tr>
<tr class="memdesc:ab721114d0166400e4f1ca4dd6bd0cdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a real space precision to a parametric space precision on a default curve.  <a href="#ab721114d0166400e4f1ca4dd6bd0cdb9">More...</a><br /></td></tr>
<tr class="separator:ab721114d0166400e4f1ca4dd6bd0cdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7430591942a5dd09f285176145f3236c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c">PConfusion</a> ()</td></tr>
<tr class="memdesc:a7430591942a5dd09f285176145f3236c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to test distances in parametric space on a default curve.  <a href="#a7430591942a5dd09f285176145f3236c">More...</a><br /></td></tr>
<tr class="separator:a7430591942a5dd09f285176145f3236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12204da3acc871ddb2adb4b72a258a97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a12204da3acc871ddb2adb4b72a258a97">PIntersection</a> ()</td></tr>
<tr class="memdesc:a12204da3acc871ddb2adb4b72a258a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for Intersections in parametric space on a default curve.  <a href="#a12204da3acc871ddb2adb4b72a258a97">More...</a><br /></td></tr>
<tr class="separator:a12204da3acc871ddb2adb4b72a258a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5f897520090072f9723c2de4607c97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a0f5f897520090072f9723c2de4607c97">PApproximation</a> ()</td></tr>
<tr class="memdesc:a0f5f897520090072f9723c2de4607c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for Approximations in parametric space on a default curve.  <a href="#a0f5f897520090072f9723c2de4607c97">More...</a><br /></td></tr>
<tr class="separator:a0f5f897520090072f9723c2de4607c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7309806c042ca49a60e84250294893d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#ac7309806c042ca49a60e84250294893d">IsInfinite</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> R)</td></tr>
<tr class="memdesc:ac7309806c042ca49a60e84250294893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if R may be considered as an infinite number. Currently Abs(R) &gt; 1e100.  <a href="#ac7309806c042ca49a60e84250294893d">More...</a><br /></td></tr>
<tr class="separator:ac7309806c042ca49a60e84250294893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977b747b3b5afc26ff6398f7595c138e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a977b747b3b5afc26ff6398f7595c138e">IsPositiveInfinite</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> R)</td></tr>
<tr class="memdesc:a977b747b3b5afc26ff6398f7595c138e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if R may be considered as a positive infinite number. Currently R &gt; 1e100.  <a href="#a977b747b3b5afc26ff6398f7595c138e">More...</a><br /></td></tr>
<tr class="separator:a977b747b3b5afc26ff6398f7595c138e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56420db53fee947a8004a606e719e3b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a56420db53fee947a8004a606e719e3b7">IsNegativeInfinite</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> R)</td></tr>
<tr class="memdesc:a56420db53fee947a8004a606e719e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if R may be considered as a negative infinite number. Currently R &lt; -1e100.  <a href="#a56420db53fee947a8004a606e719e3b7">More...</a><br /></td></tr>
<tr class="separator:a56420db53fee947a8004a606e719e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017cf56f9e5dcb39bed601365e4d1021"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_precision.html#a017cf56f9e5dcb39bed601365e4d1021">Infinite</a> ()</td></tr>
<tr class="memdesc:a017cf56f9e5dcb39bed601365e4d1021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a big number that can be considered as infinite. Use -Infinite() for a negative big number.  <a href="#a017cf56f9e5dcb39bed601365e4d1021">More...</a><br /></td></tr>
<tr class="separator:a017cf56f9e5dcb39bed601365e4d1021"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package offers a set of functions defining precision criteria for use in conventional situations when comparing two numbers. Generalities It is not advisable to use floating number equality. Instead, the difference between numbers must be compared with a given precision, i.e. : Standard_Real x1, x2 ; x1 = ... x2 = ... If ( x1 == x2 ) ... should not be used and must be written as indicated below: Standard_Real x1, x2 ; Standard_Real <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> = ... x1 = ... x2 = ... If ( Abs ( x1 - x2 ) &lt; <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> ) ... Likewise, when ordering floating numbers, you must take the following into account : Standard_Real x1, x2 ; Standard_Real <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> = ... x1 = ... ! a large number x2 = ... ! another large number If ( x1 &lt; x2 - <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> ) ... is incorrect when x1 and x2 are large numbers ; it is better to write : Standard_Real x1, x2 ; Standard_Real <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> = ... x1 = ... ! a large number x2 = ... ! another large number If ( x2 - x1 &gt; <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> ) ... <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> in Cas.Cade Generally speaking, the precision criterion is not implicit in Cas.Cade. Low-level geometric algorithms accept precision criteria as arguments. As a rule, they should not refer directly to the precision criteria provided by the <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package. On the other hand, high-level modeling algorithms have to provide the low-level geometric algorithms that they call, with a precision criteria. One way of doing this is to use the above precision criteria. Alternatively, the high-level algorithms can have their own system for precision management. For example, the Topology Data Structure stores precision criteria for each elementary shape (as a vertex, an edge or a face). When a new topological object is constructed, the precision criteria are taken from those provided by the <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package, and stored in the related data structure. Later, a topological algorithm which analyses these objects will work with the values stored in the data structure. Also, if this algorithm is to build a new topological object, from these precision criteria, it will compute a new precision criterion for the new topological object, and write it into the data structure of the new topological object. The different precision criteria offered by the <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package, cover the most common requirements of geometric algorithms, such as intersections, approximations, and so on. The choice of precision depends on the algorithm and on the geometric space. The geometric space may be : </p>
<ul>
<li>a "real" 2D or 3D space, where the lengths are measured in meters, millimeters, microns, inches, etc ..., or</li>
<li>a "parametric" space, 1D on a curve or 2D on a surface, where lengths have no dimension. The choice of precision criteria for real space depends on the choice of the product, as it is based on the accuracy of the machine and the unit of measurement. The choice of precision criteria for parametric space depends on both the accuracy of the machine and the dimensions of the curve or the surface, since the parametric precision criterion and the real precision criterion are linked : if the curve is defined by the equation P(t), the inequation : Abs ( t2 - t1 ) &lt; ParametricPrecision means that the parameters t1 and t2 are considered to be equal, and the inequation : Distance ( P(t2) , P(t1) ) &lt; RealPrecision means that the points P(t1) and P(t2) are considered to be coincident. It seems to be the same idea, and it would be wonderful if these two inequations were equivalent. Note that this is rarely the case ! What is provided in this package? The <a class="el" href="class_precision.html" title="The Precision package offers a set of functions defining precision criteria for use in conventional s...">Precision</a> package provides :</li>
<li>a set of real space precision criteria for the algorithms, in view of checking distances and angles,</li>
<li>a set of parametric space precision criteria for the algorithms, in view of checking both :</li>
<li>the equality of parameters in a parametric space,</li>
<li>or the coincidence of points in the real space, by using parameter values,</li>
<li>the notion of infinite value, composed of a value assumed to be infinite, and checking tests designed to verify if any value could be considered as infinite. All the provided functions are very simple. The returned values result from the adaptation of the applications developed by the Open CASCADE company to Open CASCADE algorithms. The main interest of these functions lies in that it incites engineers developing applications to ask questions on precision factors. Which one is to be used in such or such case ? Tolerance criteria are context dependent. They must first choose :</li>
<li>either to work in real space,</li>
<li>or to work in parametric space,</li>
<li>or to work in a combined real and parametric space. They must next decide which precision factor will give the best answer to the current problem. Within an application environment, it is crucial to master precision even though this process may take a great deal of time. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a873857668aabfc6c21da9bdc78464a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873857668aabfc6c21da9bdc78464a3f">&#9670;&nbsp;</a></span>Angular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Angular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the recommended precision value when checking the equality of two angles (given in radians). Standard_Real Angle1 = ... , Angle2 = ... ; If ( Abs( Angle2 - Angle1 ) &lt; <a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f" title="Returns the recommended precision value when checking the equality of two angles (given in radians)...">Precision::Angular()</a> ) ... The tolerance of angular equality may be used to check the parallelism of two vectors : <a class="el" href="classgp___vec.html" title="Defines a non-persistent vector in 3D space. ">gp_Vec</a> V1, V2 ; V1 = ... V2 = ... If ( V1.IsParallel (V2, <a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f" title="Returns the recommended precision value when checking the equality of two angles (given in radians)...">Precision::Angular()</a> ) ) ... The tolerance of angular equality is equal to 1.e-12. Note : The tolerance of angular equality can be used when working with scalar products or cross products since sines and angles are equivalent for small angles. Therefore, in order to check whether two unit vectors are perpendicular : <a class="el" href="classgp___dir.html" title="Describes a unit vector in 3D space. This unit vector is also called &quot;Direction&quot;. See Also gce_MakeDi...">gp_Dir</a> D1, D2 ; D1 = ... D2 = ... you can use : If ( Abs( D1.D2 ) &lt; <a class="el" href="class_precision.html#a873857668aabfc6c21da9bdc78464a3f" title="Returns the recommended precision value when checking the equality of two angles (given in radians)...">Precision::Angular()</a> ) ... (although the function IsNormal does exist). </p>

</div>
</div>
<a id="ace65a7f280a4d6806ac286231c8c0691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace65a7f280a4d6806ac286231c8c0691">&#9670;&nbsp;</a></span>Approximation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Approximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the precision value in real space, frequently used by approximation algorithms. This function provides an acceptable level of precision for an approximation process to define adjustment limits. The tolerance of approximation is designed to ensure an acceptable computation time when performing an approximation process. That is why the tolerance of approximation is greater than the tolerance of confusion. The tolerance of approximation is equal to : <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> * 10. (that is, 1.e-6). You may use a smaller tolerance in an approximation algorithm, but this option might be costly. </p>

</div>
</div>
<a id="a94f8d5777a3e8e1c61bd7bbfa8dfc0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb">&#9670;&nbsp;</a></span>Confusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Confusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the recommended precision value when checking coincidence of two points in real space. The tolerance of confusion is used for testing a 3D distance : </p>
<ul>
<li>Two points are considered to be coincident if their distance is smaller than the tolerance of confusion. <a class="el" href="classgp___pnt.html" title="Defines a 3D cartesian point. ">gp_Pnt</a> P1, P2 ; P1 = ... P2 = ... if ( P1.IsEqual ( P2 , <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> ) ) then ...</li>
<li>A vector is considered to be null if it has a null length : <a class="el" href="classgp___vec.html" title="Defines a non-persistent vector in 3D space. ">gp_Vec</a> V ; V = ... if ( V.Magnitude() &lt; <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> ) then ... The tolerance of confusion is equal to 1.e-7. The value of the tolerance of confusion is also used to define :</li>
<li>the tolerance of intersection, and</li>
<li>the tolerance of approximation. Note : As a rule, coordinate values in Cas.Cade are not dimensioned, so 1. represents one user unit, whatever value the unit may have : the millimeter, the meter, the inch, or any other unit. Let's say that Cas.Cade algorithms are written to be tuned essentially with mechanical design applications, on the basis of the millimeter. However, these algorithms may be used with any other unit but the tolerance criterion does no longer have the same signification. So pay particular attention to the type of your application, in relation with the impact of your unit on the precision criterion.</li>
<li>For example in mechanical design, if the unit is the millimeter, the tolerance of confusion corresponds to a distance of 1 / 10000 micron, which is rather difficult to measure.</li>
<li>However in other types of applications, such as cartography, where the kilometer is frequently used, the tolerance of confusion corresponds to a greater distance (1 / 10 millimeter). This distance becomes easily measurable, but only within a restricted space which contains some small objects of the complete scene. </li>
</ul>

</div>
</div>
<a id="a017cf56f9e5dcb39bed601365e4d1021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017cf56f9e5dcb39bed601365e4d1021">&#9670;&nbsp;</a></span>Infinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Infinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a big number that can be considered as infinite. Use -Infinite() for a negative big number. </p>

</div>
</div>
<a id="a89f1ffc4997b51dbe5d3fa41e0110bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f1ffc4997b51dbe5d3fa41e0110bd2">&#9670;&nbsp;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Intersection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the precision value in real space, frequently used by intersection algorithms to decide that a solution is reached. This function provides an acceptable level of precision for an intersection process to define the adjustment limits. The tolerance of intersection is designed to ensure that a point computed by an iterative algorithm as the intersection between two curves is indeed on the intersection. It is obvious that two tangent curves are close to each other, on a large distance. An iterative algorithm of intersection may find points on these curves within the scope of the confusion tolerance, but still far from the true intersection point. In order to force the intersection algorithm to continue the iteration process until a correct point is found on the tangent objects, the tolerance of intersection must be smaller than the tolerance of confusion. On the other hand, the tolerance of intersection must be large enough to minimize the time required by the process to converge to a solution. The tolerance of intersection is equal to : <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> / 100. (that is, 1.e-9). </p>

</div>
</div>
<a id="ac7309806c042ca49a60e84250294893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7309806c042ca49a60e84250294893d">&#9670;&nbsp;</a></span>IsInfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Precision::IsInfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if R may be considered as an infinite number. Currently Abs(R) &gt; 1e100. </p>

</div>
</div>
<a id="a56420db53fee947a8004a606e719e3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56420db53fee947a8004a606e719e3b7">&#9670;&nbsp;</a></span>IsNegativeInfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Precision::IsNegativeInfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if R may be considered as a negative infinite number. Currently R &lt; -1e100. </p>

</div>
</div>
<a id="a977b747b3b5afc26ff6398f7595c138e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977b747b3b5afc26ff6398f7595c138e">&#9670;&nbsp;</a></span>IsPositiveInfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> Precision::IsPositiveInfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if R may be considered as a positive infinite number. Currently R &gt; 1e100. </p>

</div>
</div>
<a id="aa7c88ceb5b4084a85455df7087d8e171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c88ceb5b4084a85455df7087d8e171">&#9670;&nbsp;</a></span>PApproximation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::PApproximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a precision value in parametric space, which may be used by approximation algorithms. The purpose of this function is to provide an acceptable level of precision in parametric space, for an approximation process to define the adjustment limits. The parametric tolerance of approximation is designed to give a mean value in relation with the dimension of the curve or the surface. It considers that a variation of parameter equal to 1. along a curve (or an isoparametric curve of a surface) generates a segment whose length is equal to 100. (default value), or T. The parametric tolerance of intersection is equal to : </p>
<ul>
<li><a class="el" href="class_precision.html#ace65a7f280a4d6806ac286231c8c0691" title="Returns the precision value in real space, frequently used by approximation algorithms. This function provides an acceptable level of precision for an approximation process to define adjustment limits. The tolerance of approximation is designed to ensure an acceptable computation time when performing an approximation process. That is why the tolerance of approximation is greater than the tolerance of confusion. The tolerance of approximation is equal to : Precision::Confusion() * 10. (that is, 1.e-6). You may use a smaller tolerance in an approximation algorithm, but this option might be costly. ">Precision::Approximation()</a> / 100., or <a class="el" href="class_precision.html#ace65a7f280a4d6806ac286231c8c0691" title="Returns the precision value in real space, frequently used by approximation algorithms. This function provides an acceptable level of precision for an approximation process to define adjustment limits. The tolerance of approximation is designed to ensure an acceptable computation time when performing an approximation process. That is why the tolerance of approximation is greater than the tolerance of confusion. The tolerance of approximation is equal to : Precision::Confusion() * 10. (that is, 1.e-6). You may use a smaller tolerance in an approximation algorithm, but this option might be costly. ">Precision::Approximation()</a> / T. </li>
</ul>

</div>
</div>
<a id="a0f5f897520090072f9723c2de4607c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5f897520090072f9723c2de4607c97">&#9670;&nbsp;</a></span>PApproximation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::PApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for Approximations in parametric space on a default curve. </p>
<p>This is Precision::Parametric(Precision::Approximation()) </p>

</div>
</div>
<a id="ae170397aa9ab7e1046827421a07f3fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae170397aa9ab7e1046827421a07f3fca">&#9670;&nbsp;</a></span>Parametric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Parametric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a real space precision to a parametric space precision. &lt;T&gt; is the mean value of the length of the tangent of the curve or the surface. </p>
<p>Value is P / T </p>

</div>
</div>
<a id="ab721114d0166400e4f1ca4dd6bd0cdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab721114d0166400e4f1ca4dd6bd0cdb9">&#9670;&nbsp;</a></span>Parametric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::Parametric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a real space precision to a parametric space precision on a default curve. </p>
<p>Value is Parametric(P,1.e+2) </p>

</div>
</div>
<a id="a358a8cdc2a1d4a8169b53f717002023d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358a8cdc2a1d4a8169b53f717002023d">&#9670;&nbsp;</a></span>PConfusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::PConfusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a precision value in parametric space, which may be used : </p>
<ul>
<li>to test the coincidence of two points in the real space, by using parameter values, or</li>
<li>to test the equality of two parameter values in a parametric space. The parametric tolerance of confusion is designed to give a mean value in relation with the dimension of the curve or the surface. It considers that a variation of parameter equal to 1. along a curve (or an isoparametric curve of a surface) generates a segment whose length is equal to 100. (default value), or T. The parametric tolerance of confusion is equal to :</li>
<li><a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> / 100., or <a class="el" href="class_precision.html#a94f8d5777a3e8e1c61bd7bbfa8dfc0eb" title="Returns the recommended precision value when checking coincidence of two points in real space...">Precision::Confusion()</a> / T. The value of the parametric tolerance of confusion is also used to define :</li>
<li>the parametric tolerance of intersection, and</li>
<li>the parametric tolerance of approximation. Warning It is rather difficult to define a unique precision value in parametric space.</li>
<li>First consider a curve (c) ; if M is the point of parameter u and M' the point of parameter u+du on the curve, call 'parametric tangent' at point M, for the variation du of the parameter, the quantity : T(u,du)=MM'/du (where MM' represents the distance between the two points M and M', in the real space).</li>
<li>Consider the other curve resulting from a scaling transformation of (c) with a scale factor equal to</li>
</ul>
<ol type="1">
<li>The 'parametric tangent' at the point of parameter u of this curve is ten times greater than the previous one. This shows that for two different curves, the distance between two points on the curve, resulting from the same variation of parameter du, may vary considerably.</li>
</ol>
<ul>
<li>Moreover, the variation of the parameter along the curve is generally not proportional to the curvilinear abscissa along the curve. So the distance between two points resulting from the same variation of parameter du, at two different points of a curve, may completely differ.</li>
<li>Moreover, the parameterization of a surface may generate two quite different 'parametric tangent' values in the u or in the v parametric direction.</li>
<li>Last, close to the poles of a sphere (the points which correspond to the values -Pi/2. and Pi/2. of the v parameter) the u parameter may change from 0 to 2.Pi without impacting on the resulting point. Therefore, take great care when adjusting a parametric tolerance to your own algorithm. </li>
</ul>

</div>
</div>
<a id="a7430591942a5dd09f285176145f3236c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7430591942a5dd09f285176145f3236c">&#9670;&nbsp;</a></span>PConfusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::PConfusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to test distances in parametric space on a default curve. </p>
<p>This is Precision::Parametric(Precision::Confusion()) </p>

</div>
</div>
<a id="a444d677fcd4ef847dc8552740461a32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444d677fcd4ef847dc8552740461a32d">&#9670;&nbsp;</a></span>PIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::PIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a precision value in parametric space, which may be used by intersection algorithms, to decide that a solution is reached. The purpose of this function is to provide an acceptable level of precision in parametric space, for an intersection process to define the adjustment limits. The parametric tolerance of intersection is designed to give a mean value in relation with the dimension of the curve or the surface. It considers that a variation of parameter equal to 1. along a curve (or an isoparametric curve of a surface) generates a segment whose length is equal to 100. (default value), or T. The parametric tolerance of intersection is equal to : </p>
<ul>
<li><a class="el" href="class_precision.html#a89f1ffc4997b51dbe5d3fa41e0110bd2" title="Returns the precision value in real space, frequently used by intersection algorithms to decide that ...">Precision::Intersection()</a> / 100., or <a class="el" href="class_precision.html#a89f1ffc4997b51dbe5d3fa41e0110bd2" title="Returns the precision value in real space, frequently used by intersection algorithms to decide that ...">Precision::Intersection()</a> / T. </li>
</ul>

</div>
</div>
<a id="a12204da3acc871ddb2adb4b72a258a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12204da3acc871ddb2adb4b72a258a97">&#9670;&nbsp;</a></span>PIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::PIntersection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for Intersections in parametric space on a default curve. </p>
<p>This is Precision::Parametric(Precision::Intersection()) </p>

</div>
</div>
<a id="a0986f1b7ec6c20f4c4fef597d9652967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0986f1b7ec6c20f4c4fef597d9652967">&#9670;&nbsp;</a></span>SquareConfusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::SquareConfusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns square of Confusion. Created for speed and convenience. </p>

</div>
</div>
<a id="ae34145217448667a402b12f2fa974fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34145217448667a402b12f2fa974fb5">&#9670;&nbsp;</a></span>SquarePConfusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Precision::SquarePConfusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns square of PConfusion. Created for speed and convenience. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_precision_8hxx.html">Precision.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

