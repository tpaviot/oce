<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: CSLib Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Open CASCADE Technology</a></li><li class="navelem"><a class="el" href="module_foundationclasses.html">Module FoundationClasses</a></li><li class="navelem"><a class="el" href="toolkit_tkmath.html">Toolkit TKMath</a></li>    <li class="navelem"><a class="el" href="package_cslib.html">Package CSLib </a>      </li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CSLib Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This package implements functions for basis geometric computation on curves and surfaces. The tolerance criterions used in this package are Resolution from package gp and RealEpsilon from class Real of package <a class="el" href="class_standard.html" title="The package Standard provides global memory allocator and other basic services used by other OCCT com...">Standard</a>.  
 <a href="class_c_s_lib.html#details">More...</a></p>

<p><code>#include &lt;CSLib.hxx&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab6c92e11874e821a4b6be3f7859e18b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#ab6c92e11874e821a4b6be3f7859e18b6">Normal</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> SinTol, <a class="el" href="_c_s_lib___derivative_status_8hxx.html#ac25c8dfe2d5d06f0f25b9907cfc1f853">CSLib_DerivativeStatus</a> &amp;theStatus, <a class="el" href="classgp___dir.html">gp_Dir</a> &amp;Normal)</td></tr>
<tr class="memdesc:ab6c92e11874e821a4b6be3f7859e18b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions computes the normal to a surface inherits FunctionWithDerivative from math.  <a href="#ab6c92e11874e821a4b6be3f7859e18b6">More...</a><br /></td></tr>
<tr class="separator:ab6c92e11874e821a4b6be3f7859e18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afa1fb092dce089d9d5ba9f3d08dc17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#a1afa1fb092dce089d9d5ba9f3d08dc17">Normal</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> SinTol, <a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> &amp;Done, <a class="el" href="_c_s_lib___normal_status_8hxx.html#a7ea38358d50994511e84e965ee4a0ca5">CSLib_NormalStatus</a> &amp;theStatus, <a class="el" href="classgp___dir.html">gp_Dir</a> &amp;Normal)</td></tr>
<tr class="memdesc:a1afa1fb092dce089d9d5ba9f3d08dc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps-&gt;0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv||.  <a href="#a1afa1fb092dce089d9d5ba9f3d08dc17">More...</a><br /></td></tr>
<tr class="separator:a1afa1fb092dce089d9d5ba9f3d08dc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f977764da86cc141ea1c9515f87dd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#a61f977764da86cc141ea1c9515f87dd9">Normal</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> MagTol, <a class="el" href="_c_s_lib___normal_status_8hxx.html#a7ea38358d50994511e84e965ee4a0ca5">CSLib_NormalStatus</a> &amp;theStatus, <a class="el" href="classgp___dir.html">gp_Dir</a> &amp;Normal)</td></tr>
<tr class="memdesc:a61f977764da86cc141ea1c9515f87dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normal direction of a surface as the cross product between D1U and D1V.  <a href="#a61f977764da86cc141ea1c9515f87dd9">More...</a><br /></td></tr>
<tr class="separator:a61f977764da86cc141ea1c9515f87dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53832beed9902420479041ff397b00be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#a53832beed9902420479041ff397b00be">Normal</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> MaxOrder, const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;DerNUV, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> MagTol, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Umin, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Umax, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Vmin, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Vmax, <a class="el" href="_c_s_lib___normal_status_8hxx.html#a7ea38358d50994511e84e965ee4a0ca5">CSLib_NormalStatus</a> &amp;theStatus, <a class="el" href="classgp___dir.html">gp_Dir</a> &amp;Normal, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;OrderU, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;OrderV)</td></tr>
<tr class="memdesc:a53832beed9902420479041ff397b00be"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the first order k0 of deriviative of NUV where: foreach order &lt; k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.  <a href="#a53832beed9902420479041ff397b00be">More...</a><br /></td></tr>
<tr class="separator:a53832beed9902420479041ff397b00be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e76de2f60b313957963d31602d12a42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#a3e76de2f60b313957963d31602d12a42">DNNUV</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv, const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;DerSurf)</td></tr>
<tr class="memdesc:a3e76de2f60b313957963d31602d12a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">&ndash; Computes the derivative of order Nu in the &ndash; direction U and Nv in the direction V of the not &ndash; normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1  <a href="#a3e76de2f60b313957963d31602d12a42">More...</a><br /></td></tr>
<tr class="separator:a3e76de2f60b313957963d31602d12a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d98a0aba92106725fcfab1bed30f37d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#a9d98a0aba92106725fcfab1bed30f37d">DNNUV</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv, const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;DerSurf1, const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;DerSurf2)</td></tr>
<tr class="memdesc:a9d98a0aba92106725fcfab1bed30f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1.  <a href="#a9d98a0aba92106725fcfab1bed30f37d">More...</a><br /></td></tr>
<tr class="separator:a9d98a0aba92106725fcfab1bed30f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fff09258ed84511cee214b771ed6cc9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_s_lib.html#a4fff09258ed84511cee214b771ed6cc9">DNNormal</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv, const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;DerNUV, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Iduref=0, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Idvref=0)</td></tr>
<tr class="memdesc:a4fff09258ed84511cee214b771ed6cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">&ndash; Computes the derivative of order Nu in the &ndash; direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0.  <a href="#a4fff09258ed84511cee214b771ed6cc9">More...</a><br /></td></tr>
<tr class="separator:a4fff09258ed84511cee214b771ed6cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This package implements functions for basis geometric computation on curves and surfaces. The tolerance criterions used in this package are Resolution from package gp and RealEpsilon from class Real of package <a class="el" href="class_standard.html" title="The package Standard provides global memory allocator and other basic services used by other OCCT com...">Standard</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4fff09258ed84511cee214b771ed6cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fff09258ed84511cee214b771ed6cc9">&#9670;&nbsp;</a></span>DNNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgp___vec.html">gp_Vec</a> CSLib::DNNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;&#160;</td>
          <td class="paramname"><em>DerNUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Iduref</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Idvref</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&ndash; Computes the derivative of order Nu in the &ndash; direction U and Nv in the direction V of the normalized normal vector at the point P(U,V) array DerNUV contain the derivative (i+Iduref,j+Idvref) of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref correspond to a derivative of D1U ^ D1V which can be used to compute the normalized normal vector. In the regular cases , Iduref=Idvref=0. </p>

</div>
</div>
<a id="a3e76de2f60b313957963d31602d12a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e76de2f60b313957963d31602d12a42">&#9670;&nbsp;</a></span>DNNUV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgp___vec.html">gp_Vec</a> CSLib::DNNUV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;&#160;</td>
          <td class="paramname"><em>DerSurf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&ndash; Computes the derivative of order Nu in the &ndash; direction U and Nv in the direction V of the not &ndash; normalized normal vector at the point P(U,V) The array DerSurf contain the derivative (i,j) of the surface for i=0,Nu+1 ; j=0,Nv+1 </p>

</div>
</div>
<a id="a9d98a0aba92106725fcfab1bed30f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d98a0aba92106725fcfab1bed30f37d">&#9670;&nbsp;</a></span>DNNUV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgp___vec.html">gp_Vec</a> CSLib::DNNUV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;&#160;</td>
          <td class="paramname"><em>DerSurf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;&#160;</td>
          <td class="paramname"><em>DerSurf2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1. </p>

</div>
</div>
<a id="ab6c92e11874e821a4b6be3f7859e18b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c92e11874e821a4b6be3f7859e18b6">&#9670;&nbsp;</a></span>Normal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSLib::Normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>SinTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_s_lib___derivative_status_8hxx.html#ac25c8dfe2d5d06f0f25b9907cfc1f853">CSLib_DerivativeStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>theStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___dir.html">gp_Dir</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions computes the normal to a surface inherits FunctionWithDerivative from math. </p>
<p>Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if theStatus == Done else the theStatus gives the reason why the computation has failed. </p>

</div>
</div>
<a id="a1afa1fb092dce089d9d5ba9f3d08dc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afa1fb092dce089d9d5ba9f3d08dc17">&#9670;&nbsp;</a></span>Normal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSLib::Normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>SinTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a03b92feca37cfb9c80cb41a5f6df6cef">Standard_Boolean</a> &amp;&#160;</td>
          <td class="paramname"><em>Done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_s_lib___normal_status_8hxx.html#a7ea38358d50994511e84e965ee4a0ca5">CSLib_NormalStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>theStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___dir.html">gp_Dir</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps-&gt;0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv||. </p>
<p>. if DNu IsNull (DNu &lt;= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv &lt;= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface. </p>

</div>
</div>
<a id="a61f977764da86cc141ea1c9515f87dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f977764da86cc141ea1c9515f87dd9">&#9670;&nbsp;</a></span>Normal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSLib::Normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>MagTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_s_lib___normal_status_8hxx.html#a7ea38358d50994511e84e965ee4a0ca5">CSLib_NormalStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>theStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___dir.html">gp_Dir</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the normal direction of a surface as the cross product between D1U and D1V. </p>

</div>
</div>
<a id="a53832beed9902420479041ff397b00be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53832beed9902420479041ff397b00be">&#9670;&nbsp;</a></span>Normal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSLib::Normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>MaxOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_vec_8hxx.html#a89f78077b340471e8414d4172a188fba">TColgp_Array2OfVec</a> &amp;&#160;</td>
          <td class="paramname"><em>DerNUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>MagTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Umin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Umax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Vmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Vmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_s_lib___normal_status_8hxx.html#a7ea38358d50994511e84e965ee4a0ca5">CSLib_NormalStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>theStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___dir.html">gp_Dir</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>OrderU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>OrderV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the first order k0 of deriviative of NUV where: foreach order &lt; k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_s_lib_8hxx.html">CSLib.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

